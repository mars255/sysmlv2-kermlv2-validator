# Generated from ./KerMLv2.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,150,2256,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
        7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,
        2,170,7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,
        7,175,2,176,7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,
        2,181,7,181,2,182,7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,
        7,186,2,187,7,187,2,188,7,188,2,189,7,189,2,190,7,190,2,191,7,191,
        2,192,7,192,2,193,7,193,2,194,7,194,2,195,7,195,2,196,7,196,2,197,
        7,197,2,198,7,198,2,199,7,199,2,200,7,200,2,201,7,201,2,202,7,202,
        2,203,7,203,2,204,7,204,2,205,7,205,2,206,7,206,2,207,7,207,2,208,
        7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,7,212,2,213,7,213,
        2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,7,218,2,219,
        7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,7,224,
        2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
        7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,
        2,236,7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,
        7,241,2,242,7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,
        2,247,7,247,2,248,7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,
        7,252,2,253,7,253,2,254,7,254,2,255,7,255,2,256,7,256,2,257,7,257,
        1,0,1,0,1,0,1,1,5,1,521,8,1,10,1,12,1,524,9,1,1,2,1,2,1,2,1,2,3,
        2,530,8,2,1,2,3,2,533,8,2,1,3,1,3,1,3,5,3,538,8,3,10,3,12,3,541,
        9,3,1,3,3,3,544,8,3,1,4,1,4,3,4,548,8,4,1,5,1,5,3,5,552,8,5,1,6,
        5,6,555,8,6,10,6,12,6,558,9,6,1,6,1,6,3,6,562,8,6,1,6,3,6,565,8,
        6,1,6,1,6,1,6,5,6,570,8,6,10,6,12,6,573,9,6,1,6,1,6,1,6,1,6,5,6,
        579,8,6,10,6,12,6,582,9,6,1,6,1,6,1,7,1,7,1,8,1,8,1,9,1,9,1,9,1,
        9,3,9,594,8,9,1,10,1,10,3,10,598,8,10,1,10,1,10,1,10,1,10,5,10,604,
        8,10,10,10,12,10,607,9,10,3,10,609,8,10,3,10,611,8,10,1,10,1,10,
        3,10,615,8,10,1,10,1,10,1,11,1,11,3,11,621,8,11,1,11,1,11,3,11,625,
        8,11,1,11,1,11,1,12,1,12,3,12,631,8,12,3,12,633,8,12,1,12,1,12,1,
        12,1,12,1,13,5,13,640,8,13,10,13,12,13,643,9,13,1,13,1,13,1,13,1,
        14,1,14,3,14,650,8,14,1,15,1,15,1,15,1,15,1,15,5,15,657,8,15,10,
        15,12,15,660,9,15,1,15,3,15,663,8,15,1,16,1,16,1,16,3,16,668,8,16,
        1,17,3,17,671,8,17,1,18,1,18,3,18,675,8,18,1,19,1,19,1,19,1,20,1,
        20,1,20,1,21,1,21,1,21,1,21,1,21,1,21,3,21,689,8,21,1,21,3,21,692,
        8,21,1,21,1,21,1,21,1,21,1,22,3,22,699,8,22,1,22,1,22,3,22,703,8,
        22,1,23,1,23,3,23,707,8,23,1,23,1,23,1,24,1,24,1,24,1,25,1,25,1,
        25,3,25,717,8,25,1,26,1,26,1,26,3,26,722,8,26,1,27,1,27,1,27,1,27,
        1,27,3,27,729,8,27,1,28,1,28,4,28,733,8,28,11,28,12,28,734,1,29,
        1,29,3,29,739,8,29,1,30,1,30,1,31,1,31,1,32,1,32,1,32,1,32,1,33,
        1,33,3,33,751,8,33,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,
        1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,
        1,34,1,34,1,34,1,34,3,34,779,8,34,1,35,1,35,1,35,1,35,1,35,1,35,
        1,35,1,35,1,35,1,35,3,35,791,8,35,1,36,5,36,794,8,36,10,36,12,36,
        797,9,36,1,36,1,36,1,36,1,37,3,37,803,8,37,1,37,1,37,5,37,807,8,
        37,10,37,12,37,810,9,37,1,37,1,37,1,37,1,38,1,38,3,38,817,8,38,1,
        39,1,39,1,39,1,39,1,39,1,39,5,39,825,8,39,10,39,12,39,828,9,39,1,
        39,3,39,831,8,39,1,40,1,40,1,40,1,40,1,40,1,41,3,41,839,8,41,1,41,
        5,41,842,8,41,10,41,12,41,845,9,41,1,42,1,42,1,42,1,42,1,42,1,43,
        3,43,853,8,43,1,43,3,43,856,8,43,1,43,3,43,859,8,43,1,43,1,43,3,
        43,863,8,43,1,43,5,43,866,8,43,10,43,12,43,869,9,43,1,44,1,44,1,
        44,1,44,5,44,875,8,44,10,44,12,44,878,9,44,1,45,1,45,1,45,1,46,1,
        46,1,46,1,46,3,46,887,8,46,1,47,1,47,1,47,1,47,1,47,5,47,894,8,47,
        10,47,12,47,897,9,47,1,48,1,48,1,48,1,48,5,48,903,8,48,10,48,12,
        48,906,9,48,1,49,1,49,1,49,1,49,5,49,912,8,49,10,49,12,49,915,9,
        49,1,50,1,50,1,50,1,50,5,50,921,8,50,10,50,12,50,924,9,50,1,51,1,
        51,1,51,1,51,1,51,1,51,5,51,932,8,51,10,51,12,51,935,9,51,1,51,3,
        51,938,8,51,1,52,1,52,3,52,942,8,52,1,53,1,53,1,53,1,53,1,54,1,54,
        1,54,1,55,1,55,3,55,953,8,55,3,55,955,8,55,1,55,1,55,1,55,3,55,960,
        8,55,1,55,1,55,1,55,3,55,965,8,55,1,55,1,55,1,56,1,56,3,56,971,8,
        56,1,57,1,57,3,57,975,8,57,3,57,977,8,57,1,57,1,57,1,57,3,57,982,
        8,57,1,57,1,57,1,57,3,57,987,8,57,1,57,1,57,1,58,1,58,3,58,993,8,
        58,1,59,1,59,3,59,997,8,59,3,59,999,8,59,1,59,1,59,1,59,3,59,1004,
        8,59,1,59,1,59,1,59,3,59,1009,8,59,1,59,1,59,1,60,1,60,3,60,1015,
        8,60,1,61,1,61,3,61,1019,8,61,1,62,1,62,3,62,1023,8,62,1,63,1,63,
        3,63,1027,8,63,1,64,1,64,1,64,1,64,1,64,1,65,3,65,1035,8,65,1,65,
        3,65,1038,8,65,1,65,3,65,1041,8,65,1,65,1,65,3,65,1045,8,65,1,65,
        5,65,1048,8,65,10,65,12,65,1051,9,65,1,66,1,66,1,66,1,66,5,66,1057,
        8,66,10,66,12,66,1060,9,66,1,67,1,67,1,67,1,68,1,68,3,68,1067,8,
        68,3,68,1069,8,68,1,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,1,70,1,
        70,1,71,3,71,1082,8,71,1,71,3,71,1085,8,71,1,71,3,71,1088,8,71,1,
        71,3,71,1091,8,71,1,71,3,71,1094,8,71,1,71,3,71,1097,8,71,1,71,5,
        71,1100,8,71,10,71,12,71,1103,9,71,1,72,1,72,3,72,1107,8,72,1,72,
        1,72,1,72,3,72,1112,8,72,1,72,3,72,1115,8,72,1,72,1,72,1,73,3,73,
        1120,8,73,1,73,1,73,1,73,3,73,1125,8,73,1,73,1,73,3,73,1129,8,73,
        1,73,5,73,1132,8,73,10,73,12,73,1135,9,73,1,74,1,74,1,74,1,74,3,
        74,1141,8,74,1,75,1,75,1,75,3,75,1146,8,75,1,76,1,76,1,76,1,76,1,
        77,1,77,1,77,1,77,1,77,5,77,1157,8,77,10,77,12,77,1160,9,77,1,78,
        4,78,1163,8,78,11,78,12,78,1164,1,78,3,78,1168,8,78,1,78,5,78,1171,
        8,78,10,78,12,78,1174,9,78,1,78,1,78,5,78,1178,8,78,10,78,12,78,
        1181,9,78,3,78,1183,8,78,1,79,1,79,3,79,1187,8,79,1,79,1,79,3,79,
        1191,8,79,1,79,1,79,3,79,1195,8,79,3,79,1197,8,79,3,79,1199,8,79,
        1,80,1,80,1,80,1,80,3,80,1205,8,80,1,81,1,81,1,81,5,81,1210,8,81,
        10,81,12,81,1213,9,81,1,82,1,82,1,82,3,82,1218,8,82,1,82,1,82,1,
        83,1,83,1,83,5,83,1225,8,83,10,83,12,83,1228,9,83,1,84,1,84,1,84,
        1,85,1,85,1,85,1,86,1,86,3,86,1238,8,86,1,87,1,87,1,87,5,87,1243,
        8,87,10,87,12,87,1246,9,87,1,88,1,88,1,88,1,89,1,89,3,89,1253,8,
        89,3,89,1255,8,89,1,89,1,89,1,89,3,89,1260,8,89,1,89,1,89,1,89,3,
        89,1265,8,89,1,89,1,89,1,90,1,90,3,90,1271,8,90,1,91,1,91,3,91,1275,
        8,91,1,91,3,91,1278,8,91,1,91,1,91,1,91,1,91,1,91,1,92,1,92,1,93,
        1,93,3,93,1289,8,93,3,93,1291,8,93,1,93,1,93,1,93,1,93,1,93,3,93,
        1298,8,93,1,93,1,93,1,93,1,94,1,94,1,95,1,95,3,95,1307,8,95,1,96,
        1,96,3,96,1311,8,96,3,96,1313,8,96,1,96,1,96,1,96,3,96,1318,8,96,
        1,96,1,96,1,96,3,96,1323,8,96,1,96,1,96,1,97,1,97,3,97,1329,8,97,
        1,98,1,98,3,98,1333,8,98,1,99,1,99,3,99,1337,8,99,3,99,1339,8,99,
        1,99,1,99,1,99,3,99,1344,8,99,1,99,1,99,1,99,3,99,1349,8,99,1,99,
        1,99,1,100,1,100,3,100,1355,8,100,1,101,1,101,1,101,1,102,1,102,
        1,103,1,103,1,104,1,104,1,104,1,104,3,104,1368,8,104,3,104,1370,
        8,104,1,104,1,104,1,105,1,105,3,105,1376,8,105,1,106,1,106,3,106,
        1380,8,106,1,106,1,106,1,106,1,107,1,107,3,107,1387,8,107,1,107,
        1,107,1,107,1,108,1,108,1,109,1,109,1,110,1,110,1,110,1,110,3,110,
        1400,8,110,1,110,1,110,1,111,1,111,3,111,1406,8,111,1,112,1,112,
        1,112,1,112,1,112,1,113,1,113,1,113,1,113,1,113,1,114,1,114,1,114,
        1,114,1,114,1,115,1,115,1,115,1,115,1,115,1,116,1,116,1,116,1,116,
        1,116,1,116,1,117,1,117,1,117,3,117,1437,8,117,1,117,3,117,1440,
        8,117,1,117,3,117,1443,8,117,1,117,1,117,1,118,1,118,3,118,1449,
        8,118,1,119,3,119,1452,8,119,1,119,1,119,1,119,3,119,1457,8,119,
        3,119,1459,8,119,1,119,1,119,1,119,1,119,1,120,3,120,1466,8,120,
        1,120,1,120,1,120,1,120,1,120,1,120,5,120,1474,8,120,10,120,12,120,
        1477,9,120,1,120,1,120,1,121,1,121,1,122,1,122,1,122,3,122,1486,
        8,122,1,122,1,122,3,122,1490,8,122,1,123,1,123,1,123,1,123,1,123,
        1,124,1,124,1,124,1,124,1,124,1,124,3,124,1503,8,124,1,124,3,124,
        1506,8,124,1,124,3,124,1509,8,124,1,124,1,124,1,124,1,124,3,124,
        1515,8,124,3,124,1517,8,124,1,125,1,125,1,125,1,125,1,125,1,126,
        1,126,1,126,1,126,1,126,1,126,3,126,1530,8,126,1,126,3,126,1533,
        8,126,1,126,3,126,1536,8,126,1,126,1,126,1,126,1,126,3,126,1542,
        8,126,3,126,1544,8,126,1,127,1,127,1,127,1,127,1,127,1,128,1,128,
        1,128,1,128,1,128,1,129,3,129,1557,8,129,1,129,3,129,1560,8,129,
        1,130,1,130,1,130,1,130,1,130,1,131,1,131,1,131,1,131,1,131,3,131,
        1572,8,131,1,132,1,132,1,132,1,132,1,132,5,132,1579,8,132,10,132,
        12,132,1582,9,132,1,132,3,132,1585,8,132,1,133,1,133,1,133,1,133,
        1,134,1,134,1,134,1,135,1,135,1,135,1,135,1,135,1,136,3,136,1600,
        8,136,1,136,3,136,1603,8,136,1,137,1,137,1,137,1,137,1,137,1,138,
        1,138,1,138,1,138,1,138,1,139,1,139,1,139,3,139,1618,8,139,1,139,
        1,139,1,139,1,140,1,140,1,140,1,140,1,140,1,141,1,141,1,141,1,141,
        1,141,1,142,1,142,1,142,1,142,1,142,1,142,1,143,3,143,1640,8,143,
        1,143,3,143,1643,8,143,1,143,1,143,3,143,1647,8,143,1,143,1,143,
        1,143,1,143,1,143,3,143,1654,8,143,1,143,3,143,1657,8,143,1,143,
        1,143,1,143,1,143,3,143,1663,8,143,1,144,1,144,1,145,3,145,1668,
        8,145,1,145,1,145,3,145,1672,8,145,1,145,3,145,1675,8,145,1,145,
        1,145,1,145,3,145,1680,8,145,1,145,1,145,1,145,3,145,1685,8,145,
        1,146,4,146,1688,8,146,11,146,12,146,1689,1,146,3,146,1693,8,146,
        1,146,5,146,1696,8,146,10,146,12,146,1699,9,146,1,146,1,146,4,146,
        1703,8,146,11,146,12,146,1704,3,146,1707,8,146,1,147,1,147,1,148,
        3,148,1712,8,148,1,148,1,148,1,149,1,149,1,149,1,149,3,149,1720,
        8,149,1,150,1,150,1,150,4,150,1725,8,150,11,150,12,150,1726,1,150,
        1,150,1,150,1,151,1,151,1,152,1,152,1,153,1,153,1,154,1,154,1,154,
        1,154,1,154,1,155,1,155,1,155,1,156,1,156,1,156,1,157,1,157,1,158,
        5,158,1752,8,158,10,158,12,158,1755,9,158,1,158,1,158,1,158,1,158,
        1,158,1,158,5,158,1763,8,158,10,158,12,158,1766,9,158,3,158,1768,
        8,158,1,158,1,158,1,159,1,159,1,159,1,159,3,159,1776,8,159,3,159,
        1778,8,159,1,159,1,159,1,160,1,160,1,161,1,161,1,161,1,161,1,161,
        1,161,5,161,1790,8,161,10,161,12,161,1793,9,161,1,161,3,161,1796,
        8,161,1,162,1,162,1,163,3,163,1801,8,163,1,163,3,163,1804,8,163,
        1,163,1,163,3,163,1808,8,163,1,163,3,163,1811,8,163,1,163,1,163,
        1,164,1,164,1,164,1,164,1,165,1,165,1,166,1,166,1,167,1,167,1,168,
        1,168,1,168,1,168,1,168,1,168,1,168,1,168,3,168,1833,8,168,1,169,
        1,169,1,170,1,170,1,170,1,170,5,170,1841,8,170,10,170,12,170,1844,
        9,170,1,171,1,171,1,172,1,172,1,173,1,173,1,174,1,174,1,174,1,174,
        5,174,1856,8,174,10,174,12,174,1859,9,174,1,175,1,175,1,176,1,176,
        1,177,1,177,1,178,1,178,1,178,1,178,1,178,1,178,1,178,3,178,1874,
        8,178,5,178,1876,8,178,10,178,12,178,1879,9,178,1,179,1,179,1,180,
        1,180,1,181,1,181,1,182,1,182,1,183,1,183,1,183,1,183,5,183,1893,
        8,183,10,183,12,183,1896,9,183,1,184,1,184,1,185,1,185,1,185,1,185,
        1,185,1,185,1,185,3,185,1907,8,185,5,185,1909,8,185,10,185,12,185,
        1912,9,185,1,186,1,186,1,187,1,187,1,188,1,188,1,189,1,189,1,190,
        1,190,1,190,1,190,5,190,1926,8,190,10,190,12,190,1929,9,190,1,191,
        1,191,1,191,1,191,3,191,1935,8,191,1,192,1,192,1,192,1,192,1,192,
        1,192,1,192,3,192,1944,8,192,1,192,1,192,1,192,1,192,1,192,1,192,
        1,192,1,192,1,192,1,192,1,192,1,192,1,192,1,192,1,192,1,192,3,192,
        1962,8,192,1,193,1,193,1,193,3,193,1967,8,193,1,194,1,194,1,195,
        1,195,1,196,1,196,1,197,1,197,1,198,1,198,1,199,1,199,1,200,1,200,
        1,201,1,201,1,202,1,202,1,203,1,203,1,204,1,204,1,205,1,205,1,205,
        1,205,5,205,1995,8,205,10,205,12,205,1998,9,205,1,206,1,206,1,206,
        1,206,3,206,2004,8,206,1,207,1,207,1,207,3,207,2009,8,207,1,208,
        1,208,1,208,1,208,5,208,2015,8,208,10,208,12,208,2018,9,208,1,209,
        1,209,3,209,2022,8,209,1,210,1,210,1,210,1,210,5,210,2028,8,210,
        10,210,12,210,2031,9,210,1,211,1,211,1,211,3,211,2036,8,211,1,212,
        1,212,1,212,1,212,3,212,2042,8,212,1,213,1,213,3,213,2046,8,213,
        1,214,1,214,1,214,1,214,3,214,2052,8,214,1,215,1,215,1,215,1,215,
        3,215,2058,8,215,1,216,1,216,1,216,3,216,2063,8,216,1,217,1,217,
        1,217,3,217,2068,8,217,1,217,1,217,1,217,1,217,1,217,1,217,1,217,
        1,217,1,217,1,217,1,217,1,217,1,217,1,217,3,217,2084,8,217,1,217,
        1,217,1,217,1,217,3,217,2090,8,217,1,217,1,217,3,217,2094,8,217,
        5,217,2096,8,217,10,217,12,217,2099,9,217,1,218,1,218,1,219,1,219,
        1,220,1,220,1,221,1,221,3,221,2109,8,221,1,222,1,222,1,222,1,222,
        1,222,1,222,1,222,1,222,1,222,1,222,3,222,2121,8,222,1,223,1,223,
        1,224,1,224,1,225,1,225,1,226,1,226,1,226,1,226,3,226,2133,8,226,
        1,227,1,227,1,228,1,228,1,229,1,229,1,229,1,229,1,230,1,230,1,230,
        1,231,1,231,1,232,1,232,1,232,4,232,2151,8,232,11,232,12,232,2152,
        1,233,1,233,1,234,1,234,1,234,3,234,2160,8,234,1,234,1,234,1,235,
        1,235,1,235,5,235,2167,8,235,10,235,12,235,2170,9,235,1,236,1,236,
        1,237,1,237,1,238,1,238,1,238,5,238,2179,8,238,10,238,12,238,2182,
        9,238,1,239,1,239,1,240,1,240,1,240,1,240,1,241,1,241,1,242,1,242,
        1,243,1,243,1,243,3,243,2197,8,243,1,244,1,244,1,244,1,244,1,244,
        3,244,2204,8,244,1,245,1,245,1,246,1,246,3,246,2210,8,246,1,247,
        1,247,1,248,1,248,1,249,1,249,1,250,3,250,2219,8,250,1,250,1,250,
        1,250,3,250,2224,8,250,1,251,1,251,1,252,1,252,3,252,2230,8,252,
        1,253,1,253,1,253,4,253,2235,8,253,11,253,12,253,2236,1,254,3,254,
        2240,8,254,1,254,1,254,1,255,1,255,1,256,1,256,1,256,3,256,2249,
        8,256,1,257,1,257,1,257,3,257,2254,8,257,1,257,0,0,258,0,2,4,6,8,
        10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,
        54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,
        98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,
        132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,
        164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,
        196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,
        228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,
        260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,
        292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,
        324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,
        356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,
        388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,
        420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,
        452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,
        484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,
        0,9,2,0,21,21,113,113,2,0,22,22,114,114,1,0,35,36,2,0,49,49,113,
        113,2,0,51,51,117,117,1,0,118,119,1,0,76,77,2,0,81,81,123,123,1,
        0,142,143,2347,0,516,1,0,0,0,2,522,1,0,0,0,4,532,1,0,0,0,6,543,1,
        0,0,0,8,547,1,0,0,0,10,551,1,0,0,0,12,556,1,0,0,0,14,585,1,0,0,0,
        16,587,1,0,0,0,18,593,1,0,0,0,20,610,1,0,0,0,22,618,1,0,0,0,24,632,
        1,0,0,0,26,641,1,0,0,0,28,647,1,0,0,0,30,662,1,0,0,0,32,667,1,0,
        0,0,34,670,1,0,0,0,36,674,1,0,0,0,38,676,1,0,0,0,40,679,1,0,0,0,
        42,682,1,0,0,0,44,698,1,0,0,0,46,706,1,0,0,0,48,710,1,0,0,0,50,713,
        1,0,0,0,52,718,1,0,0,0,54,723,1,0,0,0,56,730,1,0,0,0,58,738,1,0,
        0,0,60,740,1,0,0,0,62,742,1,0,0,0,64,744,1,0,0,0,66,750,1,0,0,0,
        68,778,1,0,0,0,70,790,1,0,0,0,72,795,1,0,0,0,74,802,1,0,0,0,76,814,
        1,0,0,0,78,830,1,0,0,0,80,832,1,0,0,0,82,838,1,0,0,0,84,846,1,0,
        0,0,86,852,1,0,0,0,88,870,1,0,0,0,90,879,1,0,0,0,92,886,1,0,0,0,
        94,888,1,0,0,0,96,898,1,0,0,0,98,907,1,0,0,0,100,916,1,0,0,0,102,
        937,1,0,0,0,104,941,1,0,0,0,106,943,1,0,0,0,108,947,1,0,0,0,110,
        954,1,0,0,0,112,970,1,0,0,0,114,976,1,0,0,0,116,992,1,0,0,0,118,
        998,1,0,0,0,120,1014,1,0,0,0,122,1018,1,0,0,0,124,1022,1,0,0,0,126,
        1026,1,0,0,0,128,1028,1,0,0,0,130,1034,1,0,0,0,132,1052,1,0,0,0,
        134,1061,1,0,0,0,136,1068,1,0,0,0,138,1076,1,0,0,0,140,1078,1,0,
        0,0,142,1081,1,0,0,0,144,1104,1,0,0,0,146,1119,1,0,0,0,148,1140,
        1,0,0,0,150,1142,1,0,0,0,152,1147,1,0,0,0,154,1151,1,0,0,0,156,1182,
        1,0,0,0,158,1198,1,0,0,0,160,1204,1,0,0,0,162,1206,1,0,0,0,164,1217,
        1,0,0,0,166,1221,1,0,0,0,168,1229,1,0,0,0,170,1232,1,0,0,0,172,1237,
        1,0,0,0,174,1239,1,0,0,0,176,1247,1,0,0,0,178,1254,1,0,0,0,180,1270,
        1,0,0,0,182,1272,1,0,0,0,184,1284,1,0,0,0,186,1290,1,0,0,0,188,1302,
        1,0,0,0,190,1306,1,0,0,0,192,1312,1,0,0,0,194,1328,1,0,0,0,196,1332,
        1,0,0,0,198,1338,1,0,0,0,200,1354,1,0,0,0,202,1356,1,0,0,0,204,1359,
        1,0,0,0,206,1361,1,0,0,0,208,1369,1,0,0,0,210,1375,1,0,0,0,212,1377,
        1,0,0,0,214,1384,1,0,0,0,216,1391,1,0,0,0,218,1393,1,0,0,0,220,1395,
        1,0,0,0,222,1405,1,0,0,0,224,1407,1,0,0,0,226,1412,1,0,0,0,228,1417,
        1,0,0,0,230,1422,1,0,0,0,232,1427,1,0,0,0,234,1433,1,0,0,0,236,1448,
        1,0,0,0,238,1458,1,0,0,0,240,1465,1,0,0,0,242,1480,1,0,0,0,244,1485,
        1,0,0,0,246,1491,1,0,0,0,248,1516,1,0,0,0,250,1518,1,0,0,0,252,1543,
        1,0,0,0,254,1545,1,0,0,0,256,1550,1,0,0,0,258,1556,1,0,0,0,260,1561,
        1,0,0,0,262,1571,1,0,0,0,264,1580,1,0,0,0,266,1586,1,0,0,0,268,1590,
        1,0,0,0,270,1593,1,0,0,0,272,1599,1,0,0,0,274,1604,1,0,0,0,276,1609,
        1,0,0,0,278,1614,1,0,0,0,280,1622,1,0,0,0,282,1627,1,0,0,0,284,1632,
        1,0,0,0,286,1662,1,0,0,0,288,1664,1,0,0,0,290,1684,1,0,0,0,292,1706,
        1,0,0,0,294,1708,1,0,0,0,296,1711,1,0,0,0,298,1719,1,0,0,0,300,1724,
        1,0,0,0,302,1731,1,0,0,0,304,1733,1,0,0,0,306,1735,1,0,0,0,308,1737,
        1,0,0,0,310,1742,1,0,0,0,312,1745,1,0,0,0,314,1748,1,0,0,0,316,1753,
        1,0,0,0,318,1777,1,0,0,0,320,1781,1,0,0,0,322,1795,1,0,0,0,324,1797,
        1,0,0,0,326,1800,1,0,0,0,328,1814,1,0,0,0,330,1818,1,0,0,0,332,1820,
        1,0,0,0,334,1822,1,0,0,0,336,1832,1,0,0,0,338,1834,1,0,0,0,340,1836,
        1,0,0,0,342,1845,1,0,0,0,344,1847,1,0,0,0,346,1849,1,0,0,0,348,1851,
        1,0,0,0,350,1860,1,0,0,0,352,1862,1,0,0,0,354,1864,1,0,0,0,356,1866,
        1,0,0,0,358,1880,1,0,0,0,360,1882,1,0,0,0,362,1884,1,0,0,0,364,1886,
        1,0,0,0,366,1888,1,0,0,0,368,1897,1,0,0,0,370,1899,1,0,0,0,372,1913,
        1,0,0,0,374,1915,1,0,0,0,376,1917,1,0,0,0,378,1919,1,0,0,0,380,1921,
        1,0,0,0,382,1934,1,0,0,0,384,1961,1,0,0,0,386,1966,1,0,0,0,388,1968,
        1,0,0,0,390,1970,1,0,0,0,392,1972,1,0,0,0,394,1974,1,0,0,0,396,1976,
        1,0,0,0,398,1978,1,0,0,0,400,1980,1,0,0,0,402,1982,1,0,0,0,404,1984,
        1,0,0,0,406,1986,1,0,0,0,408,1988,1,0,0,0,410,1990,1,0,0,0,412,2003,
        1,0,0,0,414,2005,1,0,0,0,416,2010,1,0,0,0,418,2021,1,0,0,0,420,2023,
        1,0,0,0,422,2035,1,0,0,0,424,2037,1,0,0,0,426,2045,1,0,0,0,428,2051,
        1,0,0,0,430,2057,1,0,0,0,432,2062,1,0,0,0,434,2064,1,0,0,0,436,2100,
        1,0,0,0,438,2102,1,0,0,0,440,2104,1,0,0,0,442,2108,1,0,0,0,444,2120,
        1,0,0,0,446,2122,1,0,0,0,448,2124,1,0,0,0,450,2126,1,0,0,0,452,2128,
        1,0,0,0,454,2134,1,0,0,0,456,2136,1,0,0,0,458,2138,1,0,0,0,460,2142,
        1,0,0,0,462,2145,1,0,0,0,464,2147,1,0,0,0,466,2154,1,0,0,0,468,2156,
        1,0,0,0,470,2163,1,0,0,0,472,2171,1,0,0,0,474,2173,1,0,0,0,476,2175,
        1,0,0,0,478,2183,1,0,0,0,480,2185,1,0,0,0,482,2189,1,0,0,0,484,2191,
        1,0,0,0,486,2196,1,0,0,0,488,2203,1,0,0,0,490,2205,1,0,0,0,492,2209,
        1,0,0,0,494,2211,1,0,0,0,496,2213,1,0,0,0,498,2215,1,0,0,0,500,2223,
        1,0,0,0,502,2225,1,0,0,0,504,2229,1,0,0,0,506,2234,1,0,0,0,508,2239,
        1,0,0,0,510,2243,1,0,0,0,512,2248,1,0,0,0,514,2253,1,0,0,0,516,517,
        3,2,1,0,517,518,5,0,0,1,518,1,1,0,0,0,519,521,3,32,16,0,520,519,
        1,0,0,0,521,524,1,0,0,0,522,520,1,0,0,0,522,523,1,0,0,0,523,3,1,
        0,0,0,524,522,1,0,0,0,525,526,5,100,0,0,526,527,3,504,252,0,527,
        529,5,101,0,0,528,530,3,504,252,0,529,528,1,0,0,0,529,530,1,0,0,
        0,530,533,1,0,0,0,531,533,3,504,252,0,532,525,1,0,0,0,532,531,1,
        0,0,0,533,5,1,0,0,0,534,544,5,108,0,0,535,539,5,102,0,0,536,538,
        3,8,4,0,537,536,1,0,0,0,538,541,1,0,0,0,539,537,1,0,0,0,539,540,
        1,0,0,0,540,542,1,0,0,0,541,539,1,0,0,0,542,544,5,103,0,0,543,534,
        1,0,0,0,543,535,1,0,0,0,544,7,1,0,0,0,545,548,3,10,5,0,546,548,3,
        16,8,0,547,545,1,0,0,0,547,546,1,0,0,0,548,9,1,0,0,0,549,552,3,68,
        34,0,550,552,3,70,35,0,551,549,1,0,0,0,551,550,1,0,0,0,552,11,1,
        0,0,0,553,555,3,310,155,0,554,553,1,0,0,0,555,558,1,0,0,0,556,554,
        1,0,0,0,556,557,1,0,0,0,557,559,1,0,0,0,558,556,1,0,0,0,559,564,
        5,1,0,0,560,562,3,4,2,0,561,560,1,0,0,0,561,562,1,0,0,0,562,563,
        1,0,0,0,563,565,5,2,0,0,564,561,1,0,0,0,564,565,1,0,0,0,565,566,
        1,0,0,0,566,571,3,508,254,0,567,568,5,109,0,0,568,570,3,508,254,
        0,569,567,1,0,0,0,570,573,1,0,0,0,571,569,1,0,0,0,571,572,1,0,0,
        0,572,574,1,0,0,0,573,571,1,0,0,0,574,575,5,3,0,0,575,580,3,508,
        254,0,576,577,5,109,0,0,577,579,3,508,254,0,578,576,1,0,0,0,579,
        582,1,0,0,0,580,578,1,0,0,0,580,581,1,0,0,0,581,583,1,0,0,0,582,
        580,1,0,0,0,583,584,3,6,3,0,584,13,1,0,0,0,585,586,3,508,254,0,586,
        15,1,0,0,0,587,588,3,18,9,0,588,17,1,0,0,0,589,594,3,20,10,0,590,
        594,3,22,11,0,591,594,3,24,12,0,592,594,3,316,158,0,593,589,1,0,
        0,0,593,590,1,0,0,0,593,591,1,0,0,0,593,592,1,0,0,0,594,19,1,0,0,
        0,595,597,5,4,0,0,596,598,3,4,2,0,597,596,1,0,0,0,597,598,1,0,0,
        0,598,608,1,0,0,0,599,600,5,5,0,0,600,605,3,14,7,0,601,602,5,109,
        0,0,602,604,3,14,7,0,603,601,1,0,0,0,604,607,1,0,0,0,605,603,1,0,
        0,0,605,606,1,0,0,0,606,609,1,0,0,0,607,605,1,0,0,0,608,599,1,0,
        0,0,608,609,1,0,0,0,609,611,1,0,0,0,610,595,1,0,0,0,610,611,1,0,
        0,0,611,614,1,0,0,0,612,613,5,6,0,0,613,615,5,146,0,0,614,612,1,
        0,0,0,614,615,1,0,0,0,615,616,1,0,0,0,616,617,5,147,0,0,617,21,1,
        0,0,0,618,620,5,7,0,0,619,621,3,4,2,0,620,619,1,0,0,0,620,621,1,
        0,0,0,621,624,1,0,0,0,622,623,5,6,0,0,623,625,5,146,0,0,624,622,
        1,0,0,0,624,625,1,0,0,0,625,626,1,0,0,0,626,627,5,147,0,0,627,23,
        1,0,0,0,628,630,5,8,0,0,629,631,3,4,2,0,630,629,1,0,0,0,630,631,
        1,0,0,0,631,633,1,0,0,0,632,628,1,0,0,0,632,633,1,0,0,0,633,634,
        1,0,0,0,634,635,5,9,0,0,635,636,5,146,0,0,636,637,5,147,0,0,637,
        25,1,0,0,0,638,640,3,312,156,0,639,638,1,0,0,0,640,643,1,0,0,0,641,
        639,1,0,0,0,641,642,1,0,0,0,642,644,1,0,0,0,643,641,1,0,0,0,644,
        645,3,28,14,0,645,646,3,30,15,0,646,27,1,0,0,0,647,649,5,10,0,0,
        648,650,3,4,2,0,649,648,1,0,0,0,649,650,1,0,0,0,650,29,1,0,0,0,651,
        663,5,108,0,0,652,658,5,102,0,0,653,657,3,36,18,0,654,657,3,42,21,
        0,655,657,3,46,23,0,656,653,1,0,0,0,656,654,1,0,0,0,656,655,1,0,
        0,0,657,660,1,0,0,0,658,656,1,0,0,0,658,659,1,0,0,0,659,661,1,0,
        0,0,660,658,1,0,0,0,661,663,5,103,0,0,662,651,1,0,0,0,662,652,1,
        0,0,0,663,31,1,0,0,0,664,668,3,36,18,0,665,668,3,42,21,0,666,668,
        3,46,23,0,667,664,1,0,0,0,667,665,1,0,0,0,667,666,1,0,0,0,668,33,
        1,0,0,0,669,671,3,512,256,0,670,669,1,0,0,0,670,671,1,0,0,0,671,
        35,1,0,0,0,672,675,3,38,19,0,673,675,3,40,20,0,674,672,1,0,0,0,674,
        673,1,0,0,0,675,37,1,0,0,0,676,677,3,34,17,0,677,678,3,66,33,0,678,
        39,1,0,0,0,679,680,3,34,17,0,680,681,3,70,35,0,681,41,1,0,0,0,682,
        683,3,34,17,0,683,688,5,11,0,0,684,685,5,100,0,0,685,686,3,504,252,
        0,686,687,5,101,0,0,687,689,1,0,0,0,688,684,1,0,0,0,688,689,1,0,
        0,0,689,691,1,0,0,0,690,692,3,504,252,0,691,690,1,0,0,0,691,692,
        1,0,0,0,692,693,1,0,0,0,693,694,5,12,0,0,694,695,3,508,254,0,695,
        696,3,6,3,0,696,43,1,0,0,0,697,699,3,512,256,0,698,697,1,0,0,0,698,
        699,1,0,0,0,699,700,1,0,0,0,700,702,5,13,0,0,701,703,5,14,0,0,702,
        701,1,0,0,0,702,703,1,0,0,0,703,45,1,0,0,0,704,707,3,48,24,0,705,
        707,3,52,26,0,706,704,1,0,0,0,706,705,1,0,0,0,707,708,1,0,0,0,708,
        709,3,6,3,0,709,47,1,0,0,0,710,711,3,44,22,0,711,712,3,50,25,0,712,
        49,1,0,0,0,713,716,3,508,254,0,714,715,5,110,0,0,715,717,5,111,0,
        0,716,714,1,0,0,0,716,717,1,0,0,0,717,51,1,0,0,0,718,721,3,44,22,
        0,719,722,3,54,27,0,720,722,3,56,28,0,721,719,1,0,0,0,721,720,1,
        0,0,0,722,53,1,0,0,0,723,724,3,508,254,0,724,725,5,110,0,0,725,728,
        5,112,0,0,726,727,5,110,0,0,727,729,5,111,0,0,728,726,1,0,0,0,728,
        729,1,0,0,0,729,55,1,0,0,0,730,732,3,58,29,0,731,733,3,64,32,0,732,
        731,1,0,0,0,733,734,1,0,0,0,734,732,1,0,0,0,734,735,1,0,0,0,735,
        57,1,0,0,0,736,739,3,60,30,0,737,739,3,62,31,0,738,736,1,0,0,0,738,
        737,1,0,0,0,739,59,1,0,0,0,740,741,3,50,25,0,741,61,1,0,0,0,742,
        743,3,54,27,0,743,63,1,0,0,0,744,745,3,510,255,0,745,746,3,332,166,
        0,746,747,5,104,0,0,747,65,1,0,0,0,748,751,3,18,9,0,749,751,3,68,
        34,0,750,748,1,0,0,0,750,749,1,0,0,0,751,67,1,0,0,0,752,779,3,12,
        6,0,753,779,3,26,13,0,754,779,3,72,36,0,755,779,3,74,37,0,756,779,
        3,210,105,0,757,779,3,84,42,0,758,779,3,128,64,0,759,779,3,226,113,
        0,760,779,3,228,114,0,761,779,3,308,154,0,762,779,3,224,112,0,763,
        779,3,230,115,0,764,779,3,232,116,0,765,779,3,280,140,0,766,779,
        3,254,127,0,767,779,3,260,130,0,768,779,3,274,137,0,769,779,3,110,
        55,0,770,779,3,114,57,0,771,779,3,186,93,0,772,779,3,136,68,0,773,
        779,3,118,59,0,774,779,3,178,89,0,775,779,3,192,96,0,776,779,3,198,
        99,0,777,779,3,182,91,0,778,752,1,0,0,0,778,753,1,0,0,0,778,754,
        1,0,0,0,778,755,1,0,0,0,778,756,1,0,0,0,778,757,1,0,0,0,778,758,
        1,0,0,0,778,759,1,0,0,0,778,760,1,0,0,0,778,761,1,0,0,0,778,762,
        1,0,0,0,778,763,1,0,0,0,778,764,1,0,0,0,778,765,1,0,0,0,778,766,
        1,0,0,0,778,767,1,0,0,0,778,768,1,0,0,0,778,769,1,0,0,0,778,770,
        1,0,0,0,778,771,1,0,0,0,778,772,1,0,0,0,778,773,1,0,0,0,778,774,
        1,0,0,0,778,775,1,0,0,0,778,776,1,0,0,0,778,777,1,0,0,0,779,69,1,
        0,0,0,780,791,3,144,72,0,781,791,3,256,128,0,782,791,3,270,135,0,
        783,791,3,276,138,0,784,791,3,278,139,0,785,791,3,234,117,0,786,
        791,3,246,123,0,787,791,3,250,125,0,788,791,3,282,141,0,789,791,
        3,284,142,0,790,780,1,0,0,0,790,781,1,0,0,0,790,782,1,0,0,0,790,
        783,1,0,0,0,790,784,1,0,0,0,790,785,1,0,0,0,790,786,1,0,0,0,790,
        787,1,0,0,0,790,788,1,0,0,0,790,789,1,0,0,0,791,71,1,0,0,0,792,794,
        3,312,156,0,793,792,1,0,0,0,794,797,1,0,0,0,795,793,1,0,0,0,795,
        796,1,0,0,0,796,798,1,0,0,0,797,795,1,0,0,0,798,799,3,76,38,0,799,
        800,3,78,39,0,800,73,1,0,0,0,801,803,5,15,0,0,802,801,1,0,0,0,802,
        803,1,0,0,0,803,804,1,0,0,0,804,808,5,16,0,0,805,807,3,312,156,0,
        806,805,1,0,0,0,807,810,1,0,0,0,808,806,1,0,0,0,808,809,1,0,0,0,
        809,811,1,0,0,0,810,808,1,0,0,0,811,812,3,76,38,0,812,813,3,78,39,
        0,813,75,1,0,0,0,814,816,5,17,0,0,815,817,3,4,2,0,816,815,1,0,0,
        0,816,817,1,0,0,0,817,77,1,0,0,0,818,831,5,108,0,0,819,826,5,102,
        0,0,820,825,3,36,18,0,821,825,3,80,40,0,822,825,3,42,21,0,823,825,
        3,46,23,0,824,820,1,0,0,0,824,821,1,0,0,0,824,822,1,0,0,0,824,823,
        1,0,0,0,825,828,1,0,0,0,826,824,1,0,0,0,826,827,1,0,0,0,827,829,
        1,0,0,0,828,826,1,0,0,0,829,831,5,103,0,0,830,818,1,0,0,0,830,819,
        1,0,0,0,831,79,1,0,0,0,832,833,3,34,17,0,833,834,5,18,0,0,834,835,
        3,332,166,0,835,836,5,108,0,0,836,81,1,0,0,0,837,839,5,19,0,0,838,
        837,1,0,0,0,838,839,1,0,0,0,839,843,1,0,0,0,840,842,3,312,156,0,
        841,840,1,0,0,0,842,845,1,0,0,0,843,841,1,0,0,0,843,844,1,0,0,0,
        844,83,1,0,0,0,845,843,1,0,0,0,846,847,3,82,41,0,847,848,5,20,0,
        0,848,849,3,86,43,0,849,850,3,102,51,0,850,85,1,0,0,0,851,853,5,
        14,0,0,852,851,1,0,0,0,852,853,1,0,0,0,853,855,1,0,0,0,854,856,3,
        4,2,0,855,854,1,0,0,0,855,856,1,0,0,0,856,858,1,0,0,0,857,859,3,
        216,108,0,858,857,1,0,0,0,858,859,1,0,0,0,859,862,1,0,0,0,860,863,
        3,88,44,0,861,863,3,90,45,0,862,860,1,0,0,0,862,861,1,0,0,0,863,
        867,1,0,0,0,864,866,3,92,46,0,865,864,1,0,0,0,866,869,1,0,0,0,867,
        865,1,0,0,0,867,868,1,0,0,0,868,87,1,0,0,0,869,867,1,0,0,0,870,871,
        7,0,0,0,871,876,3,112,56,0,872,873,5,109,0,0,873,875,3,112,56,0,
        874,872,1,0,0,0,875,878,1,0,0,0,876,874,1,0,0,0,876,877,1,0,0,0,
        877,89,1,0,0,0,878,876,1,0,0,0,879,880,7,1,0,0,880,881,3,116,58,
        0,881,91,1,0,0,0,882,887,3,94,47,0,883,887,3,96,48,0,884,887,3,98,
        49,0,885,887,3,100,50,0,886,882,1,0,0,0,886,883,1,0,0,0,886,884,
        1,0,0,0,886,885,1,0,0,0,887,93,1,0,0,0,888,889,5,23,0,0,889,890,
        5,2,0,0,890,895,3,120,60,0,891,892,5,109,0,0,892,894,3,120,60,0,
        893,891,1,0,0,0,894,897,1,0,0,0,895,893,1,0,0,0,895,896,1,0,0,0,
        896,95,1,0,0,0,897,895,1,0,0,0,898,899,5,24,0,0,899,904,3,122,61,
        0,900,901,5,109,0,0,901,903,3,122,61,0,902,900,1,0,0,0,903,906,1,
        0,0,0,904,902,1,0,0,0,904,905,1,0,0,0,905,97,1,0,0,0,906,904,1,0,
        0,0,907,908,5,25,0,0,908,913,3,124,62,0,909,910,5,109,0,0,910,912,
        3,124,62,0,911,909,1,0,0,0,912,915,1,0,0,0,913,911,1,0,0,0,913,914,
        1,0,0,0,914,99,1,0,0,0,915,913,1,0,0,0,916,917,5,26,0,0,917,922,
        3,126,63,0,918,919,5,109,0,0,919,921,3,126,63,0,920,918,1,0,0,0,
        921,924,1,0,0,0,922,920,1,0,0,0,922,923,1,0,0,0,923,101,1,0,0,0,
        924,922,1,0,0,0,925,938,5,108,0,0,926,933,5,102,0,0,927,932,3,38,
        19,0,928,932,3,104,52,0,929,932,3,42,21,0,930,932,3,46,23,0,931,
        927,1,0,0,0,931,928,1,0,0,0,931,929,1,0,0,0,931,930,1,0,0,0,932,
        935,1,0,0,0,933,931,1,0,0,0,933,934,1,0,0,0,934,936,1,0,0,0,935,
        933,1,0,0,0,936,938,5,103,0,0,937,925,1,0,0,0,937,926,1,0,0,0,938,
        103,1,0,0,0,939,942,3,106,53,0,940,942,3,108,54,0,941,939,1,0,0,
        0,941,940,1,0,0,0,942,105,1,0,0,0,943,944,3,34,17,0,944,945,5,27,
        0,0,945,946,3,70,35,0,946,107,1,0,0,0,947,948,3,34,17,0,948,949,
        3,70,35,0,949,109,1,0,0,0,950,952,5,28,0,0,951,953,3,4,2,0,952,951,
        1,0,0,0,952,953,1,0,0,0,953,955,1,0,0,0,954,950,1,0,0,0,954,955,
        1,0,0,0,955,956,1,0,0,0,956,959,5,29,0,0,957,960,3,508,254,0,958,
        960,3,462,231,0,959,957,1,0,0,0,959,958,1,0,0,0,960,961,1,0,0,0,
        961,964,7,0,0,0,962,965,3,508,254,0,963,965,3,462,231,0,964,962,
        1,0,0,0,964,963,1,0,0,0,965,966,1,0,0,0,966,967,3,6,3,0,967,111,
        1,0,0,0,968,971,3,508,254,0,969,971,3,462,231,0,970,968,1,0,0,0,
        970,969,1,0,0,0,971,113,1,0,0,0,972,974,5,30,0,0,973,975,3,4,2,0,
        974,973,1,0,0,0,974,975,1,0,0,0,975,977,1,0,0,0,976,972,1,0,0,0,
        976,977,1,0,0,0,977,978,1,0,0,0,978,981,5,31,0,0,979,982,3,508,254,
        0,980,982,3,462,231,0,981,979,1,0,0,0,981,980,1,0,0,0,982,983,1,
        0,0,0,983,986,7,1,0,0,984,987,3,508,254,0,985,987,3,462,231,0,986,
        984,1,0,0,0,986,985,1,0,0,0,987,988,1,0,0,0,988,989,3,6,3,0,989,
        115,1,0,0,0,990,993,3,508,254,0,991,993,3,462,231,0,992,990,1,0,
        0,0,992,991,1,0,0,0,993,117,1,0,0,0,994,996,5,32,0,0,995,997,3,4,
        2,0,996,995,1,0,0,0,996,997,1,0,0,0,997,999,1,0,0,0,998,994,1,0,
        0,0,998,999,1,0,0,0,999,1000,1,0,0,0,1000,1003,5,23,0,0,1001,1004,
        3,508,254,0,1002,1004,3,462,231,0,1003,1001,1,0,0,0,1003,1002,1,
        0,0,0,1004,1005,1,0,0,0,1005,1008,5,2,0,0,1006,1009,3,508,254,0,
        1007,1009,3,462,231,0,1008,1006,1,0,0,0,1008,1007,1,0,0,0,1009,1010,
        1,0,0,0,1010,1011,3,6,3,0,1011,119,1,0,0,0,1012,1015,3,508,254,0,
        1013,1015,3,462,231,0,1014,1012,1,0,0,0,1014,1013,1,0,0,0,1015,121,
        1,0,0,0,1016,1019,3,508,254,0,1017,1019,3,462,231,0,1018,1016,1,
        0,0,0,1018,1017,1,0,0,0,1019,123,1,0,0,0,1020,1023,3,508,254,0,1021,
        1023,3,462,231,0,1022,1020,1,0,0,0,1022,1021,1,0,0,0,1023,125,1,
        0,0,0,1024,1027,3,508,254,0,1025,1027,3,462,231,0,1026,1024,1,0,
        0,0,1026,1025,1,0,0,0,1027,127,1,0,0,0,1028,1029,3,82,41,0,1029,
        1030,5,33,0,0,1030,1031,3,130,65,0,1031,1032,3,102,51,0,1032,129,
        1,0,0,0,1033,1035,5,14,0,0,1034,1033,1,0,0,0,1034,1035,1,0,0,0,1035,
        1037,1,0,0,0,1036,1038,3,4,2,0,1037,1036,1,0,0,0,1037,1038,1,0,0,
        0,1038,1040,1,0,0,0,1039,1041,3,216,108,0,1040,1039,1,0,0,0,1040,
        1041,1,0,0,0,1041,1044,1,0,0,0,1042,1045,3,132,66,0,1043,1045,3,
        134,67,0,1044,1042,1,0,0,0,1044,1043,1,0,0,0,1044,1045,1,0,0,0,1045,
        1049,1,0,0,0,1046,1048,3,92,46,0,1047,1046,1,0,0,0,1048,1051,1,0,
        0,0,1049,1047,1,0,0,0,1049,1050,1,0,0,0,1050,131,1,0,0,0,1051,1049,
        1,0,0,0,1052,1053,7,0,0,0,1053,1058,3,138,69,0,1054,1055,5,109,0,
        0,1055,1057,3,138,69,0,1056,1054,1,0,0,0,1057,1060,1,0,0,0,1058,
        1056,1,0,0,0,1058,1059,1,0,0,0,1059,133,1,0,0,0,1060,1058,1,0,0,
        0,1061,1062,7,1,0,0,1062,1063,3,140,70,0,1063,135,1,0,0,0,1064,1066,
        5,28,0,0,1065,1067,3,4,2,0,1066,1065,1,0,0,0,1066,1067,1,0,0,0,1067,
        1069,1,0,0,0,1068,1064,1,0,0,0,1068,1069,1,0,0,0,1069,1070,1,0,0,
        0,1070,1071,5,34,0,0,1071,1072,3,508,254,0,1072,1073,7,0,0,0,1073,
        1074,3,508,254,0,1074,1075,3,6,3,0,1075,137,1,0,0,0,1076,1077,3,
        508,254,0,1077,139,1,0,0,0,1078,1079,3,508,254,0,1079,141,1,0,0,
        0,1080,1082,3,514,257,0,1081,1080,1,0,0,0,1081,1082,1,0,0,0,1082,
        1084,1,0,0,0,1083,1085,5,19,0,0,1084,1083,1,0,0,0,1084,1085,1,0,
        0,0,1085,1087,1,0,0,0,1086,1088,7,2,0,0,1087,1086,1,0,0,0,1087,1088,
        1,0,0,0,1088,1090,1,0,0,0,1089,1091,5,37,0,0,1090,1089,1,0,0,0,1090,
        1091,1,0,0,0,1091,1093,1,0,0,0,1092,1094,5,38,0,0,1093,1092,1,0,
        0,0,1093,1094,1,0,0,0,1094,1096,1,0,0,0,1095,1097,5,39,0,0,1096,
        1095,1,0,0,0,1096,1097,1,0,0,0,1097,1101,1,0,0,0,1098,1100,3,312,
        156,0,1099,1098,1,0,0,0,1100,1103,1,0,0,0,1101,1099,1,0,0,0,1101,
        1102,1,0,0,0,1102,143,1,0,0,0,1103,1101,1,0,0,0,1104,1111,3,142,
        71,0,1105,1107,5,40,0,0,1106,1105,1,0,0,0,1106,1107,1,0,0,0,1107,
        1108,1,0,0,0,1108,1112,3,146,73,0,1109,1112,3,312,156,0,1110,1112,
        5,40,0,0,1111,1106,1,0,0,0,1111,1109,1,0,0,0,1111,1110,1,0,0,0,1112,
        1114,1,0,0,0,1113,1115,3,206,103,0,1114,1113,1,0,0,0,1114,1115,1,
        0,0,0,1115,1116,1,0,0,0,1116,1117,3,102,51,0,1117,145,1,0,0,0,1118,
        1120,5,14,0,0,1119,1118,1,0,0,0,1119,1120,1,0,0,0,1120,1128,1,0,
        0,0,1121,1124,3,4,2,0,1122,1125,3,156,78,0,1123,1125,3,202,101,0,
        1124,1122,1,0,0,0,1124,1123,1,0,0,0,1124,1125,1,0,0,0,1125,1129,
        1,0,0,0,1126,1129,3,156,78,0,1127,1129,3,202,101,0,1128,1121,1,0,
        0,0,1128,1126,1,0,0,0,1128,1127,1,0,0,0,1129,1133,1,0,0,0,1130,1132,
        3,148,74,0,1131,1130,1,0,0,0,1132,1135,1,0,0,0,1133,1131,1,0,0,0,
        1133,1134,1,0,0,0,1134,147,1,0,0,0,1135,1133,1,0,0,0,1136,1141,3,
        92,46,0,1137,1141,3,150,75,0,1138,1141,3,152,76,0,1139,1141,3,154,
        77,0,1140,1136,1,0,0,0,1140,1137,1,0,0,0,1140,1138,1,0,0,0,1140,
        1139,1,0,0,0,1141,149,1,0,0,0,1142,1145,5,41,0,0,1143,1146,3,466,
        233,0,1144,1146,3,464,232,0,1145,1143,1,0,0,0,1145,1144,1,0,0,0,
        1146,151,1,0,0,0,1147,1148,5,42,0,0,1148,1149,5,43,0,0,1149,1150,
        3,180,90,0,1150,153,1,0,0,0,1151,1152,5,44,0,0,1152,1153,5,45,0,
        0,1153,1158,3,184,92,0,1154,1155,5,109,0,0,1155,1157,3,184,92,0,
        1156,1154,1,0,0,0,1157,1160,1,0,0,0,1158,1156,1,0,0,0,1158,1159,
        1,0,0,0,1159,155,1,0,0,0,1160,1158,1,0,0,0,1161,1163,3,160,80,0,
        1162,1161,1,0,0,0,1163,1164,1,0,0,0,1164,1162,1,0,0,0,1164,1165,
        1,0,0,0,1165,1167,1,0,0,0,1166,1168,3,158,79,0,1167,1166,1,0,0,0,
        1167,1168,1,0,0,0,1168,1172,1,0,0,0,1169,1171,3,160,80,0,1170,1169,
        1,0,0,0,1171,1174,1,0,0,0,1172,1170,1,0,0,0,1172,1173,1,0,0,0,1173,
        1183,1,0,0,0,1174,1172,1,0,0,0,1175,1179,3,158,79,0,1176,1178,3,
        160,80,0,1177,1176,1,0,0,0,1178,1181,1,0,0,0,1179,1177,1,0,0,0,1179,
        1180,1,0,0,0,1180,1183,1,0,0,0,1181,1179,1,0,0,0,1182,1162,1,0,0,
        0,1182,1175,1,0,0,0,1183,157,1,0,0,0,1184,1199,3,216,108,0,1185,
        1187,3,216,108,0,1186,1185,1,0,0,0,1186,1187,1,0,0,0,1187,1196,1,
        0,0,0,1188,1190,5,46,0,0,1189,1191,5,47,0,0,1190,1189,1,0,0,0,1190,
        1191,1,0,0,0,1191,1197,1,0,0,0,1192,1194,5,47,0,0,1193,1195,5,46,
        0,0,1194,1193,1,0,0,0,1194,1195,1,0,0,0,1195,1197,1,0,0,0,1196,1188,
        1,0,0,0,1196,1192,1,0,0,0,1197,1199,1,0,0,0,1198,1184,1,0,0,0,1198,
        1186,1,0,0,0,1199,159,1,0,0,0,1200,1205,3,162,81,0,1201,1205,3,166,
        83,0,1202,1205,3,170,85,0,1203,1205,3,174,87,0,1204,1200,1,0,0,0,
        1204,1201,1,0,0,0,1204,1202,1,0,0,0,1204,1203,1,0,0,0,1205,161,1,
        0,0,0,1206,1211,3,164,82,0,1207,1208,5,109,0,0,1208,1210,3,188,94,
        0,1209,1207,1,0,0,0,1210,1213,1,0,0,0,1211,1209,1,0,0,0,1211,1212,
        1,0,0,0,1212,163,1,0,0,0,1213,1211,1,0,0,0,1214,1218,5,115,0,0,1215,
        1216,5,48,0,0,1216,1218,5,45,0,0,1217,1214,1,0,0,0,1217,1215,1,0,
        0,0,1218,1219,1,0,0,0,1219,1220,3,188,94,0,1220,165,1,0,0,0,1221,
        1226,3,168,84,0,1222,1223,5,109,0,0,1223,1225,3,194,97,0,1224,1222,
        1,0,0,0,1225,1228,1,0,0,0,1226,1224,1,0,0,0,1226,1227,1,0,0,0,1227,
        167,1,0,0,0,1228,1226,1,0,0,0,1229,1230,7,3,0,0,1230,1231,3,194,
        97,0,1231,169,1,0,0,0,1232,1233,3,172,86,0,1233,1234,3,196,98,0,
        1234,171,1,0,0,0,1235,1238,5,116,0,0,1236,1238,5,50,0,0,1237,1235,
        1,0,0,0,1237,1236,1,0,0,0,1238,173,1,0,0,0,1239,1244,3,176,88,0,
        1240,1241,5,109,0,0,1241,1243,3,200,100,0,1242,1240,1,0,0,0,1243,
        1246,1,0,0,0,1244,1242,1,0,0,0,1244,1245,1,0,0,0,1245,175,1,0,0,
        0,1246,1244,1,0,0,0,1247,1248,7,4,0,0,1248,1249,3,200,100,0,1249,
        177,1,0,0,0,1250,1252,5,52,0,0,1251,1253,3,4,2,0,1252,1251,1,0,0,
        0,1252,1253,1,0,0,0,1253,1255,1,0,0,0,1254,1250,1,0,0,0,1254,1255,
        1,0,0,0,1255,1256,1,0,0,0,1256,1259,5,42,0,0,1257,1260,3,508,254,
        0,1258,1260,3,462,231,0,1259,1257,1,0,0,0,1259,1258,1,0,0,0,1260,
        1261,1,0,0,0,1261,1264,5,43,0,0,1262,1265,3,508,254,0,1263,1265,
        3,462,231,0,1264,1262,1,0,0,0,1264,1263,1,0,0,0,1265,1266,1,0,0,
        0,1266,1267,3,6,3,0,1267,179,1,0,0,0,1268,1271,3,508,254,0,1269,
        1271,3,462,231,0,1270,1268,1,0,0,0,1270,1269,1,0,0,0,1271,181,1,
        0,0,0,1272,1277,5,53,0,0,1273,1275,3,4,2,0,1274,1273,1,0,0,0,1274,
        1275,1,0,0,0,1275,1276,1,0,0,0,1276,1278,5,43,0,0,1277,1274,1,0,
        0,0,1277,1278,1,0,0,0,1278,1279,1,0,0,0,1279,1280,3,508,254,0,1280,
        1281,5,45,0,0,1281,1282,3,508,254,0,1282,1283,3,6,3,0,1283,183,1,
        0,0,0,1284,1285,3,508,254,0,1285,185,1,0,0,0,1286,1288,5,28,0,0,
        1287,1289,3,4,2,0,1288,1287,1,0,0,0,1288,1289,1,0,0,0,1289,1291,
        1,0,0,0,1290,1286,1,0,0,0,1290,1291,1,0,0,0,1291,1292,1,0,0,0,1292,
        1293,5,54,0,0,1293,1297,3,508,254,0,1294,1298,5,115,0,0,1295,1296,
        5,48,0,0,1296,1298,5,45,0,0,1297,1294,1,0,0,0,1297,1295,1,0,0,0,
        1298,1299,1,0,0,0,1299,1300,3,190,95,0,1300,1301,3,6,3,0,1301,187,
        1,0,0,0,1302,1303,3,190,95,0,1303,189,1,0,0,0,1304,1307,3,508,254,
        0,1305,1307,3,462,231,0,1306,1304,1,0,0,0,1306,1305,1,0,0,0,1307,
        191,1,0,0,0,1308,1310,5,28,0,0,1309,1311,3,4,2,0,1310,1309,1,0,0,
        0,1310,1311,1,0,0,0,1311,1313,1,0,0,0,1312,1308,1,0,0,0,1312,1313,
        1,0,0,0,1313,1314,1,0,0,0,1314,1317,5,55,0,0,1315,1318,3,508,254,
        0,1316,1318,3,462,231,0,1317,1315,1,0,0,0,1317,1316,1,0,0,0,1318,
        1319,1,0,0,0,1319,1322,7,3,0,0,1320,1323,3,508,254,0,1321,1323,3,
        462,231,0,1322,1320,1,0,0,0,1322,1321,1,0,0,0,1323,1324,1,0,0,0,
        1324,1325,3,6,3,0,1325,193,1,0,0,0,1326,1329,3,508,254,0,1327,1329,
        3,462,231,0,1328,1326,1,0,0,0,1328,1327,1,0,0,0,1329,195,1,0,0,0,
        1330,1333,3,508,254,0,1331,1333,3,462,231,0,1332,1330,1,0,0,0,1332,
        1331,1,0,0,0,1333,197,1,0,0,0,1334,1336,5,28,0,0,1335,1337,3,4,2,
        0,1336,1335,1,0,0,0,1336,1337,1,0,0,0,1337,1339,1,0,0,0,1338,1334,
        1,0,0,0,1338,1339,1,0,0,0,1339,1340,1,0,0,0,1340,1343,5,56,0,0,1341,
        1344,3,508,254,0,1342,1344,3,462,231,0,1343,1341,1,0,0,0,1343,1342,
        1,0,0,0,1344,1345,1,0,0,0,1345,1348,7,4,0,0,1346,1349,3,508,254,
        0,1347,1349,3,462,231,0,1348,1346,1,0,0,0,1348,1347,1,0,0,0,1349,
        1350,1,0,0,0,1350,1351,3,6,3,0,1351,199,1,0,0,0,1352,1355,3,508,
        254,0,1353,1355,3,462,231,0,1354,1352,1,0,0,0,1354,1353,1,0,0,0,
        1355,201,1,0,0,0,1356,1357,7,1,0,0,1357,1358,3,204,102,0,1358,203,
        1,0,0,0,1359,1360,3,508,254,0,1360,205,1,0,0,0,1361,1362,3,208,104,
        0,1362,207,1,0,0,0,1363,1370,5,118,0,0,1364,1370,5,119,0,0,1365,
        1367,5,57,0,0,1366,1368,7,5,0,0,1367,1366,1,0,0,0,1367,1368,1,0,
        0,0,1368,1370,1,0,0,0,1369,1363,1,0,0,0,1369,1364,1,0,0,0,1369,1365,
        1,0,0,0,1370,1371,1,0,0,0,1371,1372,3,332,166,0,1372,209,1,0,0,0,
        1373,1376,3,212,106,0,1374,1376,3,214,107,0,1375,1373,1,0,0,0,1375,
        1374,1,0,0,0,1376,211,1,0,0,0,1377,1379,5,58,0,0,1378,1380,3,4,2,
        0,1379,1378,1,0,0,0,1379,1380,1,0,0,0,1380,1381,1,0,0,0,1381,1382,
        3,168,84,0,1382,1383,3,102,51,0,1383,213,1,0,0,0,1384,1386,5,58,
        0,0,1385,1387,3,4,2,0,1386,1385,1,0,0,0,1386,1387,1,0,0,0,1387,1388,
        1,0,0,0,1388,1389,3,220,110,0,1389,1390,3,102,51,0,1390,215,1,0,
        0,0,1391,1392,3,218,109,0,1392,217,1,0,0,0,1393,1394,3,220,110,0,
        1394,219,1,0,0,0,1395,1396,5,105,0,0,1396,1399,3,222,111,0,1397,
        1398,5,120,0,0,1398,1400,3,222,111,0,1399,1397,1,0,0,0,1399,1400,
        1,0,0,0,1400,1401,1,0,0,0,1401,1402,5,104,0,0,1402,221,1,0,0,0,1403,
        1406,3,488,244,0,1404,1406,3,454,227,0,1405,1403,1,0,0,0,1405,1404,
        1,0,0,0,1406,223,1,0,0,0,1407,1408,3,82,41,0,1408,1409,5,59,0,0,
        1409,1410,3,130,65,0,1410,1411,3,102,51,0,1411,225,1,0,0,0,1412,
        1413,3,82,41,0,1413,1414,5,60,0,0,1414,1415,3,130,65,0,1415,1416,
        3,102,51,0,1416,227,1,0,0,0,1417,1418,3,82,41,0,1418,1419,5,61,0,
        0,1419,1420,3,130,65,0,1420,1421,3,102,51,0,1421,229,1,0,0,0,1422,
        1423,3,82,41,0,1423,1424,5,62,0,0,1424,1425,3,130,65,0,1425,1426,
        3,102,51,0,1426,231,1,0,0,0,1427,1428,3,82,41,0,1428,1429,5,62,0,
        0,1429,1430,5,61,0,0,1430,1431,3,130,65,0,1431,1432,3,102,51,0,1432,
        233,1,0,0,0,1433,1434,3,142,71,0,1434,1442,5,63,0,0,1435,1437,3,
        146,73,0,1436,1435,1,0,0,0,1436,1437,1,0,0,0,1437,1439,1,0,0,0,1438,
        1440,3,206,103,0,1439,1438,1,0,0,0,1439,1440,1,0,0,0,1440,1443,1,
        0,0,0,1441,1443,3,236,118,0,1442,1436,1,0,0,0,1442,1441,1,0,0,0,
        1443,1444,1,0,0,0,1444,1445,3,102,51,0,1445,235,1,0,0,0,1446,1449,
        3,238,119,0,1447,1449,3,240,120,0,1448,1446,1,0,0,0,1448,1447,1,
        0,0,0,1449,237,1,0,0,0,1450,1452,3,146,73,0,1451,1450,1,0,0,0,1451,
        1452,1,0,0,0,1452,1453,1,0,0,0,1453,1459,5,2,0,0,1454,1456,5,14,
        0,0,1455,1457,5,2,0,0,1456,1455,1,0,0,0,1456,1457,1,0,0,0,1457,1459,
        1,0,0,0,1458,1451,1,0,0,0,1458,1454,1,0,0,0,1458,1459,1,0,0,0,1459,
        1460,1,0,0,0,1460,1461,3,242,121,0,1461,1462,5,3,0,0,1462,1463,3,
        242,121,0,1463,239,1,0,0,0,1464,1466,3,146,73,0,1465,1464,1,0,0,
        0,1465,1466,1,0,0,0,1466,1467,1,0,0,0,1467,1468,5,106,0,0,1468,1469,
        3,242,121,0,1469,1470,5,109,0,0,1470,1475,3,242,121,0,1471,1472,
        5,109,0,0,1472,1474,3,242,121,0,1473,1471,1,0,0,0,1474,1477,1,0,
        0,0,1475,1473,1,0,0,0,1475,1476,1,0,0,0,1476,1478,1,0,0,0,1477,1475,
        1,0,0,0,1478,1479,5,107,0,0,1479,241,1,0,0,0,1480,1481,3,244,122,
        0,1481,243,1,0,0,0,1482,1483,3,504,252,0,1483,1484,3,172,86,0,1484,
        1486,1,0,0,0,1485,1482,1,0,0,0,1485,1486,1,0,0,0,1486,1487,1,0,0,
        0,1487,1489,3,196,98,0,1488,1490,3,216,108,0,1489,1488,1,0,0,0,1489,
        1490,1,0,0,0,1490,245,1,0,0,0,1491,1492,3,142,71,0,1492,1493,5,64,
        0,0,1493,1494,3,248,124,0,1494,1495,3,102,51,0,1495,247,1,0,0,0,
        1496,1502,3,146,73,0,1497,1498,5,43,0,0,1498,1499,3,242,121,0,1499,
        1500,5,118,0,0,1500,1501,3,242,121,0,1501,1503,1,0,0,0,1502,1497,
        1,0,0,0,1502,1503,1,0,0,0,1503,1517,1,0,0,0,1504,1506,5,14,0,0,1505,
        1504,1,0,0,0,1505,1506,1,0,0,0,1506,1514,1,0,0,0,1507,1509,5,43,
        0,0,1508,1507,1,0,0,0,1508,1509,1,0,0,0,1509,1510,1,0,0,0,1510,1511,
        3,242,121,0,1511,1512,5,118,0,0,1512,1513,3,242,121,0,1513,1515,
        1,0,0,0,1514,1508,1,0,0,0,1514,1515,1,0,0,0,1515,1517,1,0,0,0,1516,
        1496,1,0,0,0,1516,1505,1,0,0,0,1517,249,1,0,0,0,1518,1519,3,142,
        71,0,1519,1520,5,65,0,0,1520,1521,3,252,126,0,1521,1522,3,102,51,
        0,1522,251,1,0,0,0,1523,1529,3,146,73,0,1524,1525,5,66,0,0,1525,
        1526,3,242,121,0,1526,1527,5,67,0,0,1527,1528,3,242,121,0,1528,1530,
        1,0,0,0,1529,1524,1,0,0,0,1529,1530,1,0,0,0,1530,1544,1,0,0,0,1531,
        1533,5,14,0,0,1532,1531,1,0,0,0,1532,1533,1,0,0,0,1533,1541,1,0,
        0,0,1534,1536,5,66,0,0,1535,1534,1,0,0,0,1535,1536,1,0,0,0,1536,
        1537,1,0,0,0,1537,1538,3,242,121,0,1538,1539,5,67,0,0,1539,1540,
        3,242,121,0,1540,1542,1,0,0,0,1541,1535,1,0,0,0,1541,1542,1,0,0,
        0,1542,1544,1,0,0,0,1543,1523,1,0,0,0,1543,1532,1,0,0,0,1544,253,
        1,0,0,0,1545,1546,3,82,41,0,1546,1547,5,68,0,0,1547,1548,3,130,65,
        0,1548,1549,3,102,51,0,1549,255,1,0,0,0,1550,1551,3,142,71,0,1551,
        1552,5,69,0,0,1552,1553,3,258,129,0,1553,1554,3,102,51,0,1554,257,
        1,0,0,0,1555,1557,3,146,73,0,1556,1555,1,0,0,0,1556,1557,1,0,0,0,
        1557,1559,1,0,0,0,1558,1560,3,206,103,0,1559,1558,1,0,0,0,1559,1560,
        1,0,0,0,1560,259,1,0,0,0,1561,1562,3,82,41,0,1562,1563,5,70,0,0,
        1563,1564,3,130,65,0,1564,1565,3,262,131,0,1565,261,1,0,0,0,1566,
        1572,5,108,0,0,1567,1568,5,102,0,0,1568,1569,3,264,132,0,1569,1570,
        5,103,0,0,1570,1572,1,0,0,0,1571,1566,1,0,0,0,1571,1567,1,0,0,0,
        1572,263,1,0,0,0,1573,1579,3,38,19,0,1574,1579,3,104,52,0,1575,1579,
        3,42,21,0,1576,1579,3,46,23,0,1577,1579,3,266,133,0,1578,1573,1,
        0,0,0,1578,1574,1,0,0,0,1578,1575,1,0,0,0,1578,1576,1,0,0,0,1578,
        1577,1,0,0,0,1579,1582,1,0,0,0,1580,1578,1,0,0,0,1580,1581,1,0,0,
        0,1581,1584,1,0,0,0,1582,1580,1,0,0,0,1583,1585,3,268,134,0,1584,
        1583,1,0,0,0,1584,1585,1,0,0,0,1585,265,1,0,0,0,1586,1587,3,34,17,
        0,1587,1588,5,71,0,0,1588,1589,3,70,35,0,1589,267,1,0,0,0,1590,1591,
        3,34,17,0,1591,1592,3,332,166,0,1592,269,1,0,0,0,1593,1594,3,142,
        71,0,1594,1595,5,72,0,0,1595,1596,3,272,136,0,1596,1597,3,262,131,
        0,1597,271,1,0,0,0,1598,1600,3,146,73,0,1599,1598,1,0,0,0,1599,1600,
        1,0,0,0,1600,1602,1,0,0,0,1601,1603,3,206,103,0,1602,1601,1,0,0,
        0,1602,1603,1,0,0,0,1603,273,1,0,0,0,1604,1605,3,82,41,0,1605,1606,
        5,73,0,0,1606,1607,3,130,65,0,1607,1608,3,262,131,0,1608,275,1,0,
        0,0,1609,1610,3,142,71,0,1610,1611,5,74,0,0,1611,1612,3,272,136,
        0,1612,1613,3,262,131,0,1613,277,1,0,0,0,1614,1615,3,142,71,0,1615,
        1617,5,75,0,0,1616,1618,7,6,0,0,1617,1616,1,0,0,0,1617,1618,1,0,
        0,0,1618,1619,1,0,0,0,1619,1620,3,272,136,0,1620,1621,3,262,131,
        0,1621,279,1,0,0,0,1622,1623,3,82,41,0,1623,1624,5,78,0,0,1624,1625,
        3,130,65,0,1625,1626,3,102,51,0,1626,281,1,0,0,0,1627,1628,3,142,
        71,0,1628,1629,5,79,0,0,1629,1630,3,286,143,0,1630,1631,3,102,51,
        0,1631,283,1,0,0,0,1632,1633,3,142,71,0,1633,1634,5,65,0,0,1634,
        1635,5,79,0,0,1635,1636,3,286,143,0,1636,1637,3,102,51,0,1637,285,
        1,0,0,0,1638,1640,3,146,73,0,1639,1638,1,0,0,0,1639,1640,1,0,0,0,
        1640,1642,1,0,0,0,1641,1643,3,206,103,0,1642,1641,1,0,0,0,1642,1643,
        1,0,0,0,1643,1646,1,0,0,0,1644,1645,5,43,0,0,1645,1647,3,288,144,
        0,1646,1644,1,0,0,0,1646,1647,1,0,0,0,1647,1653,1,0,0,0,1648,1649,
        5,2,0,0,1649,1650,3,294,147,0,1650,1651,5,3,0,0,1651,1652,3,294,
        147,0,1652,1654,1,0,0,0,1653,1648,1,0,0,0,1653,1654,1,0,0,0,1654,
        1663,1,0,0,0,1655,1657,5,14,0,0,1656,1655,1,0,0,0,1656,1657,1,0,
        0,0,1657,1658,1,0,0,0,1658,1659,3,294,147,0,1659,1660,5,3,0,0,1660,
        1661,3,294,147,0,1661,1663,1,0,0,0,1662,1639,1,0,0,0,1662,1656,1,
        0,0,0,1663,287,1,0,0,0,1664,1665,3,290,145,0,1665,289,1,0,0,0,1666,
        1668,3,4,2,0,1667,1666,1,0,0,0,1667,1668,1,0,0,0,1668,1669,1,0,0,
        0,1669,1671,3,292,146,0,1670,1672,3,206,103,0,1671,1670,1,0,0,0,
        1671,1672,1,0,0,0,1672,1685,1,0,0,0,1673,1675,3,4,2,0,1674,1673,
        1,0,0,0,1674,1675,1,0,0,0,1675,1676,1,0,0,0,1676,1685,3,206,103,
        0,1677,1679,3,188,94,0,1678,1680,3,216,108,0,1679,1678,1,0,0,0,1679,
        1680,1,0,0,0,1680,1685,1,0,0,0,1681,1682,3,216,108,0,1682,1683,3,
        188,94,0,1683,1685,1,0,0,0,1684,1667,1,0,0,0,1684,1674,1,0,0,0,1684,
        1677,1,0,0,0,1684,1681,1,0,0,0,1685,291,1,0,0,0,1686,1688,3,160,
        80,0,1687,1686,1,0,0,0,1688,1689,1,0,0,0,1689,1687,1,0,0,0,1689,
        1690,1,0,0,0,1690,1692,1,0,0,0,1691,1693,3,158,79,0,1692,1691,1,
        0,0,0,1692,1693,1,0,0,0,1693,1697,1,0,0,0,1694,1696,3,160,80,0,1695,
        1694,1,0,0,0,1696,1699,1,0,0,0,1697,1695,1,0,0,0,1697,1698,1,0,0,
        0,1698,1707,1,0,0,0,1699,1697,1,0,0,0,1700,1702,3,158,79,0,1701,
        1703,3,160,80,0,1702,1701,1,0,0,0,1703,1704,1,0,0,0,1704,1702,1,
        0,0,0,1704,1705,1,0,0,0,1705,1707,1,0,0,0,1706,1687,1,0,0,0,1706,
        1700,1,0,0,0,1707,293,1,0,0,0,1708,1709,3,296,148,0,1709,295,1,0,
        0,0,1710,1712,3,298,149,0,1711,1710,1,0,0,0,1711,1712,1,0,0,0,1712,
        1713,1,0,0,0,1713,1714,3,302,151,0,1714,297,1,0,0,0,1715,1716,3,
        508,254,0,1716,1717,5,121,0,0,1717,1720,1,0,0,0,1718,1720,3,300,
        150,0,1719,1715,1,0,0,0,1719,1718,1,0,0,0,1720,299,1,0,0,0,1721,
        1722,3,466,233,0,1722,1723,5,121,0,0,1723,1725,1,0,0,0,1724,1721,
        1,0,0,0,1725,1726,1,0,0,0,1726,1724,1,0,0,0,1726,1727,1,0,0,0,1727,
        1728,1,0,0,0,1728,1729,3,466,233,0,1729,1730,5,121,0,0,1730,301,
        1,0,0,0,1731,1732,3,304,152,0,1732,303,1,0,0,0,1733,1734,3,306,153,
        0,1734,305,1,0,0,0,1735,1736,3,508,254,0,1736,307,1,0,0,0,1737,1738,
        3,82,41,0,1738,1739,5,80,0,0,1739,1740,3,130,65,0,1740,1741,3,102,
        51,0,1741,309,1,0,0,0,1742,1743,5,122,0,0,1743,1744,3,314,157,0,
        1744,311,1,0,0,0,1745,1746,5,122,0,0,1746,1747,3,314,157,0,1747,
        313,1,0,0,0,1748,1749,3,320,160,0,1749,315,1,0,0,0,1750,1752,3,312,
        156,0,1751,1750,1,0,0,0,1752,1755,1,0,0,0,1753,1751,1,0,0,0,1753,
        1754,1,0,0,0,1754,1756,1,0,0,0,1755,1753,1,0,0,0,1756,1757,7,7,0,
        0,1757,1767,3,318,159,0,1758,1759,5,5,0,0,1759,1764,3,14,7,0,1760,
        1761,5,109,0,0,1761,1763,3,14,7,0,1762,1760,1,0,0,0,1763,1766,1,
        0,0,0,1764,1762,1,0,0,0,1764,1765,1,0,0,0,1765,1768,1,0,0,0,1766,
        1764,1,0,0,0,1767,1758,1,0,0,0,1767,1768,1,0,0,0,1768,1769,1,0,0,
        0,1769,1770,3,322,161,0,1770,317,1,0,0,0,1771,1775,3,4,2,0,1772,
        1776,5,115,0,0,1773,1774,5,48,0,0,1774,1776,5,45,0,0,1775,1772,1,
        0,0,0,1775,1773,1,0,0,0,1776,1778,1,0,0,0,1777,1771,1,0,0,0,1777,
        1778,1,0,0,0,1778,1779,1,0,0,0,1779,1780,3,320,160,0,1780,319,1,
        0,0,0,1781,1782,3,508,254,0,1782,321,1,0,0,0,1783,1796,5,108,0,0,
        1784,1791,5,102,0,0,1785,1790,3,38,19,0,1786,1790,3,324,162,0,1787,
        1790,3,42,21,0,1788,1790,3,46,23,0,1789,1785,1,0,0,0,1789,1786,1,
        0,0,0,1789,1787,1,0,0,0,1789,1788,1,0,0,0,1790,1793,1,0,0,0,1791,
        1789,1,0,0,0,1791,1792,1,0,0,0,1792,1794,1,0,0,0,1793,1791,1,0,0,
        0,1794,1796,5,103,0,0,1795,1783,1,0,0,0,1795,1784,1,0,0,0,1796,323,
        1,0,0,0,1797,1798,3,326,163,0,1798,325,1,0,0,0,1799,1801,5,40,0,
        0,1800,1799,1,0,0,0,1800,1801,1,0,0,0,1801,1803,1,0,0,0,1802,1804,
        7,4,0,0,1803,1802,1,0,0,0,1803,1804,1,0,0,0,1804,1805,1,0,0,0,1805,
        1807,3,200,100,0,1806,1808,3,156,78,0,1807,1806,1,0,0,0,1807,1808,
        1,0,0,0,1808,1810,1,0,0,0,1809,1811,3,206,103,0,1810,1809,1,0,0,
        0,1810,1811,1,0,0,0,1811,1812,1,0,0,0,1812,1813,3,322,161,0,1813,
        327,1,0,0,0,1814,1815,5,102,0,0,1815,1816,3,264,132,0,1816,1817,
        5,103,0,0,1817,329,1,0,0,0,1818,1819,3,332,166,0,1819,331,1,0,0,
        0,1820,1821,3,336,168,0,1821,333,1,0,0,0,1822,1823,3,330,165,0,1823,
        335,1,0,0,0,1824,1833,3,340,170,0,1825,1826,3,338,169,0,1826,1827,
        3,340,170,0,1827,1828,5,124,0,0,1828,1829,3,334,167,0,1829,1830,
        5,82,0,0,1830,1831,3,334,167,0,1831,1833,1,0,0,0,1832,1824,1,0,0,
        0,1832,1825,1,0,0,0,1833,337,1,0,0,0,1834,1835,5,83,0,0,1835,339,
        1,0,0,0,1836,1842,3,348,174,0,1837,1838,3,342,171,0,1838,1839,3,
        344,172,0,1839,1841,1,0,0,0,1840,1837,1,0,0,0,1841,1844,1,0,0,0,
        1842,1840,1,0,0,0,1842,1843,1,0,0,0,1843,341,1,0,0,0,1844,1842,1,
        0,0,0,1845,1846,5,125,0,0,1846,343,1,0,0,0,1847,1848,3,346,173,0,
        1848,345,1,0,0,0,1849,1850,3,348,174,0,1850,347,1,0,0,0,1851,1857,
        3,356,178,0,1852,1853,3,350,175,0,1853,1854,3,352,176,0,1854,1856,
        1,0,0,0,1855,1852,1,0,0,0,1856,1859,1,0,0,0,1857,1855,1,0,0,0,1857,
        1858,1,0,0,0,1858,349,1,0,0,0,1859,1857,1,0,0,0,1860,1861,5,84,0,
        0,1861,351,1,0,0,0,1862,1863,3,354,177,0,1863,353,1,0,0,0,1864,1865,
        3,356,178,0,1865,355,1,0,0,0,1866,1877,3,366,183,0,1867,1868,3,358,
        179,0,1868,1869,3,366,183,0,1869,1874,1,0,0,0,1870,1871,3,360,180,
        0,1871,1872,3,362,181,0,1872,1874,1,0,0,0,1873,1867,1,0,0,0,1873,
        1870,1,0,0,0,1874,1876,1,0,0,0,1875,1873,1,0,0,0,1876,1879,1,0,0,
        0,1877,1875,1,0,0,0,1877,1878,1,0,0,0,1878,357,1,0,0,0,1879,1877,
        1,0,0,0,1880,1881,5,126,0,0,1881,359,1,0,0,0,1882,1883,5,85,0,0,
        1883,361,1,0,0,0,1884,1885,3,364,182,0,1885,363,1,0,0,0,1886,1887,
        3,366,183,0,1887,365,1,0,0,0,1888,1894,3,370,185,0,1889,1890,3,368,
        184,0,1890,1891,3,370,185,0,1891,1893,1,0,0,0,1892,1889,1,0,0,0,
        1893,1896,1,0,0,0,1894,1892,1,0,0,0,1894,1895,1,0,0,0,1895,367,1,
        0,0,0,1896,1894,1,0,0,0,1897,1898,5,86,0,0,1898,369,1,0,0,0,1899,
        1910,3,380,190,0,1900,1901,3,372,186,0,1901,1902,3,380,190,0,1902,
        1907,1,0,0,0,1903,1904,3,374,187,0,1904,1905,3,376,188,0,1905,1907,
        1,0,0,0,1906,1900,1,0,0,0,1906,1903,1,0,0,0,1907,1909,1,0,0,0,1908,
        1906,1,0,0,0,1909,1912,1,0,0,0,1910,1908,1,0,0,0,1910,1911,1,0,0,
        0,1911,371,1,0,0,0,1912,1910,1,0,0,0,1913,1914,5,127,0,0,1914,373,
        1,0,0,0,1915,1916,5,87,0,0,1916,375,1,0,0,0,1917,1918,3,378,189,
        0,1918,377,1,0,0,0,1919,1920,3,380,190,0,1920,379,1,0,0,0,1921,1927,
        3,384,192,0,1922,1923,3,382,191,0,1923,1924,3,384,192,0,1924,1926,
        1,0,0,0,1925,1922,1,0,0,0,1926,1929,1,0,0,0,1927,1925,1,0,0,0,1927,
        1928,1,0,0,0,1928,381,1,0,0,0,1929,1927,1,0,0,0,1930,1935,5,128,
        0,0,1931,1935,5,129,0,0,1932,1935,5,130,0,0,1933,1935,5,131,0,0,
        1934,1930,1,0,0,0,1934,1931,1,0,0,0,1934,1932,1,0,0,0,1934,1933,
        1,0,0,0,1935,383,1,0,0,0,1936,1943,3,410,205,0,1937,1938,3,386,193,
        0,1938,1939,3,396,198,0,1939,1944,1,0,0,0,1940,1941,3,390,195,0,
        1941,1942,3,398,199,0,1942,1944,1,0,0,0,1943,1937,1,0,0,0,1943,1940,
        1,0,0,0,1943,1944,1,0,0,0,1944,1962,1,0,0,0,1945,1946,3,404,202,
        0,1946,1947,3,386,193,0,1947,1948,3,396,198,0,1948,1962,1,0,0,0,
        1949,1950,3,394,197,0,1950,1951,3,388,194,0,1951,1952,3,396,198,
        0,1952,1962,1,0,0,0,1953,1954,3,404,202,0,1954,1955,3,390,195,0,
        1955,1956,3,398,199,0,1956,1962,1,0,0,0,1957,1958,3,394,197,0,1958,
        1959,3,392,196,0,1959,1960,3,398,199,0,1960,1962,1,0,0,0,1961,1936,
        1,0,0,0,1961,1945,1,0,0,0,1961,1949,1,0,0,0,1961,1953,1,0,0,0,1961,
        1957,1,0,0,0,1962,385,1,0,0,0,1963,1967,5,88,0,0,1964,1967,5,89,
        0,0,1965,1967,5,123,0,0,1966,1963,1,0,0,0,1966,1964,1,0,0,0,1966,
        1965,1,0,0,0,1967,387,1,0,0,0,1968,1969,5,132,0,0,1969,389,1,0,0,
        0,1970,1971,5,90,0,0,1971,391,1,0,0,0,1972,1973,5,91,0,0,1973,393,
        1,0,0,0,1974,1975,3,508,254,0,1975,395,1,0,0,0,1976,1977,3,400,200,
        0,1977,397,1,0,0,0,1978,1979,3,400,200,0,1979,399,1,0,0,0,1980,1981,
        3,402,201,0,1981,401,1,0,0,0,1982,1983,3,508,254,0,1983,403,1,0,
        0,0,1984,1985,3,406,203,0,1985,405,1,0,0,0,1986,1987,3,408,204,0,
        1987,407,1,0,0,0,1988,1989,1,0,0,0,1989,409,1,0,0,0,1990,1996,3,
        414,207,0,1991,1992,3,412,206,0,1992,1993,3,414,207,0,1993,1995,
        1,0,0,0,1994,1991,1,0,0,0,1995,1998,1,0,0,0,1996,1994,1,0,0,0,1996,
        1997,1,0,0,0,1997,411,1,0,0,0,1998,1996,1,0,0,0,1999,2004,5,100,
        0,0,2000,2004,5,101,0,0,2001,2004,5,133,0,0,2002,2004,5,134,0,0,
        2003,1999,1,0,0,0,2003,2000,1,0,0,0,2003,2001,1,0,0,0,2003,2002,
        1,0,0,0,2004,413,1,0,0,0,2005,2008,3,416,208,0,2006,2007,5,120,0,
        0,2007,2009,3,416,208,0,2008,2006,1,0,0,0,2008,2009,1,0,0,0,2009,
        415,1,0,0,0,2010,2016,3,420,210,0,2011,2012,3,418,209,0,2012,2013,
        3,420,210,0,2013,2015,1,0,0,0,2014,2011,1,0,0,0,2015,2018,1,0,0,
        0,2016,2014,1,0,0,0,2016,2017,1,0,0,0,2017,417,1,0,0,0,2018,2016,
        1,0,0,0,2019,2022,5,135,0,0,2020,2022,5,136,0,0,2021,2019,1,0,0,
        0,2021,2020,1,0,0,0,2022,419,1,0,0,0,2023,2029,3,424,212,0,2024,
        2025,3,422,211,0,2025,2026,3,424,212,0,2026,2028,1,0,0,0,2027,2024,
        1,0,0,0,2028,2031,1,0,0,0,2029,2027,1,0,0,0,2029,2030,1,0,0,0,2030,
        421,1,0,0,0,2031,2029,1,0,0,0,2032,2036,5,112,0,0,2033,2036,5,137,
        0,0,2034,2036,5,138,0,0,2035,2032,1,0,0,0,2035,2033,1,0,0,0,2035,
        2034,1,0,0,0,2036,423,1,0,0,0,2037,2041,3,428,214,0,2038,2039,3,
        426,213,0,2039,2040,3,424,212,0,2040,2042,1,0,0,0,2041,2038,1,0,
        0,0,2041,2042,1,0,0,0,2042,425,1,0,0,0,2043,2046,5,111,0,0,2044,
        2046,5,139,0,0,2045,2043,1,0,0,0,2045,2044,1,0,0,0,2046,427,1,0,
        0,0,2047,2048,3,430,215,0,2048,2049,3,432,216,0,2049,2052,1,0,0,
        0,2050,2052,3,432,216,0,2051,2047,1,0,0,0,2051,2050,1,0,0,0,2052,
        429,1,0,0,0,2053,2058,5,135,0,0,2054,2058,5,136,0,0,2055,2058,5,
        114,0,0,2056,2058,5,92,0,0,2057,2053,1,0,0,0,2057,2054,1,0,0,0,2057,
        2055,1,0,0,0,2057,2056,1,0,0,0,2058,431,1,0,0,0,2059,2060,5,14,0,
        0,2060,2063,3,398,199,0,2061,2063,3,434,217,0,2062,2059,1,0,0,0,
        2062,2061,1,0,0,0,2063,433,1,0,0,0,2064,2067,3,444,222,0,2065,2066,
        5,121,0,0,2066,2068,3,442,221,0,2067,2065,1,0,0,0,2067,2068,1,0,
        0,0,2068,2097,1,0,0,0,2069,2070,5,122,0,0,2070,2071,5,106,0,0,2071,
        2072,3,452,226,0,2072,2073,5,107,0,0,2073,2090,1,0,0,0,2074,2075,
        5,105,0,0,2075,2076,3,452,226,0,2076,2077,5,104,0,0,2077,2090,1,
        0,0,0,2078,2079,5,140,0,0,2079,2083,3,402,201,0,2080,2084,3,446,
        223,0,2081,2084,3,436,218,0,2082,2084,3,468,234,0,2083,2080,1,0,
        0,0,2083,2081,1,0,0,0,2083,2082,1,0,0,0,2084,2090,1,0,0,0,2085,2086,
        5,121,0,0,2086,2090,3,446,223,0,2087,2088,5,141,0,0,2088,2090,3,
        446,223,0,2089,2069,1,0,0,0,2089,2074,1,0,0,0,2089,2078,1,0,0,0,
        2089,2085,1,0,0,0,2089,2087,1,0,0,0,2090,2093,1,0,0,0,2091,2092,
        5,121,0,0,2092,2094,3,442,221,0,2093,2091,1,0,0,0,2093,2094,1,0,
        0,0,2094,2096,1,0,0,0,2095,2089,1,0,0,0,2096,2099,1,0,0,0,2097,2095,
        1,0,0,0,2097,2098,1,0,0,0,2098,435,1,0,0,0,2099,2097,1,0,0,0,2100,
        2101,3,438,219,0,2101,437,1,0,0,0,2102,2103,3,440,220,0,2103,439,
        1,0,0,0,2104,2105,3,402,201,0,2105,441,1,0,0,0,2106,2109,3,508,254,
        0,2107,2109,3,462,231,0,2108,2106,1,0,0,0,2108,2107,1,0,0,0,2109,
        443,1,0,0,0,2110,2121,3,486,243,0,2111,2121,3,488,244,0,2112,2121,
        3,454,227,0,2113,2121,3,458,229,0,2114,2121,3,460,230,0,2115,2121,
        3,446,223,0,2116,2117,5,106,0,0,2117,2118,3,452,226,0,2118,2119,
        5,107,0,0,2119,2121,1,0,0,0,2120,2110,1,0,0,0,2120,2111,1,0,0,0,
        2120,2112,1,0,0,0,2120,2113,1,0,0,0,2120,2114,1,0,0,0,2120,2115,
        1,0,0,0,2120,2116,1,0,0,0,2121,445,1,0,0,0,2122,2123,3,448,224,0,
        2123,447,1,0,0,0,2124,2125,3,328,164,0,2125,449,1,0,0,0,2126,2127,
        3,504,252,0,2127,451,1,0,0,0,2128,2132,3,332,166,0,2129,2133,5,109,
        0,0,2130,2131,5,109,0,0,2131,2133,3,452,226,0,2132,2129,1,0,0,0,
        2132,2130,1,0,0,0,2132,2133,1,0,0,0,2133,453,1,0,0,0,2134,2135,3,
        456,228,0,2135,455,1,0,0,0,2136,2137,3,508,254,0,2137,457,1,0,0,
        0,2138,2139,3,508,254,0,2139,2140,5,121,0,0,2140,2141,5,81,0,0,2141,
        459,1,0,0,0,2142,2143,3,188,94,0,2143,2144,3,468,234,0,2144,461,
        1,0,0,0,2145,2146,3,464,232,0,2146,463,1,0,0,0,2147,2150,3,466,233,
        0,2148,2149,5,121,0,0,2149,2151,3,466,233,0,2150,2148,1,0,0,0,2151,
        2152,1,0,0,0,2152,2150,1,0,0,0,2152,2153,1,0,0,0,2153,465,1,0,0,
        0,2154,2155,3,508,254,0,2155,467,1,0,0,0,2156,2159,5,106,0,0,2157,
        2160,3,470,235,0,2158,2160,3,476,238,0,2159,2157,1,0,0,0,2159,2158,
        1,0,0,0,2159,2160,1,0,0,0,2160,2161,1,0,0,0,2161,2162,5,107,0,0,
        2162,469,1,0,0,0,2163,2168,3,472,236,0,2164,2165,5,109,0,0,2165,
        2167,3,472,236,0,2166,2164,1,0,0,0,2167,2170,1,0,0,0,2168,2166,1,
        0,0,0,2168,2169,1,0,0,0,2169,471,1,0,0,0,2170,2168,1,0,0,0,2171,
        2172,3,474,237,0,2172,473,1,0,0,0,2173,2174,3,484,242,0,2174,475,
        1,0,0,0,2175,2180,3,478,239,0,2176,2177,5,109,0,0,2177,2179,3,478,
        239,0,2178,2176,1,0,0,0,2179,2182,1,0,0,0,2180,2178,1,0,0,0,2180,
        2181,1,0,0,0,2181,477,1,0,0,0,2182,2180,1,0,0,0,2183,2184,3,480,
        240,0,2184,479,1,0,0,0,2185,2186,3,482,241,0,2186,2187,5,118,0,0,
        2187,2188,3,484,242,0,2188,481,1,0,0,0,2189,2190,3,508,254,0,2190,
        483,1,0,0,0,2191,2192,3,332,166,0,2192,485,1,0,0,0,2193,2197,5,93,
        0,0,2194,2195,5,106,0,0,2195,2197,5,107,0,0,2196,2193,1,0,0,0,2196,
        2194,1,0,0,0,2197,487,1,0,0,0,2198,2204,3,490,245,0,2199,2204,3,
        494,247,0,2200,2204,3,496,248,0,2201,2204,3,498,249,0,2202,2204,
        3,502,251,0,2203,2198,1,0,0,0,2203,2199,1,0,0,0,2203,2200,1,0,0,
        0,2203,2201,1,0,0,0,2203,2202,1,0,0,0,2204,489,1,0,0,0,2205,2206,
        3,492,246,0,2206,491,1,0,0,0,2207,2210,5,76,0,0,2208,2210,5,77,0,
        0,2209,2207,1,0,0,0,2209,2208,1,0,0,0,2210,493,1,0,0,0,2211,2212,
        5,146,0,0,2212,495,1,0,0,0,2213,2214,5,142,0,0,2214,497,1,0,0,0,
        2215,2216,3,500,250,0,2216,499,1,0,0,0,2217,2219,5,142,0,0,2218,
        2217,1,0,0,0,2218,2219,1,0,0,0,2219,2220,1,0,0,0,2220,2221,5,121,
        0,0,2221,2224,7,8,0,0,2222,2224,5,143,0,0,2223,2218,1,0,0,0,2223,
        2222,1,0,0,0,2224,501,1,0,0,0,2225,2226,5,112,0,0,2226,503,1,0,0,
        0,2227,2230,5,144,0,0,2228,2230,5,145,0,0,2229,2227,1,0,0,0,2229,
        2228,1,0,0,0,2230,505,1,0,0,0,2231,2232,3,504,252,0,2232,2233,5,
        110,0,0,2233,2235,1,0,0,0,2234,2231,1,0,0,0,2235,2236,1,0,0,0,2236,
        2234,1,0,0,0,2236,2237,1,0,0,0,2237,507,1,0,0,0,2238,2240,3,506,
        253,0,2239,2238,1,0,0,0,2239,2240,1,0,0,0,2240,2241,1,0,0,0,2241,
        2242,3,504,252,0,2242,509,1,0,0,0,2243,2244,5,105,0,0,2244,511,1,
        0,0,0,2245,2249,5,94,0,0,2246,2249,5,95,0,0,2247,2249,5,96,0,0,2248,
        2245,1,0,0,0,2248,2246,1,0,0,0,2248,2247,1,0,0,0,2249,513,1,0,0,
        0,2250,2254,5,97,0,0,2251,2254,5,98,0,0,2252,2254,5,99,0,0,2253,
        2250,1,0,0,0,2253,2251,1,0,0,0,2253,2252,1,0,0,0,2254,515,1,0,0,
        0,263,522,529,532,539,543,547,551,556,561,564,571,580,593,597,605,
        608,610,614,620,624,630,632,641,649,656,658,662,667,670,674,688,
        691,698,702,706,716,721,728,734,738,750,778,790,795,802,808,816,
        824,826,830,838,843,852,855,858,862,867,876,886,895,904,913,922,
        931,933,937,941,952,954,959,964,970,974,976,981,986,992,996,998,
        1003,1008,1014,1018,1022,1026,1034,1037,1040,1044,1049,1058,1066,
        1068,1081,1084,1087,1090,1093,1096,1101,1106,1111,1114,1119,1124,
        1128,1133,1140,1145,1158,1164,1167,1172,1179,1182,1186,1190,1194,
        1196,1198,1204,1211,1217,1226,1237,1244,1252,1254,1259,1264,1270,
        1274,1277,1288,1290,1297,1306,1310,1312,1317,1322,1328,1332,1336,
        1338,1343,1348,1354,1367,1369,1375,1379,1386,1399,1405,1436,1439,
        1442,1448,1451,1456,1458,1465,1475,1485,1489,1502,1505,1508,1514,
        1516,1529,1532,1535,1541,1543,1556,1559,1571,1578,1580,1584,1599,
        1602,1617,1639,1642,1646,1653,1656,1662,1667,1671,1674,1679,1684,
        1689,1692,1697,1704,1706,1711,1719,1726,1753,1764,1767,1775,1777,
        1789,1791,1795,1800,1803,1807,1810,1832,1842,1857,1873,1877,1894,
        1906,1910,1927,1934,1943,1961,1966,1996,2003,2008,2016,2021,2029,
        2035,2041,2045,2051,2057,2062,2067,2083,2089,2093,2097,2108,2120,
        2132,2152,2159,2168,2180,2196,2203,2209,2218,2223,2229,2236,2239,
        2248,2253
    ]

class KerMLv2Parser ( Parser ):

    grammarFileName = "KerMLv2.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'dependency'", "'from'", "'to'", "'comment'", 
                     "'about'", "'locale'", "'doc'", "'rep'", "'language'", 
                     "'namespace'", "'alias'", "'for'", "'import'", "'all'", 
                     "'standard'", "'library'", "'package'", "'filter'", 
                     "'abstract'", "'type'", "'specializes'", "'conjugates'", 
                     "'disjoint'", "'unions'", "'intersects'", "'differences'", 
                     "'member'", "'specialization'", "'subtype'", "'conjugation'", 
                     "'conjugate'", "'disjoining'", "'classifier'", "'subclassifier'", 
                     "'composite'", "'portion'", "'readonly'", "'derived'", 
                     "'end'", "'feature'", "'chains'", "'inverse'", "'of'", 
                     "'featured'", "'by'", "'ordered'", "'nonunique'", "'typed'", 
                     "'subsets'", "'references'", "'redefines'", "'inverting'", 
                     "'featuring'", "'typing'", "'subset'", "'redefinition'", 
                     "'default'", "'multiplicity'", "'datatype'", "'class'", 
                     "'struct'", "'assoc'", "'connector'", "'binding'", 
                     "'succession'", "'first'", "'then'", "'behavior'", 
                     "'step'", "'function'", "'return'", "'expr'", "'predicate'", 
                     "'bool'", "'inv'", "'true'", "'false'", "'interaction'", 
                     "'flow'", "'metaclass'", "'metadata'", "'else'", "'if'", 
                     "'implies'", "'or'", "'xor'", "'and'", "'hastype'", 
                     "'istype'", "'as'", "'meta'", "'not'", "'null'", "'public'", 
                     "'private'", "'protected'", "'in'", "'out'", "'inout'", 
                     "'<'", "'>'", "'{'", "'}'", "']'", "'['", "'('", "')'", 
                     "';'", "','", "'::'", "'**'", "'*'", "':>'", "'~'", 
                     "':'", "'::>'", "':>>'", "'='", "':='", "'..'", "'.'", 
                     "'#'", "'@'", "'?'", "'??'", "'|'", "'&'", "'=='", 
                     "'!='", "'==='", "'!=='", "'@@'", "'<='", "'>='", "'+'", 
                     "'-'", "'/'", "'%'", "'^'", "'->'", "'.?'" ]

    symbolicNames = [ "<INVALID>", "K_DEPENDENCY", "K_FROM", "K_TO", "K_COMMENT", 
                      "K_ABOUT", "K_LOCALE", "K_DOC", "K_REP", "K_LANGUAGE", 
                      "K_NAMESPACE", "K_ALIAS", "K_FOR", "K_IMPORT", "K_ALL", 
                      "K_STANDARD", "K_LIBRARY", "K_PACKAGE", "K_FILTER", 
                      "K_ABSTRACT", "K_TYPE", "K_SPECIALIZES", "K_CONJUGATES", 
                      "K_DISJOINT", "K_UNIONS", "K_INTERSECTS", "K_DIFFERENCES", 
                      "K_MEMBER", "K_SPECIALIZATION", "K_SUBTYPE", "K_CONJUGATION", 
                      "K_CONJUGATE", "K_DISJOINING", "K_CLASSIFIER", "K_SUBCLASSIFIER", 
                      "K_COMPOSITE", "K_PORTION", "K_READONLY", "K_DERIVED", 
                      "K_END", "K_FEATURE", "K_CHAINS", "K_INVERSE", "K_OF", 
                      "K_FEATURED", "K_BY", "K_ORDERED", "K_NONUNIQUE", 
                      "K_TYPED", "K_SUBSETS", "K_REFERENCES", "K_REDEFINES", 
                      "K_INVERTING", "K_FEATURING", "K_TYPING", "K_SUBSET", 
                      "K_REDEFINITION", "K_DEFAULT", "K_MULTIPLICITY", "K_DATATYPE", 
                      "K_CLASS", "K_STRUCT", "K_ASSOC", "K_CONNECTOR", "K_BINDING", 
                      "K_SUCCESSION", "K_FIRST", "K_THEN", "K_BEHAVIOR", 
                      "K_STEP", "K_FUNCTION", "K_RETURN", "K_EXPR", "K_PREDICATE", 
                      "K_BOOL", "K_INV", "K_TRUE", "K_FALSE", "K_INTERACTION", 
                      "K_FLOW", "K_METACLASS", "K_METADATA", "K_ELSE", "K_IF", 
                      "K_IMPLIES", "K_OR", "K_XOR", "K_AND", "K_HASTYPE", 
                      "K_ISTYPE", "K_AS", "K_META", "K_NOT", "K_NULL", "K_PUBLIC", 
                      "K_PRIVATE", "K_PROTECTED", "K_IN", "K_OUT", "K_INOUT", 
                      "LANGLE", "RANGLE", "LBRACE", "RBRACE", "RSQUARE", 
                      "LSQUARE", "LPAREN", "RPAREN", "OP_SEMI", "OP_COMMA", 
                      "OP_COLON_COLON", "OP_STAR_STAR", "OP_STAR", "OP_COLON_RANGLE", 
                      "OP_TILDE", "OP_COLON", "OP_COLON_COLON_RANGLE", "OP_COLON_RANGLE_RANGLE", 
                      "OP_EQ", "OP_COLON_EQ", "OP_DOT_DOT", "OP_DOT", "OP_HASH", 
                      "OP_AT", "OP_QMARK", "OP_QMARK_QMARK", "OP_BAR", "OP_AND", 
                      "OP_EQ_EQ", "OP_BANG_EQ", "OP_EQ_EQ_EQ", "OP_BANG_EQ_EQ", 
                      "OP_AT_AT", "OP_LANGLE_EQ", "OP_RANGLE_EQ", "OP_PLUS", 
                      "OP_MINUS", "OP_SLASH", "OP_PERCENT", "OP_HAT", "OP_MINUS_RANGLE", 
                      "OP_DOT_QMARK", "RULE_DECIMAL_VALUE", "RULE_EXP_VALUE", 
                      "RULE_ID", "RULE_UNRESTRICTED_NAME", "RULE_STRING_VALUE", 
                      "RULE_REGULAR_COMMENT", "RULE_ML_NOTE", "RULE_SL_NOTE", 
                      "RULE_WS" ]

    RULE_entryRuleRootNamespace = 0
    RULE_ruleRootNamespace = 1
    RULE_ruleIdentification = 2
    RULE_ruleRelationshipBody = 3
    RULE_ruleRelationshipOwnedElement = 4
    RULE_ruleOwnedRelatedElement = 5
    RULE_ruleDependency = 6
    RULE_ruleAnnotation = 7
    RULE_ruleOwnedAnnotation = 8
    RULE_ruleAnnotatingElement = 9
    RULE_ruleComment = 10
    RULE_ruleDocumentation = 11
    RULE_ruleTextualRepresentation = 12
    RULE_ruleNamespace = 13
    RULE_ruleNamespaceDeclaration = 14
    RULE_ruleNamespaceBody = 15
    RULE_ruleNamespaceBodyElement = 16
    RULE_ruleMemberPrefix = 17
    RULE_ruleNamespaceMember = 18
    RULE_ruleNonFeatureMember = 19
    RULE_ruleNamespaceFeatureMember = 20
    RULE_ruleAliasMember = 21
    RULE_ruleImportPrefix = 22
    RULE_ruleImport = 23
    RULE_ruleMembershipImport = 24
    RULE_ruleImportedMembership = 25
    RULE_ruleNamespaceImport = 26
    RULE_ruleImportedNamespace = 27
    RULE_ruleFilterPackage = 28
    RULE_ruleFilterPackageImport = 29
    RULE_ruleFilterPackageMembershipImport = 30
    RULE_ruleFilterPackageNamespaceImport = 31
    RULE_ruleFilterPackageMember = 32
    RULE_ruleMemberElement = 33
    RULE_ruleNonFeatureElement = 34
    RULE_ruleFeatureElement = 35
    RULE_rulePackage = 36
    RULE_ruleLibraryPackage = 37
    RULE_rulePackageDeclaration = 38
    RULE_rulePackageBody = 39
    RULE_ruleElementFilterMember = 40
    RULE_ruleTypePrefix = 41
    RULE_ruleType = 42
    RULE_ruleTypeDeclaration = 43
    RULE_ruleSpecializationPart = 44
    RULE_ruleConjugationPart = 45
    RULE_ruleTypeRelationshipPart = 46
    RULE_ruleDisjoiningPart = 47
    RULE_ruleUnioningPart = 48
    RULE_ruleIntersectingPart = 49
    RULE_ruleDifferencingPart = 50
    RULE_ruleTypeBody = 51
    RULE_ruleFeatureMember = 52
    RULE_ruleTypeFeatureMember = 53
    RULE_ruleOwnedFeatureMember = 54
    RULE_ruleSpecialization = 55
    RULE_ruleOwnedSpecialization = 56
    RULE_ruleConjugation = 57
    RULE_ruleOwnedConjugation = 58
    RULE_ruleDisjoining = 59
    RULE_ruleOwnedDisjoining = 60
    RULE_ruleUnioning = 61
    RULE_ruleIntersecting = 62
    RULE_ruleDifferencing = 63
    RULE_ruleClassifier = 64
    RULE_ruleClassifierDeclaration = 65
    RULE_ruleSuperclassingPart = 66
    RULE_ruleClassifierConjugationPart = 67
    RULE_ruleSubclassification = 68
    RULE_ruleOwnedsubclassification = 69
    RULE_ruleClassifierConjugation = 70
    RULE_ruleFeaturePrefix = 71
    RULE_ruleFeature = 72
    RULE_ruleFeatureDeclaration = 73
    RULE_ruleFeatureRelationshipPart = 74
    RULE_ruleChainingPart = 75
    RULE_ruleInvertingPart = 76
    RULE_ruleTypeFeaturingPart = 77
    RULE_ruleFeatureSpecializationPart = 78
    RULE_ruleMultiplicityPart = 79
    RULE_ruleFeatureSpecialization = 80
    RULE_ruleTypings = 81
    RULE_ruleTypedBy = 82
    RULE_ruleSubsettings = 83
    RULE_ruleSubsets = 84
    RULE_ruleReferences = 85
    RULE_ruleReferencesKeyword = 86
    RULE_ruleRedefinitions = 87
    RULE_ruleRedefines = 88
    RULE_ruleFeatureInverting = 89
    RULE_ruleOwnedFeatureInverting = 90
    RULE_ruleTypeFeaturing = 91
    RULE_ruleOwnedTypeFeaturing = 92
    RULE_ruleFeatureTyping = 93
    RULE_ruleOwnedFeatureTyping = 94
    RULE_ruleFeatureType = 95
    RULE_ruleSubsetting = 96
    RULE_ruleOwnedSubsetting = 97
    RULE_ruleOwnedReferenceSubsetting = 98
    RULE_ruleRedefinition = 99
    RULE_ruleOwnedRedefinition = 100
    RULE_ruleFeatureConjugationPart = 101
    RULE_ruleFeatureConjugation = 102
    RULE_ruleValuePart = 103
    RULE_ruleFeatureValue = 104
    RULE_ruleMultiplicity = 105
    RULE_ruleMultiplicitySubset = 106
    RULE_ruleMultiplicityRange = 107
    RULE_ruleOwnedMultiplicity = 108
    RULE_ruleOwnedMultiplicityRange = 109
    RULE_ruleMultiplicityBounds = 110
    RULE_ruleMultiplicityExpressionMember = 111
    RULE_ruleDataType = 112
    RULE_ruleClass = 113
    RULE_ruleStructure = 114
    RULE_ruleAssociation = 115
    RULE_ruleAssociationStructure = 116
    RULE_ruleConnector = 117
    RULE_ruleConnectorDeclaration = 118
    RULE_ruleBinaryConnectorDeclaration = 119
    RULE_ruleNaryConnectorDeclaration = 120
    RULE_ruleConnectorEndMember = 121
    RULE_ruleConnectorEnd = 122
    RULE_ruleBindingConnector = 123
    RULE_ruleBindingConnectorDeclaration = 124
    RULE_ruleSuccession = 125
    RULE_ruleSuccessionDeclaration = 126
    RULE_ruleBehavior = 127
    RULE_ruleStep = 128
    RULE_ruleStepDeclaration = 129
    RULE_ruleFunction = 130
    RULE_ruleFunctionBody = 131
    RULE_ruleFunctionBodyPart = 132
    RULE_ruleReturnFeatureMember = 133
    RULE_ruleResultExpressionMember = 134
    RULE_ruleExpression = 135
    RULE_ruleExpressionDeclaration = 136
    RULE_rulePredicate = 137
    RULE_ruleBooleanExpression = 138
    RULE_ruleInvariant = 139
    RULE_ruleInteraction = 140
    RULE_ruleItemFlow = 141
    RULE_ruleSuccessionItemFlow = 142
    RULE_ruleItemFlowDeclaration = 143
    RULE_ruleItemFeatureMember = 144
    RULE_ruleItemFeature = 145
    RULE_ruleItemFeatureSpecializationPart = 146
    RULE_ruleItemFlowEndMember = 147
    RULE_ruleItemFlowEnd = 148
    RULE_ruleItemFlowEndSubsetting = 149
    RULE_ruleFeatureChainPrefix = 150
    RULE_ruleItemFlowFeatureMember = 151
    RULE_ruleItemFlowFeature = 152
    RULE_ruleItemFlowRedefinition = 153
    RULE_ruleMetaclass = 154
    RULE_rulePrefixMetadataAnnotation = 155
    RULE_rulePrefixMetadataMember = 156
    RULE_rulePrefixMetadataFeature = 157
    RULE_ruleMetadataFeature = 158
    RULE_ruleMetadataFeatureDeclaration = 159
    RULE_ruleMetadataTyping = 160
    RULE_ruleMetadataBody = 161
    RULE_ruleMetadataBodyFeatureMember = 162
    RULE_ruleMetadataBodyFeature = 163
    RULE_ruleExpressionBody = 164
    RULE_ruleOwnedExpressionMember = 165
    RULE_ruleOwnedExpression = 166
    RULE_ruleOwnedExpressionReference = 167
    RULE_ruleConditionalExpression = 168
    RULE_ruleConditionalOperator = 169
    RULE_ruleNullCoalescingExpression = 170
    RULE_ruleNullCoalescingOperator = 171
    RULE_ruleImpliesExpressionReference = 172
    RULE_ruleImpliesExpressionMember = 173
    RULE_ruleImpliesExpression = 174
    RULE_ruleImpliesOperator = 175
    RULE_ruleOrExpressionReference = 176
    RULE_ruleOrExpressionMember = 177
    RULE_ruleOrExpression = 178
    RULE_ruleOrOperator = 179
    RULE_ruleConditionalOrOperator = 180
    RULE_ruleXorExpressionReference = 181
    RULE_ruleXorExpressionMember = 182
    RULE_ruleXorExpression = 183
    RULE_ruleXorOperator = 184
    RULE_ruleAndExpression = 185
    RULE_ruleAndOperator = 186
    RULE_ruleConditionalAndOperator = 187
    RULE_ruleEqualityExpressionReference = 188
    RULE_ruleEqualityExpressionMember = 189
    RULE_ruleEqualityExpression = 190
    RULE_ruleEqualityOperator = 191
    RULE_ruleClassificationExpression = 192
    RULE_ruleClassificationTestOperator = 193
    RULE_ruleMetaClassificationTestOperator = 194
    RULE_ruleCastOperator = 195
    RULE_ruleMetaCastOperator = 196
    RULE_ruleMetadataReference = 197
    RULE_ruleTypeReferenceMember = 198
    RULE_ruleTypeResultMember = 199
    RULE_ruleTypeReference = 200
    RULE_ruleReferenceTyping = 201
    RULE_ruleSelfReferenceExpression = 202
    RULE_ruleSelfReferenceMember = 203
    RULE_ruleEmptyFeature = 204
    RULE_ruleRelationalExpression = 205
    RULE_ruleRelationalOperator = 206
    RULE_ruleRangeExpression = 207
    RULE_ruleAdditiveExpression = 208
    RULE_ruleAdditiveOperator = 209
    RULE_ruleMultiplicativeExpression = 210
    RULE_ruleMultiplicativeOperator = 211
    RULE_ruleExponentiationExpression = 212
    RULE_ruleExponentiationOperator = 213
    RULE_ruleUnaryExpression = 214
    RULE_ruleUnaryOperator = 215
    RULE_ruleExtentExpression = 216
    RULE_rulePrimaryExpression = 217
    RULE_ruleFunctionReferenceExpression = 218
    RULE_ruleFunctionReferenceMember = 219
    RULE_ruleFunctionReference = 220
    RULE_ruleFeatureChainMember = 221
    RULE_ruleBaseExpression = 222
    RULE_ruleBodyExpression = 223
    RULE_ruleExpressionBodyMember = 224
    RULE_ruleBodyParameter = 225
    RULE_ruleSequenceExpression = 226
    RULE_ruleFeatureReferenceExpression = 227
    RULE_ruleFeatureReferenceMember = 228
    RULE_ruleMetadataAccessExpression = 229
    RULE_ruleInvocationExpression = 230
    RULE_ruleOwnedFeatureChain = 231
    RULE_ruleFeatureChain = 232
    RULE_ruleOwnedFeatureChaining = 233
    RULE_ruleArgumentList = 234
    RULE_rulePositionalArgumentList = 235
    RULE_ruleArgumentMember = 236
    RULE_ruleArgument = 237
    RULE_ruleNamedArgumentList = 238
    RULE_ruleNamedArgumentMember = 239
    RULE_ruleNamedArgument = 240
    RULE_ruleParameterRedefinition = 241
    RULE_ruleArgumentValue = 242
    RULE_ruleNullExpression = 243
    RULE_ruleLiteralExpression = 244
    RULE_ruleLiteralBoolean = 245
    RULE_ruleBooleanValue = 246
    RULE_ruleLiteralString = 247
    RULE_ruleLiteralInteger = 248
    RULE_ruleLiteralReal = 249
    RULE_ruleRealValue = 250
    RULE_ruleLiteralInfinity = 251
    RULE_ruleName = 252
    RULE_ruleQualification = 253
    RULE_ruleQualifiedName = 254
    RULE_ruleFilterPackageMemberVisibility = 255
    RULE_ruleVisibilityIndicator = 256
    RULE_ruleFeatureDirection = 257

    ruleNames =  [ "entryRuleRootNamespace", "ruleRootNamespace", "ruleIdentification", 
                   "ruleRelationshipBody", "ruleRelationshipOwnedElement", 
                   "ruleOwnedRelatedElement", "ruleDependency", "ruleAnnotation", 
                   "ruleOwnedAnnotation", "ruleAnnotatingElement", "ruleComment", 
                   "ruleDocumentation", "ruleTextualRepresentation", "ruleNamespace", 
                   "ruleNamespaceDeclaration", "ruleNamespaceBody", "ruleNamespaceBodyElement", 
                   "ruleMemberPrefix", "ruleNamespaceMember", "ruleNonFeatureMember", 
                   "ruleNamespaceFeatureMember", "ruleAliasMember", "ruleImportPrefix", 
                   "ruleImport", "ruleMembershipImport", "ruleImportedMembership", 
                   "ruleNamespaceImport", "ruleImportedNamespace", "ruleFilterPackage", 
                   "ruleFilterPackageImport", "ruleFilterPackageMembershipImport", 
                   "ruleFilterPackageNamespaceImport", "ruleFilterPackageMember", 
                   "ruleMemberElement", "ruleNonFeatureElement", "ruleFeatureElement", 
                   "rulePackage", "ruleLibraryPackage", "rulePackageDeclaration", 
                   "rulePackageBody", "ruleElementFilterMember", "ruleTypePrefix", 
                   "ruleType", "ruleTypeDeclaration", "ruleSpecializationPart", 
                   "ruleConjugationPart", "ruleTypeRelationshipPart", "ruleDisjoiningPart", 
                   "ruleUnioningPart", "ruleIntersectingPart", "ruleDifferencingPart", 
                   "ruleTypeBody", "ruleFeatureMember", "ruleTypeFeatureMember", 
                   "ruleOwnedFeatureMember", "ruleSpecialization", "ruleOwnedSpecialization", 
                   "ruleConjugation", "ruleOwnedConjugation", "ruleDisjoining", 
                   "ruleOwnedDisjoining", "ruleUnioning", "ruleIntersecting", 
                   "ruleDifferencing", "ruleClassifier", "ruleClassifierDeclaration", 
                   "ruleSuperclassingPart", "ruleClassifierConjugationPart", 
                   "ruleSubclassification", "ruleOwnedsubclassification", 
                   "ruleClassifierConjugation", "ruleFeaturePrefix", "ruleFeature", 
                   "ruleFeatureDeclaration", "ruleFeatureRelationshipPart", 
                   "ruleChainingPart", "ruleInvertingPart", "ruleTypeFeaturingPart", 
                   "ruleFeatureSpecializationPart", "ruleMultiplicityPart", 
                   "ruleFeatureSpecialization", "ruleTypings", "ruleTypedBy", 
                   "ruleSubsettings", "ruleSubsets", "ruleReferences", "ruleReferencesKeyword", 
                   "ruleRedefinitions", "ruleRedefines", "ruleFeatureInverting", 
                   "ruleOwnedFeatureInverting", "ruleTypeFeaturing", "ruleOwnedTypeFeaturing", 
                   "ruleFeatureTyping", "ruleOwnedFeatureTyping", "ruleFeatureType", 
                   "ruleSubsetting", "ruleOwnedSubsetting", "ruleOwnedReferenceSubsetting", 
                   "ruleRedefinition", "ruleOwnedRedefinition", "ruleFeatureConjugationPart", 
                   "ruleFeatureConjugation", "ruleValuePart", "ruleFeatureValue", 
                   "ruleMultiplicity", "ruleMultiplicitySubset", "ruleMultiplicityRange", 
                   "ruleOwnedMultiplicity", "ruleOwnedMultiplicityRange", 
                   "ruleMultiplicityBounds", "ruleMultiplicityExpressionMember", 
                   "ruleDataType", "ruleClass", "ruleStructure", "ruleAssociation", 
                   "ruleAssociationStructure", "ruleConnector", "ruleConnectorDeclaration", 
                   "ruleBinaryConnectorDeclaration", "ruleNaryConnectorDeclaration", 
                   "ruleConnectorEndMember", "ruleConnectorEnd", "ruleBindingConnector", 
                   "ruleBindingConnectorDeclaration", "ruleSuccession", 
                   "ruleSuccessionDeclaration", "ruleBehavior", "ruleStep", 
                   "ruleStepDeclaration", "ruleFunction", "ruleFunctionBody", 
                   "ruleFunctionBodyPart", "ruleReturnFeatureMember", "ruleResultExpressionMember", 
                   "ruleExpression", "ruleExpressionDeclaration", "rulePredicate", 
                   "ruleBooleanExpression", "ruleInvariant", "ruleInteraction", 
                   "ruleItemFlow", "ruleSuccessionItemFlow", "ruleItemFlowDeclaration", 
                   "ruleItemFeatureMember", "ruleItemFeature", "ruleItemFeatureSpecializationPart", 
                   "ruleItemFlowEndMember", "ruleItemFlowEnd", "ruleItemFlowEndSubsetting", 
                   "ruleFeatureChainPrefix", "ruleItemFlowFeatureMember", 
                   "ruleItemFlowFeature", "ruleItemFlowRedefinition", "ruleMetaclass", 
                   "rulePrefixMetadataAnnotation", "rulePrefixMetadataMember", 
                   "rulePrefixMetadataFeature", "ruleMetadataFeature", "ruleMetadataFeatureDeclaration", 
                   "ruleMetadataTyping", "ruleMetadataBody", "ruleMetadataBodyFeatureMember", 
                   "ruleMetadataBodyFeature", "ruleExpressionBody", "ruleOwnedExpressionMember", 
                   "ruleOwnedExpression", "ruleOwnedExpressionReference", 
                   "ruleConditionalExpression", "ruleConditionalOperator", 
                   "ruleNullCoalescingExpression", "ruleNullCoalescingOperator", 
                   "ruleImpliesExpressionReference", "ruleImpliesExpressionMember", 
                   "ruleImpliesExpression", "ruleImpliesOperator", "ruleOrExpressionReference", 
                   "ruleOrExpressionMember", "ruleOrExpression", "ruleOrOperator", 
                   "ruleConditionalOrOperator", "ruleXorExpressionReference", 
                   "ruleXorExpressionMember", "ruleXorExpression", "ruleXorOperator", 
                   "ruleAndExpression", "ruleAndOperator", "ruleConditionalAndOperator", 
                   "ruleEqualityExpressionReference", "ruleEqualityExpressionMember", 
                   "ruleEqualityExpression", "ruleEqualityOperator", "ruleClassificationExpression", 
                   "ruleClassificationTestOperator", "ruleMetaClassificationTestOperator", 
                   "ruleCastOperator", "ruleMetaCastOperator", "ruleMetadataReference", 
                   "ruleTypeReferenceMember", "ruleTypeResultMember", "ruleTypeReference", 
                   "ruleReferenceTyping", "ruleSelfReferenceExpression", 
                   "ruleSelfReferenceMember", "ruleEmptyFeature", "ruleRelationalExpression", 
                   "ruleRelationalOperator", "ruleRangeExpression", "ruleAdditiveExpression", 
                   "ruleAdditiveOperator", "ruleMultiplicativeExpression", 
                   "ruleMultiplicativeOperator", "ruleExponentiationExpression", 
                   "ruleExponentiationOperator", "ruleUnaryExpression", 
                   "ruleUnaryOperator", "ruleExtentExpression", "rulePrimaryExpression", 
                   "ruleFunctionReferenceExpression", "ruleFunctionReferenceMember", 
                   "ruleFunctionReference", "ruleFeatureChainMember", "ruleBaseExpression", 
                   "ruleBodyExpression", "ruleExpressionBodyMember", "ruleBodyParameter", 
                   "ruleSequenceExpression", "ruleFeatureReferenceExpression", 
                   "ruleFeatureReferenceMember", "ruleMetadataAccessExpression", 
                   "ruleInvocationExpression", "ruleOwnedFeatureChain", 
                   "ruleFeatureChain", "ruleOwnedFeatureChaining", "ruleArgumentList", 
                   "rulePositionalArgumentList", "ruleArgumentMember", "ruleArgument", 
                   "ruleNamedArgumentList", "ruleNamedArgumentMember", "ruleNamedArgument", 
                   "ruleParameterRedefinition", "ruleArgumentValue", "ruleNullExpression", 
                   "ruleLiteralExpression", "ruleLiteralBoolean", "ruleBooleanValue", 
                   "ruleLiteralString", "ruleLiteralInteger", "ruleLiteralReal", 
                   "ruleRealValue", "ruleLiteralInfinity", "ruleName", "ruleQualification", 
                   "ruleQualifiedName", "ruleFilterPackageMemberVisibility", 
                   "ruleVisibilityIndicator", "ruleFeatureDirection" ]

    EOF = Token.EOF
    K_DEPENDENCY=1
    K_FROM=2
    K_TO=3
    K_COMMENT=4
    K_ABOUT=5
    K_LOCALE=6
    K_DOC=7
    K_REP=8
    K_LANGUAGE=9
    K_NAMESPACE=10
    K_ALIAS=11
    K_FOR=12
    K_IMPORT=13
    K_ALL=14
    K_STANDARD=15
    K_LIBRARY=16
    K_PACKAGE=17
    K_FILTER=18
    K_ABSTRACT=19
    K_TYPE=20
    K_SPECIALIZES=21
    K_CONJUGATES=22
    K_DISJOINT=23
    K_UNIONS=24
    K_INTERSECTS=25
    K_DIFFERENCES=26
    K_MEMBER=27
    K_SPECIALIZATION=28
    K_SUBTYPE=29
    K_CONJUGATION=30
    K_CONJUGATE=31
    K_DISJOINING=32
    K_CLASSIFIER=33
    K_SUBCLASSIFIER=34
    K_COMPOSITE=35
    K_PORTION=36
    K_READONLY=37
    K_DERIVED=38
    K_END=39
    K_FEATURE=40
    K_CHAINS=41
    K_INVERSE=42
    K_OF=43
    K_FEATURED=44
    K_BY=45
    K_ORDERED=46
    K_NONUNIQUE=47
    K_TYPED=48
    K_SUBSETS=49
    K_REFERENCES=50
    K_REDEFINES=51
    K_INVERTING=52
    K_FEATURING=53
    K_TYPING=54
    K_SUBSET=55
    K_REDEFINITION=56
    K_DEFAULT=57
    K_MULTIPLICITY=58
    K_DATATYPE=59
    K_CLASS=60
    K_STRUCT=61
    K_ASSOC=62
    K_CONNECTOR=63
    K_BINDING=64
    K_SUCCESSION=65
    K_FIRST=66
    K_THEN=67
    K_BEHAVIOR=68
    K_STEP=69
    K_FUNCTION=70
    K_RETURN=71
    K_EXPR=72
    K_PREDICATE=73
    K_BOOL=74
    K_INV=75
    K_TRUE=76
    K_FALSE=77
    K_INTERACTION=78
    K_FLOW=79
    K_METACLASS=80
    K_METADATA=81
    K_ELSE=82
    K_IF=83
    K_IMPLIES=84
    K_OR=85
    K_XOR=86
    K_AND=87
    K_HASTYPE=88
    K_ISTYPE=89
    K_AS=90
    K_META=91
    K_NOT=92
    K_NULL=93
    K_PUBLIC=94
    K_PRIVATE=95
    K_PROTECTED=96
    K_IN=97
    K_OUT=98
    K_INOUT=99
    LANGLE=100
    RANGLE=101
    LBRACE=102
    RBRACE=103
    RSQUARE=104
    LSQUARE=105
    LPAREN=106
    RPAREN=107
    OP_SEMI=108
    OP_COMMA=109
    OP_COLON_COLON=110
    OP_STAR_STAR=111
    OP_STAR=112
    OP_COLON_RANGLE=113
    OP_TILDE=114
    OP_COLON=115
    OP_COLON_COLON_RANGLE=116
    OP_COLON_RANGLE_RANGLE=117
    OP_EQ=118
    OP_COLON_EQ=119
    OP_DOT_DOT=120
    OP_DOT=121
    OP_HASH=122
    OP_AT=123
    OP_QMARK=124
    OP_QMARK_QMARK=125
    OP_BAR=126
    OP_AND=127
    OP_EQ_EQ=128
    OP_BANG_EQ=129
    OP_EQ_EQ_EQ=130
    OP_BANG_EQ_EQ=131
    OP_AT_AT=132
    OP_LANGLE_EQ=133
    OP_RANGLE_EQ=134
    OP_PLUS=135
    OP_MINUS=136
    OP_SLASH=137
    OP_PERCENT=138
    OP_HAT=139
    OP_MINUS_RANGLE=140
    OP_DOT_QMARK=141
    RULE_DECIMAL_VALUE=142
    RULE_EXP_VALUE=143
    RULE_ID=144
    RULE_UNRESTRICTED_NAME=145
    RULE_STRING_VALUE=146
    RULE_REGULAR_COMMENT=147
    RULE_ML_NOTE=148
    RULE_SL_NOTE=149
    RULE_WS=150

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class EntryRuleRootNamespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleRootNamespace(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRootNamespaceContext,0)


        def EOF(self):
            return self.getToken(KerMLv2Parser.EOF, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_entryRuleRootNamespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntryRuleRootNamespace" ):
                listener.enterEntryRuleRootNamespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntryRuleRootNamespace" ):
                listener.exitEntryRuleRootNamespace(self)




    def entryRuleRootNamespace(self):

        localctx = KerMLv2Parser.EntryRuleRootNamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_entryRuleRootNamespace)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 516
            self.ruleRootNamespace()
            self.state = 517
            self.match(KerMLv2Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRootNamespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleNamespaceBodyElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNamespaceBodyElementContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNamespaceBodyElementContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRootNamespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRootNamespace" ):
                listener.enterRuleRootNamespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRootNamespace" ):
                listener.exitRuleRootNamespace(self)




    def ruleRootNamespace(self):

        localctx = KerMLv2Parser.RuleRootNamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_ruleRootNamespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -144178960004288558) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 882144912399912819) != 0) or ((((_la - 144)) & ~0x3f) == 0 and ((1 << (_la - 144)) & 11) != 0):
                self.state = 519
                self.ruleNamespaceBodyElement()
                self.state = 524
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleIdentificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleIdentification

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleIdentification2Context(RuleIdentificationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleIdentificationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleIdentification2" ):
                listener.enterRuleIdentification2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleIdentification2" ):
                listener.exitRuleIdentification2(self)


    class RuleIdentification1Context(RuleIdentificationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleIdentificationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LANGLE(self):
            return self.getToken(KerMLv2Parser.LANGLE, 0)
        def ruleName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNameContext,i)

        def RANGLE(self):
            return self.getToken(KerMLv2Parser.RANGLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleIdentification1" ):
                listener.enterRuleIdentification1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleIdentification1" ):
                listener.exitRuleIdentification1(self)



    def ruleIdentification(self):

        localctx = KerMLv2Parser.RuleIdentificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_ruleIdentification)
        self._la = 0 # Token type
        try:
            self.state = 532
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [100]:
                localctx = KerMLv2Parser.RuleIdentification1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 525
                self.match(KerMLv2Parser.LANGLE)
                self.state = 526
                self.ruleName()
                self.state = 527
                self.match(KerMLv2Parser.RANGLE)
                self.state = 529
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==144 or _la==145:
                    self.state = 528
                    self.ruleName()


                pass
            elif token in [144, 145]:
                localctx = KerMLv2Parser.RuleIdentification2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 531
                self.ruleName()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRelationshipBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRelationshipBody

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleRelationshipBody1Context(RuleRelationshipBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRelationshipBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_SEMI(self):
            return self.getToken(KerMLv2Parser.OP_SEMI, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRelationshipBody1" ):
                listener.enterRuleRelationshipBody1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRelationshipBody1" ):
                listener.exitRuleRelationshipBody1(self)


    class RuleRelationshipBody2Context(RuleRelationshipBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRelationshipBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACE(self):
            return self.getToken(KerMLv2Parser.LBRACE, 0)
        def RBRACE(self):
            return self.getToken(KerMLv2Parser.RBRACE, 0)
        def ruleRelationshipOwnedElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleRelationshipOwnedElementContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipOwnedElementContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRelationshipBody2" ):
                listener.enterRuleRelationshipBody2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRelationshipBody2" ):
                listener.exitRuleRelationshipBody2(self)



    def ruleRelationshipBody(self):

        localctx = KerMLv2Parser.RuleRelationshipBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_ruleRelationshipBody)
        self._la = 0 # Token type
        try:
            self.state = 543
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [108]:
                localctx = KerMLv2Parser.RuleRelationshipBody1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 534
                self.match(KerMLv2Parser.OP_SEMI)
                pass
            elif token in [102]:
                localctx = KerMLv2Parser.RuleRelationshipBody2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 535
                self.match(KerMLv2Parser.LBRACE)
                self.state = 539
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & -144178960004298798) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 882144904883720051) != 0) or ((((_la - 144)) & ~0x3f) == 0 and ((1 << (_la - 144)) & 11) != 0):
                    self.state = 536
                    self.ruleRelationshipOwnedElement()
                    self.state = 541
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 542
                self.match(KerMLv2Parser.RBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRelationshipOwnedElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRelationshipOwnedElement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleRelationshipOwnedElement1Context(RuleRelationshipOwnedElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRelationshipOwnedElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedRelatedElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedRelatedElementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRelationshipOwnedElement1" ):
                listener.enterRuleRelationshipOwnedElement1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRelationshipOwnedElement1" ):
                listener.exitRuleRelationshipOwnedElement1(self)


    class RuleRelationshipOwnedElement2Context(RuleRelationshipOwnedElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRelationshipOwnedElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedAnnotation(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedAnnotationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRelationshipOwnedElement2" ):
                listener.enterRuleRelationshipOwnedElement2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRelationshipOwnedElement2" ):
                listener.exitRuleRelationshipOwnedElement2(self)



    def ruleRelationshipOwnedElement(self):

        localctx = KerMLv2Parser.RuleRelationshipOwnedElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_ruleRelationshipOwnedElement)
        try:
            self.state = 547
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleRelationshipOwnedElement1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 545
                self.ruleOwnedRelatedElement()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleRelationshipOwnedElement2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 546
                self.ruleOwnedAnnotation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedRelatedElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedRelatedElement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleOwnedRelatedElement1Context(RuleOwnedRelatedElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedRelatedElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleNonFeatureElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNonFeatureElementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedRelatedElement1" ):
                listener.enterRuleOwnedRelatedElement1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedRelatedElement1" ):
                listener.exitRuleOwnedRelatedElement1(self)


    class RuleOwnedRelatedElement2Context(RuleOwnedRelatedElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedRelatedElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureElementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedRelatedElement2" ):
                listener.enterRuleOwnedRelatedElement2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedRelatedElement2" ):
                listener.exitRuleOwnedRelatedElement2(self)



    def ruleOwnedRelatedElement(self):

        localctx = KerMLv2Parser.RuleOwnedRelatedElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ruleOwnedRelatedElement)
        try:
            self.state = 551
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleOwnedRelatedElement1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 549
                self.ruleNonFeatureElement()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleOwnedRelatedElement2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 550
                self.ruleFeatureElement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDependencyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DEPENDENCY(self):
            return self.getToken(KerMLv2Parser.K_DEPENDENCY, 0)

        def ruleQualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleQualifiedNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,i)


        def K_TO(self):
            return self.getToken(KerMLv2Parser.K_TO, 0)

        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def rulePrefixMetadataAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RulePrefixMetadataAnnotationContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataAnnotationContext,i)


        def K_FROM(self):
            return self.getToken(KerMLv2Parser.K_FROM, 0)

        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleDependency

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDependency" ):
                listener.enterRuleDependency(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDependency" ):
                listener.exitRuleDependency(self)




    def ruleDependency(self):

        localctx = KerMLv2Parser.RuleDependencyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_ruleDependency)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 556
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==122:
                self.state = 553
                self.rulePrefixMetadataAnnotation()
                self.state = 558
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 559
            self.match(KerMLv2Parser.K_DEPENDENCY)
            self.state = 564
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.state = 561
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 560
                    self.ruleIdentification()


                self.state = 563
                self.match(KerMLv2Parser.K_FROM)


            self.state = 566
            self.ruleQualifiedName()
            self.state = 571
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 567
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 568
                self.ruleQualifiedName()
                self.state = 573
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 574
            self.match(KerMLv2Parser.K_TO)
            self.state = 575
            self.ruleQualifiedName()
            self.state = 580
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 576
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 577
                self.ruleQualifiedName()
                self.state = 582
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 583
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAnnotation" ):
                listener.enterRuleAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAnnotation" ):
                listener.exitRuleAnnotation(self)




    def ruleAnnotation(self):

        localctx = KerMLv2Parser.RuleAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ruleAnnotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 585
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleAnnotatingElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleAnnotatingElementContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedAnnotation" ):
                listener.enterRuleOwnedAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedAnnotation" ):
                listener.exitRuleOwnedAnnotation(self)




    def ruleOwnedAnnotation(self):

        localctx = KerMLv2Parser.RuleOwnedAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_ruleOwnedAnnotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 587
            self.ruleAnnotatingElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleAnnotatingElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleAnnotatingElement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleAnnotatingElement1Context(RuleAnnotatingElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleAnnotatingElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleComment(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleCommentContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAnnotatingElement1" ):
                listener.enterRuleAnnotatingElement1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAnnotatingElement1" ):
                listener.exitRuleAnnotatingElement1(self)


    class RuleAnnotatingElement2Context(RuleAnnotatingElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleAnnotatingElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleDocumentation(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleDocumentationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAnnotatingElement2" ):
                listener.enterRuleAnnotatingElement2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAnnotatingElement2" ):
                listener.exitRuleAnnotatingElement2(self)


    class RuleAnnotatingElement3Context(RuleAnnotatingElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleAnnotatingElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleTextualRepresentation(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTextualRepresentationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAnnotatingElement3" ):
                listener.enterRuleAnnotatingElement3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAnnotatingElement3" ):
                listener.exitRuleAnnotatingElement3(self)


    class RuleAnnotatingElement4Context(RuleAnnotatingElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleAnnotatingElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMetadataFeature(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataFeatureContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAnnotatingElement4" ):
                listener.enterRuleAnnotatingElement4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAnnotatingElement4" ):
                listener.exitRuleAnnotatingElement4(self)



    def ruleAnnotatingElement(self):

        localctx = KerMLv2Parser.RuleAnnotatingElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_ruleAnnotatingElement)
        try:
            self.state = 593
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 6, 147]:
                localctx = KerMLv2Parser.RuleAnnotatingElement1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 589
                self.ruleComment()
                pass
            elif token in [7]:
                localctx = KerMLv2Parser.RuleAnnotatingElement2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 590
                self.ruleDocumentation()
                pass
            elif token in [8, 9]:
                localctx = KerMLv2Parser.RuleAnnotatingElement3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 591
                self.ruleTextualRepresentation()
                pass
            elif token in [81, 122, 123]:
                localctx = KerMLv2Parser.RuleAnnotatingElement4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 592
                self.ruleMetadataFeature()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleCommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULE_REGULAR_COMMENT(self):
            return self.getToken(KerMLv2Parser.RULE_REGULAR_COMMENT, 0)

        def K_COMMENT(self):
            return self.getToken(KerMLv2Parser.K_COMMENT, 0)

        def K_LOCALE(self):
            return self.getToken(KerMLv2Parser.K_LOCALE, 0)

        def RULE_STRING_VALUE(self):
            return self.getToken(KerMLv2Parser.RULE_STRING_VALUE, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def K_ABOUT(self):
            return self.getToken(KerMLv2Parser.K_ABOUT, 0)

        def ruleAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAnnotationContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAnnotationContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleComment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleComment" ):
                listener.enterRuleComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleComment" ):
                listener.exitRuleComment(self)




    def ruleComment(self):

        localctx = KerMLv2Parser.RuleCommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_ruleComment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 610
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 595
                self.match(KerMLv2Parser.K_COMMENT)
                self.state = 597
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 596
                    self.ruleIdentification()


                self.state = 608
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==5:
                    self.state = 599
                    self.match(KerMLv2Parser.K_ABOUT)
                    self.state = 600
                    self.ruleAnnotation()
                    self.state = 605
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==109:
                        self.state = 601
                        self.match(KerMLv2Parser.OP_COMMA)
                        self.state = 602
                        self.ruleAnnotation()
                        self.state = 607
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)





            self.state = 614
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 612
                self.match(KerMLv2Parser.K_LOCALE)
                self.state = 613
                self.match(KerMLv2Parser.RULE_STRING_VALUE)


            self.state = 616
            self.match(KerMLv2Parser.RULE_REGULAR_COMMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDocumentationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DOC(self):
            return self.getToken(KerMLv2Parser.K_DOC, 0)

        def RULE_REGULAR_COMMENT(self):
            return self.getToken(KerMLv2Parser.RULE_REGULAR_COMMENT, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def K_LOCALE(self):
            return self.getToken(KerMLv2Parser.K_LOCALE, 0)

        def RULE_STRING_VALUE(self):
            return self.getToken(KerMLv2Parser.RULE_STRING_VALUE, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleDocumentation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDocumentation" ):
                listener.enterRuleDocumentation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDocumentation" ):
                listener.exitRuleDocumentation(self)




    def ruleDocumentation(self):

        localctx = KerMLv2Parser.RuleDocumentationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_ruleDocumentation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 618
            self.match(KerMLv2Parser.K_DOC)
            self.state = 620
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                self.state = 619
                self.ruleIdentification()


            self.state = 624
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 622
                self.match(KerMLv2Parser.K_LOCALE)
                self.state = 623
                self.match(KerMLv2Parser.RULE_STRING_VALUE)


            self.state = 626
            self.match(KerMLv2Parser.RULE_REGULAR_COMMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTextualRepresentationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_LANGUAGE(self):
            return self.getToken(KerMLv2Parser.K_LANGUAGE, 0)

        def RULE_STRING_VALUE(self):
            return self.getToken(KerMLv2Parser.RULE_STRING_VALUE, 0)

        def RULE_REGULAR_COMMENT(self):
            return self.getToken(KerMLv2Parser.RULE_REGULAR_COMMENT, 0)

        def K_REP(self):
            return self.getToken(KerMLv2Parser.K_REP, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTextualRepresentation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTextualRepresentation" ):
                listener.enterRuleTextualRepresentation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTextualRepresentation" ):
                listener.exitRuleTextualRepresentation(self)




    def ruleTextualRepresentation(self):

        localctx = KerMLv2Parser.RuleTextualRepresentationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ruleTextualRepresentation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 632
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 628
                self.match(KerMLv2Parser.K_REP)
                self.state = 630
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 629
                    self.ruleIdentification()




            self.state = 634
            self.match(KerMLv2Parser.K_LANGUAGE)
            self.state = 635
            self.match(KerMLv2Parser.RULE_STRING_VALUE)
            self.state = 636
            self.match(KerMLv2Parser.RULE_REGULAR_COMMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleNamespaceDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNamespaceDeclarationContext,0)


        def ruleNamespaceBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNamespaceBodyContext,0)


        def rulePrefixMetadataMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RulePrefixMetadataMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataMemberContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespace" ):
                listener.enterRuleNamespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespace" ):
                listener.exitRuleNamespace(self)




    def ruleNamespace(self):

        localctx = KerMLv2Parser.RuleNamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_ruleNamespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 641
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==122:
                self.state = 638
                self.rulePrefixMetadataMember()
                self.state = 643
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 644
            self.ruleNamespaceDeclaration()
            self.state = 645
            self.ruleNamespaceBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamespaceDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_NAMESPACE(self):
            return self.getToken(KerMLv2Parser.K_NAMESPACE, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamespaceDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceDeclaration" ):
                listener.enterRuleNamespaceDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceDeclaration" ):
                listener.exitRuleNamespaceDeclaration(self)




    def ruleNamespaceDeclaration(self):

        localctx = KerMLv2Parser.RuleNamespaceDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_ruleNamespaceDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 647
            self.match(KerMLv2Parser.K_NAMESPACE)
            self.state = 649
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                self.state = 648
                self.ruleIdentification()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamespaceBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamespaceBody

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleNamespaceBody2Context(RuleNamespaceBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNamespaceBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACE(self):
            return self.getToken(KerMLv2Parser.LBRACE, 0)
        def RBRACE(self):
            return self.getToken(KerMLv2Parser.RBRACE, 0)
        def ruleNamespaceMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNamespaceMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNamespaceMemberContext,i)

        def ruleAliasMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAliasMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAliasMemberContext,i)

        def ruleImport(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleImportContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleImportContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceBody2" ):
                listener.enterRuleNamespaceBody2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceBody2" ):
                listener.exitRuleNamespaceBody2(self)


    class RuleNamespaceBody1Context(RuleNamespaceBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNamespaceBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_SEMI(self):
            return self.getToken(KerMLv2Parser.OP_SEMI, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceBody1" ):
                listener.enterRuleNamespaceBody1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceBody1" ):
                listener.exitRuleNamespaceBody1(self)



    def ruleNamespaceBody(self):

        localctx = KerMLv2Parser.RuleNamespaceBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_ruleNamespaceBody)
        self._la = 0 # Token type
        try:
            self.state = 662
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [108]:
                localctx = KerMLv2Parser.RuleNamespaceBody1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 651
                self.match(KerMLv2Parser.OP_SEMI)
                pass
            elif token in [102]:
                localctx = KerMLv2Parser.RuleNamespaceBody2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 652
                self.match(KerMLv2Parser.LBRACE)
                self.state = 658
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & -144178960004288558) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 882144912399912819) != 0) or ((((_la - 144)) & ~0x3f) == 0 and ((1 << (_la - 144)) & 11) != 0):
                    self.state = 656
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
                    if la_ == 1:
                        self.state = 653
                        self.ruleNamespaceMember()
                        pass

                    elif la_ == 2:
                        self.state = 654
                        self.ruleAliasMember()
                        pass

                    elif la_ == 3:
                        self.state = 655
                        self.ruleImport()
                        pass


                    self.state = 660
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 661
                self.match(KerMLv2Parser.RBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamespaceBodyElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamespaceBodyElement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleNamespaceBodyElement1Context(RuleNamespaceBodyElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNamespaceBodyElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleNamespaceMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNamespaceMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceBodyElement1" ):
                listener.enterRuleNamespaceBodyElement1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceBodyElement1" ):
                listener.exitRuleNamespaceBodyElement1(self)


    class RuleNamespaceBodyElement2Context(RuleNamespaceBodyElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNamespaceBodyElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleAliasMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleAliasMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceBodyElement2" ):
                listener.enterRuleNamespaceBodyElement2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceBodyElement2" ):
                listener.exitRuleNamespaceBodyElement2(self)


    class RuleNamespaceBodyElement3Context(RuleNamespaceBodyElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNamespaceBodyElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleImport(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImportContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceBodyElement3" ):
                listener.enterRuleNamespaceBodyElement3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceBodyElement3" ):
                listener.exitRuleNamespaceBodyElement3(self)



    def ruleNamespaceBodyElement(self):

        localctx = KerMLv2Parser.RuleNamespaceBodyElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_ruleNamespaceBodyElement)
        try:
            self.state = 667
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleNamespaceBodyElement1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 664
                self.ruleNamespaceMember()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleNamespaceBodyElement2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 665
                self.ruleAliasMember()
                pass

            elif la_ == 3:
                localctx = KerMLv2Parser.RuleNamespaceBodyElement3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 666
                self.ruleImport()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMemberPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleVisibilityIndicator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleVisibilityIndicatorContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMemberPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMemberPrefix" ):
                listener.enterRuleMemberPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMemberPrefix" ):
                listener.exitRuleMemberPrefix(self)




    def ruleMemberPrefix(self):

        localctx = KerMLv2Parser.RuleMemberPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_ruleMemberPrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 670
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 94)) & ~0x3f) == 0 and ((1 << (_la - 94)) & 7) != 0):
                self.state = 669
                self.ruleVisibilityIndicator()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamespaceMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamespaceMember

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleNamespaceMember2Context(RuleNamespaceMemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNamespaceMemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleNamespaceFeatureMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNamespaceFeatureMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceMember2" ):
                listener.enterRuleNamespaceMember2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceMember2" ):
                listener.exitRuleNamespaceMember2(self)


    class RuleNamespaceMember1Context(RuleNamespaceMemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNamespaceMemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleNonFeatureMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNonFeatureMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceMember1" ):
                listener.enterRuleNamespaceMember1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceMember1" ):
                listener.exitRuleNamespaceMember1(self)



    def ruleNamespaceMember(self):

        localctx = KerMLv2Parser.RuleNamespaceMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_ruleNamespaceMember)
        try:
            self.state = 674
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleNamespaceMember1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 672
                self.ruleNonFeatureMember()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleNamespaceMember2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 673
                self.ruleNamespaceFeatureMember()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNonFeatureMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMemberPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMemberPrefixContext,0)


        def ruleMemberElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMemberElementContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNonFeatureMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureMember" ):
                listener.enterRuleNonFeatureMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureMember" ):
                listener.exitRuleNonFeatureMember(self)




    def ruleNonFeatureMember(self):

        localctx = KerMLv2Parser.RuleNonFeatureMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ruleNonFeatureMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 676
            self.ruleMemberPrefix()
            self.state = 677
            self.ruleMemberElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamespaceFeatureMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMemberPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMemberPrefixContext,0)


        def ruleFeatureElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureElementContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamespaceFeatureMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceFeatureMember" ):
                listener.enterRuleNamespaceFeatureMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceFeatureMember" ):
                listener.exitRuleNamespaceFeatureMember(self)




    def ruleNamespaceFeatureMember(self):

        localctx = KerMLv2Parser.RuleNamespaceFeatureMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_ruleNamespaceFeatureMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 679
            self.ruleMemberPrefix()
            self.state = 680
            self.ruleFeatureElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleAliasMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMemberPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMemberPrefixContext,0)


        def K_ALIAS(self):
            return self.getToken(KerMLv2Parser.K_ALIAS, 0)

        def K_FOR(self):
            return self.getToken(KerMLv2Parser.K_FOR, 0)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def LANGLE(self):
            return self.getToken(KerMLv2Parser.LANGLE, 0)

        def ruleName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNameContext,i)


        def RANGLE(self):
            return self.getToken(KerMLv2Parser.RANGLE, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleAliasMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAliasMember" ):
                listener.enterRuleAliasMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAliasMember" ):
                listener.exitRuleAliasMember(self)




    def ruleAliasMember(self):

        localctx = KerMLv2Parser.RuleAliasMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_ruleAliasMember)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 682
            self.ruleMemberPrefix()
            self.state = 683
            self.match(KerMLv2Parser.K_ALIAS)
            self.state = 688
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==100:
                self.state = 684
                self.match(KerMLv2Parser.LANGLE)
                self.state = 685
                self.ruleName()
                self.state = 686
                self.match(KerMLv2Parser.RANGLE)


            self.state = 691
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==144 or _la==145:
                self.state = 690
                self.ruleName()


            self.state = 693
            self.match(KerMLv2Parser.K_FOR)
            self.state = 694
            self.ruleQualifiedName()
            self.state = 695
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleImportPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_IMPORT(self):
            return self.getToken(KerMLv2Parser.K_IMPORT, 0)

        def ruleVisibilityIndicator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleVisibilityIndicatorContext,0)


        def K_ALL(self):
            return self.getToken(KerMLv2Parser.K_ALL, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleImportPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleImportPrefix" ):
                listener.enterRuleImportPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleImportPrefix" ):
                listener.exitRuleImportPrefix(self)




    def ruleImportPrefix(self):

        localctx = KerMLv2Parser.RuleImportPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_ruleImportPrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 698
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 94)) & ~0x3f) == 0 and ((1 << (_la - 94)) & 7) != 0):
                self.state = 697
                self.ruleVisibilityIndicator()


            self.state = 700
            self.match(KerMLv2Parser.K_IMPORT)
            self.state = 702
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 701
                self.match(KerMLv2Parser.K_ALL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleImportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def ruleMembershipImport(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMembershipImportContext,0)


        def ruleNamespaceImport(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNamespaceImportContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleImport

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleImport" ):
                listener.enterRuleImport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleImport" ):
                listener.exitRuleImport(self)




    def ruleImport(self):

        localctx = KerMLv2Parser.RuleImportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_ruleImport)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.state = 704
                self.ruleMembershipImport()
                pass

            elif la_ == 2:
                self.state = 705
                self.ruleNamespaceImport()
                pass


            self.state = 708
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMembershipImportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleImportPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImportPrefixContext,0)


        def ruleImportedMembership(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImportedMembershipContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMembershipImport

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMembershipImport" ):
                listener.enterRuleMembershipImport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMembershipImport" ):
                listener.exitRuleMembershipImport(self)




    def ruleMembershipImport(self):

        localctx = KerMLv2Parser.RuleMembershipImportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_ruleMembershipImport)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 710
            self.ruleImportPrefix()
            self.state = 711
            self.ruleImportedMembership()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleImportedMembershipContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def OP_COLON_COLON(self):
            return self.getToken(KerMLv2Parser.OP_COLON_COLON, 0)

        def OP_STAR_STAR(self):
            return self.getToken(KerMLv2Parser.OP_STAR_STAR, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleImportedMembership

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleImportedMembership" ):
                listener.enterRuleImportedMembership(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleImportedMembership" ):
                listener.exitRuleImportedMembership(self)




    def ruleImportedMembership(self):

        localctx = KerMLv2Parser.RuleImportedMembershipContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_ruleImportedMembership)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 713
            self.ruleQualifiedName()
            self.state = 716
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==110:
                self.state = 714
                self.match(KerMLv2Parser.OP_COLON_COLON)
                self.state = 715
                self.match(KerMLv2Parser.OP_STAR_STAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamespaceImportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleImportPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImportPrefixContext,0)


        def ruleImportedNamespace(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImportedNamespaceContext,0)


        def ruleFilterPackage(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFilterPackageContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamespaceImport

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamespaceImport" ):
                listener.enterRuleNamespaceImport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamespaceImport" ):
                listener.exitRuleNamespaceImport(self)




    def ruleNamespaceImport(self):

        localctx = KerMLv2Parser.RuleNamespaceImportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_ruleNamespaceImport)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 718
            self.ruleImportPrefix()
            self.state = 721
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.state = 719
                self.ruleImportedNamespace()
                pass

            elif la_ == 2:
                self.state = 720
                self.ruleFilterPackage()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleImportedNamespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def OP_COLON_COLON(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COLON_COLON)
            else:
                return self.getToken(KerMLv2Parser.OP_COLON_COLON, i)

        def OP_STAR(self):
            return self.getToken(KerMLv2Parser.OP_STAR, 0)

        def OP_STAR_STAR(self):
            return self.getToken(KerMLv2Parser.OP_STAR_STAR, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleImportedNamespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleImportedNamespace" ):
                listener.enterRuleImportedNamespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleImportedNamespace" ):
                listener.exitRuleImportedNamespace(self)




    def ruleImportedNamespace(self):

        localctx = KerMLv2Parser.RuleImportedNamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_ruleImportedNamespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 723
            self.ruleQualifiedName()
            self.state = 724
            self.match(KerMLv2Parser.OP_COLON_COLON)
            self.state = 725
            self.match(KerMLv2Parser.OP_STAR)
            self.state = 728
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==110:
                self.state = 726
                self.match(KerMLv2Parser.OP_COLON_COLON)
                self.state = 727
                self.match(KerMLv2Parser.OP_STAR_STAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFilterPackageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFilterPackageImport(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFilterPackageImportContext,0)


        def ruleFilterPackageMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFilterPackageMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFilterPackageMemberContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFilterPackage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFilterPackage" ):
                listener.enterRuleFilterPackage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFilterPackage" ):
                listener.exitRuleFilterPackage(self)




    def ruleFilterPackage(self):

        localctx = KerMLv2Parser.RuleFilterPackageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_ruleFilterPackage)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 730
            self.ruleFilterPackageImport()
            self.state = 732 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 731
                self.ruleFilterPackageMember()
                self.state = 734 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==105):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFilterPackageImportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFilterPackageImport

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFilterPackageImport2Context(RuleFilterPackageImportContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFilterPackageImportContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFilterPackageNamespaceImport(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFilterPackageNamespaceImportContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFilterPackageImport2" ):
                listener.enterRuleFilterPackageImport2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFilterPackageImport2" ):
                listener.exitRuleFilterPackageImport2(self)


    class RuleFilterPackageImport1Context(RuleFilterPackageImportContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFilterPackageImportContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFilterPackageMembershipImport(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFilterPackageMembershipImportContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFilterPackageImport1" ):
                listener.enterRuleFilterPackageImport1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFilterPackageImport1" ):
                listener.exitRuleFilterPackageImport1(self)



    def ruleFilterPackageImport(self):

        localctx = KerMLv2Parser.RuleFilterPackageImportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_ruleFilterPackageImport)
        try:
            self.state = 738
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleFilterPackageImport1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 736
                self.ruleFilterPackageMembershipImport()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleFilterPackageImport2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 737
                self.ruleFilterPackageNamespaceImport()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFilterPackageMembershipImportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleImportedMembership(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImportedMembershipContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFilterPackageMembershipImport

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFilterPackageMembershipImport" ):
                listener.enterRuleFilterPackageMembershipImport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFilterPackageMembershipImport" ):
                listener.exitRuleFilterPackageMembershipImport(self)




    def ruleFilterPackageMembershipImport(self):

        localctx = KerMLv2Parser.RuleFilterPackageMembershipImportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_ruleFilterPackageMembershipImport)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 740
            self.ruleImportedMembership()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFilterPackageNamespaceImportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleImportedNamespace(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImportedNamespaceContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFilterPackageNamespaceImport

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFilterPackageNamespaceImport" ):
                listener.enterRuleFilterPackageNamespaceImport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFilterPackageNamespaceImport" ):
                listener.exitRuleFilterPackageNamespaceImport(self)




    def ruleFilterPackageNamespaceImport(self):

        localctx = KerMLv2Parser.RuleFilterPackageNamespaceImportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_ruleFilterPackageNamespaceImport)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 742
            self.ruleImportedNamespace()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFilterPackageMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFilterPackageMemberVisibility(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFilterPackageMemberVisibilityContext,0)


        def ruleOwnedExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedExpressionContext,0)


        def RSQUARE(self):
            return self.getToken(KerMLv2Parser.RSQUARE, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFilterPackageMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFilterPackageMember" ):
                listener.enterRuleFilterPackageMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFilterPackageMember" ):
                listener.exitRuleFilterPackageMember(self)




    def ruleFilterPackageMember(self):

        localctx = KerMLv2Parser.RuleFilterPackageMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_ruleFilterPackageMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 744
            self.ruleFilterPackageMemberVisibility()
            self.state = 745
            self.ruleOwnedExpression()
            self.state = 746
            self.match(KerMLv2Parser.RSQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMemberElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMemberElement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleMemberElement1Context(RuleMemberElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMemberElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleAnnotatingElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleAnnotatingElementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMemberElement1" ):
                listener.enterRuleMemberElement1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMemberElement1" ):
                listener.exitRuleMemberElement1(self)


    class RuleMemberElement2Context(RuleMemberElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMemberElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleNonFeatureElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNonFeatureElementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMemberElement2" ):
                listener.enterRuleMemberElement2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMemberElement2" ):
                listener.exitRuleMemberElement2(self)



    def ruleMemberElement(self):

        localctx = KerMLv2Parser.RuleMemberElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_ruleMemberElement)
        try:
            self.state = 750
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleMemberElement1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 748
                self.ruleAnnotatingElement()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleMemberElement2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 749
                self.ruleNonFeatureElement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNonFeatureElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNonFeatureElement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleNonFeatureElement20Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureTyping(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureTypingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement20" ):
                listener.enterRuleNonFeatureElement20(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement20" ):
                listener.exitRuleNonFeatureElement20(self)


    class RuleNonFeatureElement22Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleDisjoining(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleDisjoiningContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement22" ):
                listener.enterRuleNonFeatureElement22(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement22" ):
                listener.exitRuleNonFeatureElement22(self)


    class RuleNonFeatureElement21Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleSubclassification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSubclassificationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement21" ):
                listener.enterRuleNonFeatureElement21(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement21" ):
                listener.exitRuleNonFeatureElement21(self)


    class RuleNonFeatureElement7Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleClassifier(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement7" ):
                listener.enterRuleNonFeatureElement7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement7" ):
                listener.exitRuleNonFeatureElement7(self)


    class RuleNonFeatureElement8Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleClass(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement8" ):
                listener.enterRuleNonFeatureElement8(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement8" ):
                listener.exitRuleNonFeatureElement8(self)


    class RuleNonFeatureElement9Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleStructure(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleStructureContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement9" ):
                listener.enterRuleNonFeatureElement9(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement9" ):
                listener.exitRuleNonFeatureElement9(self)


    class RuleNonFeatureElement24Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleSubsetting(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSubsettingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement24" ):
                listener.enterRuleNonFeatureElement24(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement24" ):
                listener.exitRuleNonFeatureElement24(self)


    class RuleNonFeatureElement23Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureInverting(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureInvertingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement23" ):
                listener.enterRuleNonFeatureElement23(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement23" ):
                listener.exitRuleNonFeatureElement23(self)


    class RuleNonFeatureElement26Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleTypeFeaturing(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeFeaturingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement26" ):
                listener.enterRuleNonFeatureElement26(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement26" ):
                listener.exitRuleNonFeatureElement26(self)


    class RuleNonFeatureElement25Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleRedefinition(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRedefinitionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement25" ):
                listener.enterRuleNonFeatureElement25(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement25" ):
                listener.exitRuleNonFeatureElement25(self)


    class RuleNonFeatureElement3Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def rulePackage(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePackageContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement3" ):
                listener.enterRuleNonFeatureElement3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement3" ):
                listener.exitRuleNonFeatureElement3(self)


    class RuleNonFeatureElement4Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleLibraryPackage(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleLibraryPackageContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement4" ):
                listener.enterRuleNonFeatureElement4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement4" ):
                listener.exitRuleNonFeatureElement4(self)


    class RuleNonFeatureElement5Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMultiplicity(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicityContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement5" ):
                listener.enterRuleNonFeatureElement5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement5" ):
                listener.exitRuleNonFeatureElement5(self)


    class RuleNonFeatureElement6Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleType(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement6" ):
                listener.enterRuleNonFeatureElement6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement6" ):
                listener.exitRuleNonFeatureElement6(self)


    class RuleNonFeatureElement1Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleDependency(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleDependencyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement1" ):
                listener.enterRuleNonFeatureElement1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement1" ):
                listener.exitRuleNonFeatureElement1(self)


    class RuleNonFeatureElement2Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleNamespace(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNamespaceContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement2" ):
                listener.enterRuleNonFeatureElement2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement2" ):
                listener.exitRuleNonFeatureElement2(self)


    class RuleNonFeatureElement11Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleDataType(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleDataTypeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement11" ):
                listener.enterRuleNonFeatureElement11(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement11" ):
                listener.exitRuleNonFeatureElement11(self)


    class RuleNonFeatureElement10Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMetaclass(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetaclassContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement10" ):
                listener.enterRuleNonFeatureElement10(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement10" ):
                listener.exitRuleNonFeatureElement10(self)


    class RuleNonFeatureElement17Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def rulePredicate(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePredicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement17" ):
                listener.enterRuleNonFeatureElement17(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement17" ):
                listener.exitRuleNonFeatureElement17(self)


    class RuleNonFeatureElement16Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFunction(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement16" ):
                listener.enterRuleNonFeatureElement16(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement16" ):
                listener.exitRuleNonFeatureElement16(self)


    class RuleNonFeatureElement19Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleConjugation(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleConjugationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement19" ):
                listener.enterRuleNonFeatureElement19(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement19" ):
                listener.exitRuleNonFeatureElement19(self)


    class RuleNonFeatureElement18Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleSpecialization(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSpecializationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement18" ):
                listener.enterRuleNonFeatureElement18(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement18" ):
                listener.exitRuleNonFeatureElement18(self)


    class RuleNonFeatureElement13Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleAssociationStructure(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleAssociationStructureContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement13" ):
                listener.enterRuleNonFeatureElement13(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement13" ):
                listener.exitRuleNonFeatureElement13(self)


    class RuleNonFeatureElement12Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleAssociation(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleAssociationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement12" ):
                listener.enterRuleNonFeatureElement12(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement12" ):
                listener.exitRuleNonFeatureElement12(self)


    class RuleNonFeatureElement15Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleBehavior(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleBehaviorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement15" ):
                listener.enterRuleNonFeatureElement15(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement15" ):
                listener.exitRuleNonFeatureElement15(self)


    class RuleNonFeatureElement14Context(RuleNonFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNonFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleInteraction(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleInteractionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNonFeatureElement14" ):
                listener.enterRuleNonFeatureElement14(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNonFeatureElement14" ):
                listener.exitRuleNonFeatureElement14(self)



    def ruleNonFeatureElement(self):

        localctx = KerMLv2Parser.RuleNonFeatureElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_ruleNonFeatureElement)
        try:
            self.state = 778
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleNonFeatureElement1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 752
                self.ruleDependency()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleNonFeatureElement2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 753
                self.ruleNamespace()
                pass

            elif la_ == 3:
                localctx = KerMLv2Parser.RuleNonFeatureElement3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 754
                self.rulePackage()
                pass

            elif la_ == 4:
                localctx = KerMLv2Parser.RuleNonFeatureElement4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 755
                self.ruleLibraryPackage()
                pass

            elif la_ == 5:
                localctx = KerMLv2Parser.RuleNonFeatureElement5Context(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 756
                self.ruleMultiplicity()
                pass

            elif la_ == 6:
                localctx = KerMLv2Parser.RuleNonFeatureElement6Context(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 757
                self.ruleType()
                pass

            elif la_ == 7:
                localctx = KerMLv2Parser.RuleNonFeatureElement7Context(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 758
                self.ruleClassifier()
                pass

            elif la_ == 8:
                localctx = KerMLv2Parser.RuleNonFeatureElement8Context(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 759
                self.ruleClass()
                pass

            elif la_ == 9:
                localctx = KerMLv2Parser.RuleNonFeatureElement9Context(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 760
                self.ruleStructure()
                pass

            elif la_ == 10:
                localctx = KerMLv2Parser.RuleNonFeatureElement10Context(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 761
                self.ruleMetaclass()
                pass

            elif la_ == 11:
                localctx = KerMLv2Parser.RuleNonFeatureElement11Context(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 762
                self.ruleDataType()
                pass

            elif la_ == 12:
                localctx = KerMLv2Parser.RuleNonFeatureElement12Context(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 763
                self.ruleAssociation()
                pass

            elif la_ == 13:
                localctx = KerMLv2Parser.RuleNonFeatureElement13Context(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 764
                self.ruleAssociationStructure()
                pass

            elif la_ == 14:
                localctx = KerMLv2Parser.RuleNonFeatureElement14Context(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 765
                self.ruleInteraction()
                pass

            elif la_ == 15:
                localctx = KerMLv2Parser.RuleNonFeatureElement15Context(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 766
                self.ruleBehavior()
                pass

            elif la_ == 16:
                localctx = KerMLv2Parser.RuleNonFeatureElement16Context(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 767
                self.ruleFunction()
                pass

            elif la_ == 17:
                localctx = KerMLv2Parser.RuleNonFeatureElement17Context(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 768
                self.rulePredicate()
                pass

            elif la_ == 18:
                localctx = KerMLv2Parser.RuleNonFeatureElement18Context(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 769
                self.ruleSpecialization()
                pass

            elif la_ == 19:
                localctx = KerMLv2Parser.RuleNonFeatureElement19Context(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 770
                self.ruleConjugation()
                pass

            elif la_ == 20:
                localctx = KerMLv2Parser.RuleNonFeatureElement20Context(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 771
                self.ruleFeatureTyping()
                pass

            elif la_ == 21:
                localctx = KerMLv2Parser.RuleNonFeatureElement21Context(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 772
                self.ruleSubclassification()
                pass

            elif la_ == 22:
                localctx = KerMLv2Parser.RuleNonFeatureElement22Context(self, localctx)
                self.enterOuterAlt(localctx, 22)
                self.state = 773
                self.ruleDisjoining()
                pass

            elif la_ == 23:
                localctx = KerMLv2Parser.RuleNonFeatureElement23Context(self, localctx)
                self.enterOuterAlt(localctx, 23)
                self.state = 774
                self.ruleFeatureInverting()
                pass

            elif la_ == 24:
                localctx = KerMLv2Parser.RuleNonFeatureElement24Context(self, localctx)
                self.enterOuterAlt(localctx, 24)
                self.state = 775
                self.ruleSubsetting()
                pass

            elif la_ == 25:
                localctx = KerMLv2Parser.RuleNonFeatureElement25Context(self, localctx)
                self.enterOuterAlt(localctx, 25)
                self.state = 776
                self.ruleRedefinition()
                pass

            elif la_ == 26:
                localctx = KerMLv2Parser.RuleNonFeatureElement26Context(self, localctx)
                self.enterOuterAlt(localctx, 26)
                self.state = 777
                self.ruleTypeFeaturing()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureElement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFeatureElement1Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeature(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement1" ):
                listener.enterRuleFeatureElement1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement1" ):
                listener.exitRuleFeatureElement1(self)


    class RuleFeatureElement10Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleSuccessionItemFlow(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSuccessionItemFlowContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement10" ):
                listener.enterRuleFeatureElement10(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement10" ):
                listener.exitRuleFeatureElement10(self)


    class RuleFeatureElement5Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleInvariant(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleInvariantContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement5" ):
                listener.enterRuleFeatureElement5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement5" ):
                listener.exitRuleFeatureElement5(self)


    class RuleFeatureElement4Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleBooleanExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleBooleanExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement4" ):
                listener.enterRuleFeatureElement4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement4" ):
                listener.exitRuleFeatureElement4(self)


    class RuleFeatureElement3Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement3" ):
                listener.enterRuleFeatureElement3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement3" ):
                listener.exitRuleFeatureElement3(self)


    class RuleFeatureElement2Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleStep(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleStepContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement2" ):
                listener.enterRuleFeatureElement2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement2" ):
                listener.exitRuleFeatureElement2(self)


    class RuleFeatureElement9Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleItemFlow(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement9" ):
                listener.enterRuleFeatureElement9(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement9" ):
                listener.exitRuleFeatureElement9(self)


    class RuleFeatureElement8Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleSuccession(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSuccessionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement8" ):
                listener.enterRuleFeatureElement8(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement8" ):
                listener.exitRuleFeatureElement8(self)


    class RuleFeatureElement7Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleBindingConnector(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleBindingConnectorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement7" ):
                listener.enterRuleFeatureElement7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement7" ):
                listener.exitRuleFeatureElement7(self)


    class RuleFeatureElement6Context(RuleFeatureElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleConnector(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleConnectorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureElement6" ):
                listener.enterRuleFeatureElement6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureElement6" ):
                listener.exitRuleFeatureElement6(self)



    def ruleFeatureElement(self):

        localctx = KerMLv2Parser.RuleFeatureElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_ruleFeatureElement)
        try:
            self.state = 790
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleFeatureElement1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 780
                self.ruleFeature()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleFeatureElement2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 781
                self.ruleStep()
                pass

            elif la_ == 3:
                localctx = KerMLv2Parser.RuleFeatureElement3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 782
                self.ruleExpression()
                pass

            elif la_ == 4:
                localctx = KerMLv2Parser.RuleFeatureElement4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 783
                self.ruleBooleanExpression()
                pass

            elif la_ == 5:
                localctx = KerMLv2Parser.RuleFeatureElement5Context(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 784
                self.ruleInvariant()
                pass

            elif la_ == 6:
                localctx = KerMLv2Parser.RuleFeatureElement6Context(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 785
                self.ruleConnector()
                pass

            elif la_ == 7:
                localctx = KerMLv2Parser.RuleFeatureElement7Context(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 786
                self.ruleBindingConnector()
                pass

            elif la_ == 8:
                localctx = KerMLv2Parser.RuleFeatureElement8Context(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 787
                self.ruleSuccession()
                pass

            elif la_ == 9:
                localctx = KerMLv2Parser.RuleFeatureElement9Context(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 788
                self.ruleItemFlow()
                pass

            elif la_ == 10:
                localctx = KerMLv2Parser.RuleFeatureElement10Context(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 789
                self.ruleSuccessionItemFlow()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulePackageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rulePackageDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePackageDeclarationContext,0)


        def rulePackageBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePackageBodyContext,0)


        def rulePrefixMetadataMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RulePrefixMetadataMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataMemberContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_rulePackage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePackage" ):
                listener.enterRulePackage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePackage" ):
                listener.exitRulePackage(self)




    def rulePackage(self):

        localctx = KerMLv2Parser.RulePackageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_rulePackage)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 795
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==122:
                self.state = 792
                self.rulePrefixMetadataMember()
                self.state = 797
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 798
            self.rulePackageDeclaration()
            self.state = 799
            self.rulePackageBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleLibraryPackageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_LIBRARY(self):
            return self.getToken(KerMLv2Parser.K_LIBRARY, 0)

        def rulePackageDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePackageDeclarationContext,0)


        def rulePackageBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePackageBodyContext,0)


        def K_STANDARD(self):
            return self.getToken(KerMLv2Parser.K_STANDARD, 0)

        def rulePrefixMetadataMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RulePrefixMetadataMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataMemberContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleLibraryPackage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLibraryPackage" ):
                listener.enterRuleLibraryPackage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLibraryPackage" ):
                listener.exitRuleLibraryPackage(self)




    def ruleLibraryPackage(self):

        localctx = KerMLv2Parser.RuleLibraryPackageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_ruleLibraryPackage)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 802
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 801
                self.match(KerMLv2Parser.K_STANDARD)


            self.state = 804
            self.match(KerMLv2Parser.K_LIBRARY)
            self.state = 808
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==122:
                self.state = 805
                self.rulePrefixMetadataMember()
                self.state = 810
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 811
            self.rulePackageDeclaration()
            self.state = 812
            self.rulePackageBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulePackageDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PACKAGE(self):
            return self.getToken(KerMLv2Parser.K_PACKAGE, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_rulePackageDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePackageDeclaration" ):
                listener.enterRulePackageDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePackageDeclaration" ):
                listener.exitRulePackageDeclaration(self)




    def rulePackageDeclaration(self):

        localctx = KerMLv2Parser.RulePackageDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_rulePackageDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 814
            self.match(KerMLv2Parser.K_PACKAGE)
            self.state = 816
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                self.state = 815
                self.ruleIdentification()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulePackageBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_rulePackageBody

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RulePackageBody2Context(RulePackageBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RulePackageBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACE(self):
            return self.getToken(KerMLv2Parser.LBRACE, 0)
        def RBRACE(self):
            return self.getToken(KerMLv2Parser.RBRACE, 0)
        def ruleNamespaceMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNamespaceMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNamespaceMemberContext,i)

        def ruleElementFilterMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleElementFilterMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleElementFilterMemberContext,i)

        def ruleAliasMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAliasMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAliasMemberContext,i)

        def ruleImport(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleImportContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleImportContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePackageBody2" ):
                listener.enterRulePackageBody2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePackageBody2" ):
                listener.exitRulePackageBody2(self)


    class RulePackageBody1Context(RulePackageBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RulePackageBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_SEMI(self):
            return self.getToken(KerMLv2Parser.OP_SEMI, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePackageBody1" ):
                listener.enterRulePackageBody1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePackageBody1" ):
                listener.exitRulePackageBody1(self)



    def rulePackageBody(self):

        localctx = KerMLv2Parser.RulePackageBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_rulePackageBody)
        self._la = 0 # Token type
        try:
            self.state = 830
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [108]:
                localctx = KerMLv2Parser.RulePackageBody1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 818
                self.match(KerMLv2Parser.OP_SEMI)
                pass
            elif token in [102]:
                localctx = KerMLv2Parser.RulePackageBody2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 819
                self.match(KerMLv2Parser.LBRACE)
                self.state = 826
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & -144178960004026414) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 882144912399912819) != 0) or ((((_la - 144)) & ~0x3f) == 0 and ((1 << (_la - 144)) & 11) != 0):
                    self.state = 824
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                    if la_ == 1:
                        self.state = 820
                        self.ruleNamespaceMember()
                        pass

                    elif la_ == 2:
                        self.state = 821
                        self.ruleElementFilterMember()
                        pass

                    elif la_ == 3:
                        self.state = 822
                        self.ruleAliasMember()
                        pass

                    elif la_ == 4:
                        self.state = 823
                        self.ruleImport()
                        pass


                    self.state = 828
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 829
                self.match(KerMLv2Parser.RBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleElementFilterMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMemberPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMemberPrefixContext,0)


        def K_FILTER(self):
            return self.getToken(KerMLv2Parser.K_FILTER, 0)

        def ruleOwnedExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedExpressionContext,0)


        def OP_SEMI(self):
            return self.getToken(KerMLv2Parser.OP_SEMI, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleElementFilterMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleElementFilterMember" ):
                listener.enterRuleElementFilterMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleElementFilterMember" ):
                listener.exitRuleElementFilterMember(self)




    def ruleElementFilterMember(self):

        localctx = KerMLv2Parser.RuleElementFilterMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_ruleElementFilterMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 832
            self.ruleMemberPrefix()
            self.state = 833
            self.match(KerMLv2Parser.K_FILTER)
            self.state = 834
            self.ruleOwnedExpression()
            self.state = 835
            self.match(KerMLv2Parser.OP_SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypePrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ABSTRACT(self):
            return self.getToken(KerMLv2Parser.K_ABSTRACT, 0)

        def rulePrefixMetadataMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RulePrefixMetadataMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataMemberContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypePrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypePrefix" ):
                listener.enterRuleTypePrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypePrefix" ):
                listener.exitRuleTypePrefix(self)




    def ruleTypePrefix(self):

        localctx = KerMLv2Parser.RuleTypePrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_ruleTypePrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 838
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 837
                self.match(KerMLv2Parser.K_ABSTRACT)


            self.state = 843
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==122:
                self.state = 840
                self.rulePrefixMetadataMember()
                self.state = 845
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_TYPE(self):
            return self.getToken(KerMLv2Parser.K_TYPE, 0)

        def ruleTypeDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleType" ):
                listener.enterRuleType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleType" ):
                listener.exitRuleType(self)




    def ruleType(self):

        localctx = KerMLv2Parser.RuleTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_ruleType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 846
            self.ruleTypePrefix()
            self.state = 847
            self.match(KerMLv2Parser.K_TYPE)
            self.state = 848
            self.ruleTypeDeclaration()
            self.state = 849
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleSpecializationPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSpecializationPartContext,0)


        def ruleConjugationPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleConjugationPartContext,0)


        def K_ALL(self):
            return self.getToken(KerMLv2Parser.K_ALL, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def ruleOwnedMultiplicity(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedMultiplicityContext,0)


        def ruleTypeRelationshipPart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleTypeRelationshipPartContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleTypeRelationshipPartContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypeDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeDeclaration" ):
                listener.enterRuleTypeDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeDeclaration" ):
                listener.exitRuleTypeDeclaration(self)




    def ruleTypeDeclaration(self):

        localctx = KerMLv2Parser.RuleTypeDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_ruleTypeDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 852
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 851
                self.match(KerMLv2Parser.K_ALL)


            self.state = 855
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                self.state = 854
                self.ruleIdentification()


            self.state = 858
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==105:
                self.state = 857
                self.ruleOwnedMultiplicity()


            self.state = 862
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 113]:
                self.state = 860
                self.ruleSpecializationPart()
                pass
            elif token in [22, 114]:
                self.state = 861
                self.ruleConjugationPart()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 867
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 125829120) != 0):
                self.state = 864
                self.ruleTypeRelationshipPart()
                self.state = 869
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSpecializationPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedSpecialization(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedSpecializationContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedSpecializationContext,i)


        def OP_COLON_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_RANGLE, 0)

        def K_SPECIALIZES(self):
            return self.getToken(KerMLv2Parser.K_SPECIALIZES, 0)

        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSpecializationPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSpecializationPart" ):
                listener.enterRuleSpecializationPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSpecializationPart" ):
                listener.exitRuleSpecializationPart(self)




    def ruleSpecializationPart(self):

        localctx = KerMLv2Parser.RuleSpecializationPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_ruleSpecializationPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 870
            _la = self._input.LA(1)
            if not(_la==21 or _la==113):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 871
            self.ruleOwnedSpecialization()
            self.state = 876
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 872
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 873
                self.ruleOwnedSpecialization()
                self.state = 878
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConjugationPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedConjugation(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedConjugationContext,0)


        def OP_TILDE(self):
            return self.getToken(KerMLv2Parser.OP_TILDE, 0)

        def K_CONJUGATES(self):
            return self.getToken(KerMLv2Parser.K_CONJUGATES, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConjugationPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConjugationPart" ):
                listener.enterRuleConjugationPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConjugationPart" ):
                listener.exitRuleConjugationPart(self)




    def ruleConjugationPart(self):

        localctx = KerMLv2Parser.RuleConjugationPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_ruleConjugationPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 879
            _la = self._input.LA(1)
            if not(_la==22 or _la==114):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 880
            self.ruleOwnedConjugation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeRelationshipPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypeRelationshipPart

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleTypeRelationshipPart2Context(RuleTypeRelationshipPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleTypeRelationshipPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleUnioningPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleUnioningPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeRelationshipPart2" ):
                listener.enterRuleTypeRelationshipPart2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeRelationshipPart2" ):
                listener.exitRuleTypeRelationshipPart2(self)


    class RuleTypeRelationshipPart1Context(RuleTypeRelationshipPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleTypeRelationshipPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleDisjoiningPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleDisjoiningPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeRelationshipPart1" ):
                listener.enterRuleTypeRelationshipPart1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeRelationshipPart1" ):
                listener.exitRuleTypeRelationshipPart1(self)


    class RuleTypeRelationshipPart4Context(RuleTypeRelationshipPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleTypeRelationshipPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleDifferencingPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleDifferencingPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeRelationshipPart4" ):
                listener.enterRuleTypeRelationshipPart4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeRelationshipPart4" ):
                listener.exitRuleTypeRelationshipPart4(self)


    class RuleTypeRelationshipPart3Context(RuleTypeRelationshipPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleTypeRelationshipPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleIntersectingPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIntersectingPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeRelationshipPart3" ):
                listener.enterRuleTypeRelationshipPart3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeRelationshipPart3" ):
                listener.exitRuleTypeRelationshipPart3(self)



    def ruleTypeRelationshipPart(self):

        localctx = KerMLv2Parser.RuleTypeRelationshipPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_ruleTypeRelationshipPart)
        try:
            self.state = 886
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [23]:
                localctx = KerMLv2Parser.RuleTypeRelationshipPart1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 882
                self.ruleDisjoiningPart()
                pass
            elif token in [24]:
                localctx = KerMLv2Parser.RuleTypeRelationshipPart2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 883
                self.ruleUnioningPart()
                pass
            elif token in [25]:
                localctx = KerMLv2Parser.RuleTypeRelationshipPart3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 884
                self.ruleIntersectingPart()
                pass
            elif token in [26]:
                localctx = KerMLv2Parser.RuleTypeRelationshipPart4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 885
                self.ruleDifferencingPart()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDisjoiningPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DISJOINT(self):
            return self.getToken(KerMLv2Parser.K_DISJOINT, 0)

        def K_FROM(self):
            return self.getToken(KerMLv2Parser.K_FROM, 0)

        def ruleOwnedDisjoining(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedDisjoiningContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedDisjoiningContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleDisjoiningPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDisjoiningPart" ):
                listener.enterRuleDisjoiningPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDisjoiningPart" ):
                listener.exitRuleDisjoiningPart(self)




    def ruleDisjoiningPart(self):

        localctx = KerMLv2Parser.RuleDisjoiningPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_ruleDisjoiningPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 888
            self.match(KerMLv2Parser.K_DISJOINT)
            self.state = 889
            self.match(KerMLv2Parser.K_FROM)
            self.state = 890
            self.ruleOwnedDisjoining()
            self.state = 895
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 891
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 892
                self.ruleOwnedDisjoining()
                self.state = 897
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleUnioningPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_UNIONS(self):
            return self.getToken(KerMLv2Parser.K_UNIONS, 0)

        def ruleUnioning(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleUnioningContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleUnioningContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleUnioningPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleUnioningPart" ):
                listener.enterRuleUnioningPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleUnioningPart" ):
                listener.exitRuleUnioningPart(self)




    def ruleUnioningPart(self):

        localctx = KerMLv2Parser.RuleUnioningPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_ruleUnioningPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 898
            self.match(KerMLv2Parser.K_UNIONS)
            self.state = 899
            self.ruleUnioning()
            self.state = 904
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 900
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 901
                self.ruleUnioning()
                self.state = 906
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleIntersectingPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_INTERSECTS(self):
            return self.getToken(KerMLv2Parser.K_INTERSECTS, 0)

        def ruleIntersecting(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleIntersectingContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleIntersectingContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleIntersectingPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleIntersectingPart" ):
                listener.enterRuleIntersectingPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleIntersectingPart" ):
                listener.exitRuleIntersectingPart(self)




    def ruleIntersectingPart(self):

        localctx = KerMLv2Parser.RuleIntersectingPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_ruleIntersectingPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 907
            self.match(KerMLv2Parser.K_INTERSECTS)
            self.state = 908
            self.ruleIntersecting()
            self.state = 913
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 909
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 910
                self.ruleIntersecting()
                self.state = 915
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDifferencingPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DIFFERENCES(self):
            return self.getToken(KerMLv2Parser.K_DIFFERENCES, 0)

        def ruleDifferencing(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleDifferencingContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleDifferencingContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleDifferencingPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDifferencingPart" ):
                listener.enterRuleDifferencingPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDifferencingPart" ):
                listener.exitRuleDifferencingPart(self)




    def ruleDifferencingPart(self):

        localctx = KerMLv2Parser.RuleDifferencingPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_ruleDifferencingPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 916
            self.match(KerMLv2Parser.K_DIFFERENCES)
            self.state = 917
            self.ruleDifferencing()
            self.state = 922
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 918
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 919
                self.ruleDifferencing()
                self.state = 924
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypeBody

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleTypeBody2Context(RuleTypeBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleTypeBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACE(self):
            return self.getToken(KerMLv2Parser.LBRACE, 0)
        def RBRACE(self):
            return self.getToken(KerMLv2Parser.RBRACE, 0)
        def ruleNonFeatureMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNonFeatureMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNonFeatureMemberContext,i)

        def ruleFeatureMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFeatureMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureMemberContext,i)

        def ruleAliasMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAliasMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAliasMemberContext,i)

        def ruleImport(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleImportContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleImportContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeBody2" ):
                listener.enterRuleTypeBody2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeBody2" ):
                listener.exitRuleTypeBody2(self)


    class RuleTypeBody1Context(RuleTypeBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleTypeBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_SEMI(self):
            return self.getToken(KerMLv2Parser.OP_SEMI, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeBody1" ):
                listener.enterRuleTypeBody1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeBody1" ):
                listener.exitRuleTypeBody1(self)



    def ruleTypeBody(self):

        localctx = KerMLv2Parser.RuleTypeBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_ruleTypeBody)
        self._la = 0 # Token type
        try:
            self.state = 937
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [108]:
                localctx = KerMLv2Parser.RuleTypeBody1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 925
                self.match(KerMLv2Parser.OP_SEMI)
                pass
            elif token in [102]:
                localctx = KerMLv2Parser.RuleTypeBody2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 926
                self.match(KerMLv2Parser.LBRACE)
                self.state = 933
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & -144178959870070830) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 882144912399912819) != 0) or ((((_la - 144)) & ~0x3f) == 0 and ((1 << (_la - 144)) & 11) != 0):
                    self.state = 931
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
                    if la_ == 1:
                        self.state = 927
                        self.ruleNonFeatureMember()
                        pass

                    elif la_ == 2:
                        self.state = 928
                        self.ruleFeatureMember()
                        pass

                    elif la_ == 3:
                        self.state = 929
                        self.ruleAliasMember()
                        pass

                    elif la_ == 4:
                        self.state = 930
                        self.ruleImport()
                        pass


                    self.state = 935
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 936
                self.match(KerMLv2Parser.RBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureMember

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFeatureMember2Context(RuleFeatureMemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureMemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureMember2" ):
                listener.enterRuleFeatureMember2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureMember2" ):
                listener.exitRuleFeatureMember2(self)


    class RuleFeatureMember1Context(RuleFeatureMemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureMemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleTypeFeatureMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeFeatureMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureMember1" ):
                listener.enterRuleFeatureMember1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureMember1" ):
                listener.exitRuleFeatureMember1(self)



    def ruleFeatureMember(self):

        localctx = KerMLv2Parser.RuleFeatureMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_ruleFeatureMember)
        try:
            self.state = 941
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleFeatureMember1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 939
                self.ruleTypeFeatureMember()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleFeatureMember2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 940
                self.ruleOwnedFeatureMember()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeFeatureMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMemberPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMemberPrefixContext,0)


        def K_MEMBER(self):
            return self.getToken(KerMLv2Parser.K_MEMBER, 0)

        def ruleFeatureElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureElementContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypeFeatureMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeFeatureMember" ):
                listener.enterRuleTypeFeatureMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeFeatureMember" ):
                listener.exitRuleTypeFeatureMember(self)




    def ruleTypeFeatureMember(self):

        localctx = KerMLv2Parser.RuleTypeFeatureMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_ruleTypeFeatureMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 943
            self.ruleMemberPrefix()
            self.state = 944
            self.match(KerMLv2Parser.K_MEMBER)
            self.state = 945
            self.ruleFeatureElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedFeatureMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMemberPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMemberPrefixContext,0)


        def ruleFeatureElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureElementContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedFeatureMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedFeatureMember" ):
                listener.enterRuleOwnedFeatureMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedFeatureMember" ):
                listener.exitRuleOwnedFeatureMember(self)




    def ruleOwnedFeatureMember(self):

        localctx = KerMLv2Parser.RuleOwnedFeatureMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_ruleOwnedFeatureMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947
            self.ruleMemberPrefix()
            self.state = 948
            self.ruleFeatureElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSpecializationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SUBTYPE(self):
            return self.getToken(KerMLv2Parser.K_SUBTYPE, 0)

        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def OP_COLON_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_RANGLE, 0)

        def K_SPECIALIZES(self):
            return self.getToken(KerMLv2Parser.K_SPECIALIZES, 0)

        def ruleQualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleQualifiedNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,i)


        def ruleOwnedFeatureChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedFeatureChainContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,i)


        def K_SPECIALIZATION(self):
            return self.getToken(KerMLv2Parser.K_SPECIALIZATION, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSpecialization

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSpecialization" ):
                listener.enterRuleSpecialization(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSpecialization" ):
                listener.exitRuleSpecialization(self)




    def ruleSpecialization(self):

        localctx = KerMLv2Parser.RuleSpecializationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_ruleSpecialization)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 954
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 950
                self.match(KerMLv2Parser.K_SPECIALIZATION)
                self.state = 952
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 951
                    self.ruleIdentification()




            self.state = 956
            self.match(KerMLv2Parser.K_SUBTYPE)
            self.state = 959
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.state = 957
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 958
                self.ruleOwnedFeatureChain()
                pass


            self.state = 961
            _la = self._input.LA(1)
            if not(_la==21 or _la==113):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 964
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 962
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 963
                self.ruleOwnedFeatureChain()
                pass


            self.state = 966
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedSpecializationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedSpecialization

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleOwnedSpecialization1Context(RuleOwnedSpecializationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedSpecializationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedSpecialization1" ):
                listener.enterRuleOwnedSpecialization1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedSpecialization1" ):
                listener.exitRuleOwnedSpecialization1(self)


    class RuleOwnedSpecialization2Context(RuleOwnedSpecializationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedSpecializationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedSpecialization2" ):
                listener.enterRuleOwnedSpecialization2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedSpecialization2" ):
                listener.exitRuleOwnedSpecialization2(self)



    def ruleOwnedSpecialization(self):

        localctx = KerMLv2Parser.RuleOwnedSpecializationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_ruleOwnedSpecialization)
        try:
            self.state = 970
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleOwnedSpecialization1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 968
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleOwnedSpecialization2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 969
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConjugationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_CONJUGATE(self):
            return self.getToken(KerMLv2Parser.K_CONJUGATE, 0)

        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def OP_TILDE(self):
            return self.getToken(KerMLv2Parser.OP_TILDE, 0)

        def K_CONJUGATES(self):
            return self.getToken(KerMLv2Parser.K_CONJUGATES, 0)

        def ruleQualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleQualifiedNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,i)


        def ruleOwnedFeatureChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedFeatureChainContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,i)


        def K_CONJUGATION(self):
            return self.getToken(KerMLv2Parser.K_CONJUGATION, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConjugation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConjugation" ):
                listener.enterRuleConjugation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConjugation" ):
                listener.exitRuleConjugation(self)




    def ruleConjugation(self):

        localctx = KerMLv2Parser.RuleConjugationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_ruleConjugation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 976
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 972
                self.match(KerMLv2Parser.K_CONJUGATION)
                self.state = 974
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 973
                    self.ruleIdentification()




            self.state = 978
            self.match(KerMLv2Parser.K_CONJUGATE)
            self.state = 981
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
            if la_ == 1:
                self.state = 979
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 980
                self.ruleOwnedFeatureChain()
                pass


            self.state = 983
            _la = self._input.LA(1)
            if not(_la==22 or _la==114):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 986
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                self.state = 984
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 985
                self.ruleOwnedFeatureChain()
                pass


            self.state = 988
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedConjugationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedConjugation

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleOwnedConjugation2Context(RuleOwnedConjugationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedConjugationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedConjugation2" ):
                listener.enterRuleOwnedConjugation2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedConjugation2" ):
                listener.exitRuleOwnedConjugation2(self)


    class RuleOwnedConjugation1Context(RuleOwnedConjugationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedConjugationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedConjugation1" ):
                listener.enterRuleOwnedConjugation1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedConjugation1" ):
                listener.exitRuleOwnedConjugation1(self)



    def ruleOwnedConjugation(self):

        localctx = KerMLv2Parser.RuleOwnedConjugationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_ruleOwnedConjugation)
        try:
            self.state = 992
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleOwnedConjugation1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 990
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleOwnedConjugation2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 991
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDisjoiningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DISJOINT(self):
            return self.getToken(KerMLv2Parser.K_DISJOINT, 0)

        def K_FROM(self):
            return self.getToken(KerMLv2Parser.K_FROM, 0)

        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def ruleQualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleQualifiedNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,i)


        def ruleOwnedFeatureChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedFeatureChainContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,i)


        def K_DISJOINING(self):
            return self.getToken(KerMLv2Parser.K_DISJOINING, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleDisjoining

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDisjoining" ):
                listener.enterRuleDisjoining(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDisjoining" ):
                listener.exitRuleDisjoining(self)




    def ruleDisjoining(self):

        localctx = KerMLv2Parser.RuleDisjoiningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_ruleDisjoining)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 998
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 994
                self.match(KerMLv2Parser.K_DISJOINING)
                self.state = 996
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 995
                    self.ruleIdentification()




            self.state = 1000
            self.match(KerMLv2Parser.K_DISJOINT)
            self.state = 1003
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                self.state = 1001
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 1002
                self.ruleOwnedFeatureChain()
                pass


            self.state = 1005
            self.match(KerMLv2Parser.K_FROM)
            self.state = 1008
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
            if la_ == 1:
                self.state = 1006
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 1007
                self.ruleOwnedFeatureChain()
                pass


            self.state = 1010
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedDisjoiningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedDisjoining

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleOwnedDisjoining1Context(RuleOwnedDisjoiningContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedDisjoiningContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedDisjoining1" ):
                listener.enterRuleOwnedDisjoining1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedDisjoining1" ):
                listener.exitRuleOwnedDisjoining1(self)


    class RuleOwnedDisjoining2Context(RuleOwnedDisjoiningContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedDisjoiningContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedDisjoining2" ):
                listener.enterRuleOwnedDisjoining2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedDisjoining2" ):
                listener.exitRuleOwnedDisjoining2(self)



    def ruleOwnedDisjoining(self):

        localctx = KerMLv2Parser.RuleOwnedDisjoiningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_ruleOwnedDisjoining)
        try:
            self.state = 1014
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleOwnedDisjoining1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1012
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleOwnedDisjoining2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1013
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleUnioningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleUnioning

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleUnioning1Context(RuleUnioningContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleUnioningContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleUnioning1" ):
                listener.enterRuleUnioning1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleUnioning1" ):
                listener.exitRuleUnioning1(self)


    class RuleUnioning2Context(RuleUnioningContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleUnioningContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleUnioning2" ):
                listener.enterRuleUnioning2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleUnioning2" ):
                listener.exitRuleUnioning2(self)



    def ruleUnioning(self):

        localctx = KerMLv2Parser.RuleUnioningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_ruleUnioning)
        try:
            self.state = 1018
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleUnioning1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1016
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleUnioning2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1017
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleIntersectingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleIntersecting

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleIntersecting1Context(RuleIntersectingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleIntersectingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleIntersecting1" ):
                listener.enterRuleIntersecting1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleIntersecting1" ):
                listener.exitRuleIntersecting1(self)


    class RuleIntersecting2Context(RuleIntersectingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleIntersectingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleIntersecting2" ):
                listener.enterRuleIntersecting2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleIntersecting2" ):
                listener.exitRuleIntersecting2(self)



    def ruleIntersecting(self):

        localctx = KerMLv2Parser.RuleIntersectingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_ruleIntersecting)
        try:
            self.state = 1022
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleIntersecting1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1020
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleIntersecting2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1021
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDifferencingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleDifferencing

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleDifferencing1Context(RuleDifferencingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleDifferencingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDifferencing1" ):
                listener.enterRuleDifferencing1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDifferencing1" ):
                listener.exitRuleDifferencing1(self)


    class RuleDifferencing2Context(RuleDifferencingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleDifferencingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDifferencing2" ):
                listener.enterRuleDifferencing2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDifferencing2" ):
                listener.exitRuleDifferencing2(self)



    def ruleDifferencing(self):

        localctx = KerMLv2Parser.RuleDifferencingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_ruleDifferencing)
        try:
            self.state = 1026
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleDifferencing1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1024
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleDifferencing2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1025
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleClassifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_CLASSIFIER(self):
            return self.getToken(KerMLv2Parser.K_CLASSIFIER, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleClassifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassifier" ):
                listener.enterRuleClassifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassifier" ):
                listener.exitRuleClassifier(self)




    def ruleClassifier(self):

        localctx = KerMLv2Parser.RuleClassifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_ruleClassifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1028
            self.ruleTypePrefix()
            self.state = 1029
            self.match(KerMLv2Parser.K_CLASSIFIER)
            self.state = 1030
            self.ruleClassifierDeclaration()
            self.state = 1031
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleClassifierDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ALL(self):
            return self.getToken(KerMLv2Parser.K_ALL, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def ruleOwnedMultiplicity(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedMultiplicityContext,0)


        def ruleSuperclassingPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSuperclassingPartContext,0)


        def ruleClassifierConjugationPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierConjugationPartContext,0)


        def ruleTypeRelationshipPart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleTypeRelationshipPartContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleTypeRelationshipPartContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleClassifierDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassifierDeclaration" ):
                listener.enterRuleClassifierDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassifierDeclaration" ):
                listener.exitRuleClassifierDeclaration(self)




    def ruleClassifierDeclaration(self):

        localctx = KerMLv2Parser.RuleClassifierDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_ruleClassifierDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1034
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 1033
                self.match(KerMLv2Parser.K_ALL)


            self.state = 1037
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                self.state = 1036
                self.ruleIdentification()


            self.state = 1040
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==105:
                self.state = 1039
                self.ruleOwnedMultiplicity()


            self.state = 1044
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 113]:
                self.state = 1042
                self.ruleSuperclassingPart()
                pass
            elif token in [22, 114]:
                self.state = 1043
                self.ruleClassifierConjugationPart()
                pass
            elif token in [23, 24, 25, 26, 102, 108]:
                pass
            else:
                pass
            self.state = 1049
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 125829120) != 0):
                self.state = 1046
                self.ruleTypeRelationshipPart()
                self.state = 1051
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSuperclassingPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedsubclassification(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedsubclassificationContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedsubclassificationContext,i)


        def OP_COLON_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_RANGLE, 0)

        def K_SPECIALIZES(self):
            return self.getToken(KerMLv2Parser.K_SPECIALIZES, 0)

        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSuperclassingPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSuperclassingPart" ):
                listener.enterRuleSuperclassingPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSuperclassingPart" ):
                listener.exitRuleSuperclassingPart(self)




    def ruleSuperclassingPart(self):

        localctx = KerMLv2Parser.RuleSuperclassingPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_ruleSuperclassingPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1052
            _la = self._input.LA(1)
            if not(_la==21 or _la==113):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1053
            self.ruleOwnedsubclassification()
            self.state = 1058
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 1054
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 1055
                self.ruleOwnedsubclassification()
                self.state = 1060
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleClassifierConjugationPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleClassifierConjugation(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierConjugationContext,0)


        def OP_TILDE(self):
            return self.getToken(KerMLv2Parser.OP_TILDE, 0)

        def K_CONJUGATES(self):
            return self.getToken(KerMLv2Parser.K_CONJUGATES, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleClassifierConjugationPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassifierConjugationPart" ):
                listener.enterRuleClassifierConjugationPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassifierConjugationPart" ):
                listener.exitRuleClassifierConjugationPart(self)




    def ruleClassifierConjugationPart(self):

        localctx = KerMLv2Parser.RuleClassifierConjugationPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_ruleClassifierConjugationPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1061
            _la = self._input.LA(1)
            if not(_la==22 or _la==114):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1062
            self.ruleClassifierConjugation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSubclassificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SUBCLASSIFIER(self):
            return self.getToken(KerMLv2Parser.K_SUBCLASSIFIER, 0)

        def ruleQualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleQualifiedNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,i)


        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def OP_COLON_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_RANGLE, 0)

        def K_SPECIALIZES(self):
            return self.getToken(KerMLv2Parser.K_SPECIALIZES, 0)

        def K_SPECIALIZATION(self):
            return self.getToken(KerMLv2Parser.K_SPECIALIZATION, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSubclassification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSubclassification" ):
                listener.enterRuleSubclassification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSubclassification" ):
                listener.exitRuleSubclassification(self)




    def ruleSubclassification(self):

        localctx = KerMLv2Parser.RuleSubclassificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_ruleSubclassification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1068
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 1064
                self.match(KerMLv2Parser.K_SPECIALIZATION)
                self.state = 1066
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 1065
                    self.ruleIdentification()




            self.state = 1070
            self.match(KerMLv2Parser.K_SUBCLASSIFIER)
            self.state = 1071
            self.ruleQualifiedName()
            self.state = 1072
            _la = self._input.LA(1)
            if not(_la==21 or _la==113):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1073
            self.ruleQualifiedName()
            self.state = 1074
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedsubclassificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedsubclassification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedsubclassification" ):
                listener.enterRuleOwnedsubclassification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedsubclassification" ):
                listener.exitRuleOwnedsubclassification(self)




    def ruleOwnedsubclassification(self):

        localctx = KerMLv2Parser.RuleOwnedsubclassificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_ruleOwnedsubclassification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1076
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleClassifierConjugationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleClassifierConjugation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassifierConjugation" ):
                listener.enterRuleClassifierConjugation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassifierConjugation" ):
                listener.exitRuleClassifierConjugation(self)




    def ruleClassifierConjugation(self):

        localctx = KerMLv2Parser.RuleClassifierConjugationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_ruleClassifierConjugation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1078
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeaturePrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeatureDirection(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDirectionContext,0)


        def K_ABSTRACT(self):
            return self.getToken(KerMLv2Parser.K_ABSTRACT, 0)

        def K_READONLY(self):
            return self.getToken(KerMLv2Parser.K_READONLY, 0)

        def K_DERIVED(self):
            return self.getToken(KerMLv2Parser.K_DERIVED, 0)

        def K_END(self):
            return self.getToken(KerMLv2Parser.K_END, 0)

        def rulePrefixMetadataMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RulePrefixMetadataMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataMemberContext,i)


        def K_COMPOSITE(self):
            return self.getToken(KerMLv2Parser.K_COMPOSITE, 0)

        def K_PORTION(self):
            return self.getToken(KerMLv2Parser.K_PORTION, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeaturePrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeaturePrefix" ):
                listener.enterRuleFeaturePrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeaturePrefix" ):
                listener.exitRuleFeaturePrefix(self)




    def ruleFeaturePrefix(self):

        localctx = KerMLv2Parser.RuleFeaturePrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_ruleFeaturePrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1081
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 97)) & ~0x3f) == 0 and ((1 << (_la - 97)) & 7) != 0):
                self.state = 1080
                self.ruleFeatureDirection()


            self.state = 1084
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 1083
                self.match(KerMLv2Parser.K_ABSTRACT)


            self.state = 1087
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35 or _la==36:
                self.state = 1086
                _la = self._input.LA(1)
                if not(_la==35 or _la==36):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1090
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==37:
                self.state = 1089
                self.match(KerMLv2Parser.K_READONLY)


            self.state = 1093
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38:
                self.state = 1092
                self.match(KerMLv2Parser.K_DERIVED)


            self.state = 1096
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 1095
                self.match(KerMLv2Parser.K_END)


            self.state = 1101
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,99,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1098
                    self.rulePrefixMetadataMember() 
                self.state = 1103
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,99,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def ruleFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDeclarationContext,0)


        def rulePrefixMetadataMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataMemberContext,0)


        def K_FEATURE(self):
            return self.getToken(KerMLv2Parser.K_FEATURE, 0)

        def ruleValuePart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleValuePartContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeature

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeature" ):
                listener.enterRuleFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeature" ):
                listener.exitRuleFeature(self)




    def ruleFeature(self):

        localctx = KerMLv2Parser.RuleFeatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_ruleFeature)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1104
            self.ruleFeaturePrefix()
            self.state = 1111
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 1106
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==40:
                    self.state = 1105
                    self.match(KerMLv2Parser.K_FEATURE)


                self.state = 1108
                self.ruleFeatureDeclaration()
                pass

            elif la_ == 2:
                self.state = 1109
                self.rulePrefixMetadataMember()
                pass

            elif la_ == 3:
                self.state = 1110
                self.match(KerMLv2Parser.K_FEATURE)
                pass


            self.state = 1114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & 6917529027641081857) != 0):
                self.state = 1113
                self.ruleValuePart()


            self.state = 1116
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def ruleFeatureSpecializationPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureSpecializationPartContext,0)


        def ruleFeatureConjugationPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureConjugationPartContext,0)


        def K_ALL(self):
            return self.getToken(KerMLv2Parser.K_ALL, 0)

        def ruleFeatureRelationshipPart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFeatureRelationshipPartContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureRelationshipPartContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureDeclaration" ):
                listener.enterRuleFeatureDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureDeclaration" ):
                listener.exitRuleFeatureDeclaration(self)




    def ruleFeatureDeclaration(self):

        localctx = KerMLv2Parser.RuleFeatureDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_ruleFeatureDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 1118
                self.match(KerMLv2Parser.K_ALL)


            self.state = 1128
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [100, 144, 145]:
                self.state = 1121
                self.ruleIdentification()
                self.state = 1124
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [46, 47, 48, 49, 50, 51, 105, 113, 115, 116, 117]:
                    self.state = 1122
                    self.ruleFeatureSpecializationPart()
                    pass
                elif token in [22, 114]:
                    self.state = 1123
                    self.ruleFeatureConjugationPart()
                    pass
                elif token in [2, 23, 24, 25, 26, 41, 42, 43, 44, 57, 66, 102, 106, 108, 118, 119]:
                    pass
                else:
                    pass
                pass
            elif token in [46, 47, 48, 49, 50, 51, 105, 113, 115, 116, 117]:
                self.state = 1126
                self.ruleFeatureSpecializationPart()
                pass
            elif token in [22, 114]:
                self.state = 1127
                self.ruleFeatureConjugationPart()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 24189381640192) != 0):
                self.state = 1130
                self.ruleFeatureRelationshipPart()
                self.state = 1135
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureRelationshipPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureRelationshipPart

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFeatureRelationshipPart4Context(RuleFeatureRelationshipPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureRelationshipPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleTypeFeaturingPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeFeaturingPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureRelationshipPart4" ):
                listener.enterRuleFeatureRelationshipPart4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureRelationshipPart4" ):
                listener.exitRuleFeatureRelationshipPart4(self)


    class RuleFeatureRelationshipPart3Context(RuleFeatureRelationshipPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureRelationshipPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleInvertingPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleInvertingPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureRelationshipPart3" ):
                listener.enterRuleFeatureRelationshipPart3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureRelationshipPart3" ):
                listener.exitRuleFeatureRelationshipPart3(self)


    class RuleFeatureRelationshipPart2Context(RuleFeatureRelationshipPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureRelationshipPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleChainingPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleChainingPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureRelationshipPart2" ):
                listener.enterRuleFeatureRelationshipPart2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureRelationshipPart2" ):
                listener.exitRuleFeatureRelationshipPart2(self)


    class RuleFeatureRelationshipPart1Context(RuleFeatureRelationshipPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureRelationshipPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleTypeRelationshipPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeRelationshipPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureRelationshipPart1" ):
                listener.enterRuleFeatureRelationshipPart1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureRelationshipPart1" ):
                listener.exitRuleFeatureRelationshipPart1(self)



    def ruleFeatureRelationshipPart(self):

        localctx = KerMLv2Parser.RuleFeatureRelationshipPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_ruleFeatureRelationshipPart)
        try:
            self.state = 1140
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [23, 24, 25, 26]:
                localctx = KerMLv2Parser.RuleFeatureRelationshipPart1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1136
                self.ruleTypeRelationshipPart()
                pass
            elif token in [41]:
                localctx = KerMLv2Parser.RuleFeatureRelationshipPart2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1137
                self.ruleChainingPart()
                pass
            elif token in [42]:
                localctx = KerMLv2Parser.RuleFeatureRelationshipPart3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1138
                self.ruleInvertingPart()
                pass
            elif token in [44]:
                localctx = KerMLv2Parser.RuleFeatureRelationshipPart4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1139
                self.ruleTypeFeaturingPart()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleChainingPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_CHAINS(self):
            return self.getToken(KerMLv2Parser.K_CHAINS, 0)

        def ruleOwnedFeatureChaining(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainingContext,0)


        def ruleFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureChainContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleChainingPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleChainingPart" ):
                listener.enterRuleChainingPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleChainingPart" ):
                listener.exitRuleChainingPart(self)




    def ruleChainingPart(self):

        localctx = KerMLv2Parser.RuleChainingPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_ruleChainingPart)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1142
            self.match(KerMLv2Parser.K_CHAINS)
            self.state = 1145
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.state = 1143
                self.ruleOwnedFeatureChaining()
                pass

            elif la_ == 2:
                self.state = 1144
                self.ruleFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleInvertingPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_INVERSE(self):
            return self.getToken(KerMLv2Parser.K_INVERSE, 0)

        def K_OF(self):
            return self.getToken(KerMLv2Parser.K_OF, 0)

        def ruleOwnedFeatureInverting(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureInvertingContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleInvertingPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleInvertingPart" ):
                listener.enterRuleInvertingPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleInvertingPart" ):
                listener.exitRuleInvertingPart(self)




    def ruleInvertingPart(self):

        localctx = KerMLv2Parser.RuleInvertingPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_ruleInvertingPart)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1147
            self.match(KerMLv2Parser.K_INVERSE)
            self.state = 1148
            self.match(KerMLv2Parser.K_OF)
            self.state = 1149
            self.ruleOwnedFeatureInverting()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeFeaturingPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FEATURED(self):
            return self.getToken(KerMLv2Parser.K_FEATURED, 0)

        def K_BY(self):
            return self.getToken(KerMLv2Parser.K_BY, 0)

        def ruleOwnedTypeFeaturing(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedTypeFeaturingContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedTypeFeaturingContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypeFeaturingPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeFeaturingPart" ):
                listener.enterRuleTypeFeaturingPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeFeaturingPart" ):
                listener.exitRuleTypeFeaturingPart(self)




    def ruleTypeFeaturingPart(self):

        localctx = KerMLv2Parser.RuleTypeFeaturingPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_ruleTypeFeaturingPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1151
            self.match(KerMLv2Parser.K_FEATURED)
            self.state = 1152
            self.match(KerMLv2Parser.K_BY)
            self.state = 1153
            self.ruleOwnedTypeFeaturing()
            self.state = 1158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 1154
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 1155
                self.ruleOwnedTypeFeaturing()
                self.state = 1160
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureSpecializationPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureSpecializationPart

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFeatureSpecializationPart1Context(RuleFeatureSpecializationPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureSpecializationPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureSpecialization(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFeatureSpecializationContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureSpecializationContext,i)

        def ruleMultiplicityPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicityPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureSpecializationPart1" ):
                listener.enterRuleFeatureSpecializationPart1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureSpecializationPart1" ):
                listener.exitRuleFeatureSpecializationPart1(self)


    class RuleFeatureSpecializationPart2Context(RuleFeatureSpecializationPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureSpecializationPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMultiplicityPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicityPartContext,0)

        def ruleFeatureSpecialization(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFeatureSpecializationContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureSpecializationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureSpecializationPart2" ):
                listener.enterRuleFeatureSpecializationPart2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureSpecializationPart2" ):
                listener.exitRuleFeatureSpecializationPart2(self)



    def ruleFeatureSpecializationPart(self):

        localctx = KerMLv2Parser.RuleFeatureSpecializationPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_ruleFeatureSpecializationPart)
        self._la = 0 # Token type
        try:
            self.state = 1182
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48, 49, 50, 51, 113, 115, 116, 117]:
                localctx = KerMLv2Parser.RuleFeatureSpecializationPart1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1162 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1161
                        self.ruleFeatureSpecialization()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1164 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,110,self._ctx)

                self.state = 1167
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 46)) & ~0x3f) == 0 and ((1 << (_la - 46)) & 576460752303423491) != 0):
                    self.state = 1166
                    self.ruleMultiplicityPart()


                self.state = 1172
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4222124650659840) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 29) != 0):
                    self.state = 1169
                    self.ruleFeatureSpecialization()
                    self.state = 1174
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [46, 47, 105]:
                localctx = KerMLv2Parser.RuleFeatureSpecializationPart2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1175
                self.ruleMultiplicityPart()
                self.state = 1179
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4222124650659840) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 29) != 0):
                    self.state = 1176
                    self.ruleFeatureSpecialization()
                    self.state = 1181
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMultiplicityPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMultiplicityPart

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleMultiplicityPart1Context(RuleMultiplicityPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMultiplicityPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedMultiplicity(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedMultiplicityContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicityPart1" ):
                listener.enterRuleMultiplicityPart1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicityPart1" ):
                listener.exitRuleMultiplicityPart1(self)


    class RuleMultiplicityPart2Context(RuleMultiplicityPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMultiplicityPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_ORDERED(self):
            return self.getToken(KerMLv2Parser.K_ORDERED, 0)
        def K_NONUNIQUE(self):
            return self.getToken(KerMLv2Parser.K_NONUNIQUE, 0)
        def ruleOwnedMultiplicity(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedMultiplicityContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicityPart2" ):
                listener.enterRuleMultiplicityPart2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicityPart2" ):
                listener.exitRuleMultiplicityPart2(self)



    def ruleMultiplicityPart(self):

        localctx = KerMLv2Parser.RuleMultiplicityPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_ruleMultiplicityPart)
        self._la = 0 # Token type
        try:
            self.state = 1198
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleMultiplicityPart1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1184
                self.ruleOwnedMultiplicity()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleMultiplicityPart2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1186
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==105:
                    self.state = 1185
                    self.ruleOwnedMultiplicity()


                self.state = 1196
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [46]:
                    self.state = 1188
                    self.match(KerMLv2Parser.K_ORDERED)
                    self.state = 1190
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==47:
                        self.state = 1189
                        self.match(KerMLv2Parser.K_NONUNIQUE)


                    pass
                elif token in [47]:
                    self.state = 1192
                    self.match(KerMLv2Parser.K_NONUNIQUE)
                    self.state = 1194
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==46:
                        self.state = 1193
                        self.match(KerMLv2Parser.K_ORDERED)


                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureSpecializationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureSpecialization

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFeatureSpecialization1Context(RuleFeatureSpecializationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureSpecializationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleTypings(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypingsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureSpecialization1" ):
                listener.enterRuleFeatureSpecialization1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureSpecialization1" ):
                listener.exitRuleFeatureSpecialization1(self)


    class RuleFeatureSpecialization2Context(RuleFeatureSpecializationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureSpecializationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleSubsettings(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSubsettingsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureSpecialization2" ):
                listener.enterRuleFeatureSpecialization2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureSpecialization2" ):
                listener.exitRuleFeatureSpecialization2(self)


    class RuleFeatureSpecialization3Context(RuleFeatureSpecializationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureSpecializationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleReferences(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleReferencesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureSpecialization3" ):
                listener.enterRuleFeatureSpecialization3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureSpecialization3" ):
                listener.exitRuleFeatureSpecialization3(self)


    class RuleFeatureSpecialization4Context(RuleFeatureSpecializationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureSpecializationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleRedefinitions(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRedefinitionsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureSpecialization4" ):
                listener.enterRuleFeatureSpecialization4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureSpecialization4" ):
                listener.exitRuleFeatureSpecialization4(self)



    def ruleFeatureSpecialization(self):

        localctx = KerMLv2Parser.RuleFeatureSpecializationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_ruleFeatureSpecialization)
        try:
            self.state = 1204
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48, 115]:
                localctx = KerMLv2Parser.RuleFeatureSpecialization1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1200
                self.ruleTypings()
                pass
            elif token in [49, 113]:
                localctx = KerMLv2Parser.RuleFeatureSpecialization2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1201
                self.ruleSubsettings()
                pass
            elif token in [50, 116]:
                localctx = KerMLv2Parser.RuleFeatureSpecialization3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1202
                self.ruleReferences()
                pass
            elif token in [51, 117]:
                localctx = KerMLv2Parser.RuleFeatureSpecialization4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1203
                self.ruleRedefinitions()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypingsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypedBy(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypedByContext,0)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def ruleOwnedFeatureTyping(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedFeatureTypingContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureTypingContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypings

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypings" ):
                listener.enterRuleTypings(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypings" ):
                listener.exitRuleTypings(self)




    def ruleTypings(self):

        localctx = KerMLv2Parser.RuleTypingsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_ruleTypings)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1206
            self.ruleTypedBy()
            self.state = 1211
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 1207
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 1208
                self.ruleOwnedFeatureTyping()
                self.state = 1213
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypedByContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedFeatureTyping(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureTypingContext,0)


        def OP_COLON(self):
            return self.getToken(KerMLv2Parser.OP_COLON, 0)

        def K_TYPED(self):
            return self.getToken(KerMLv2Parser.K_TYPED, 0)

        def K_BY(self):
            return self.getToken(KerMLv2Parser.K_BY, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypedBy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypedBy" ):
                listener.enterRuleTypedBy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypedBy" ):
                listener.exitRuleTypedBy(self)




    def ruleTypedBy(self):

        localctx = KerMLv2Parser.RuleTypedByContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_ruleTypedBy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1217
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [115]:
                self.state = 1214
                self.match(KerMLv2Parser.OP_COLON)
                pass
            elif token in [48]:
                self.state = 1215
                self.match(KerMLv2Parser.K_TYPED)
                self.state = 1216
                self.match(KerMLv2Parser.K_BY)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1219
            self.ruleOwnedFeatureTyping()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSubsettingsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleSubsets(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSubsetsContext,0)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def ruleOwnedSubsetting(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedSubsettingContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedSubsettingContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSubsettings

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSubsettings" ):
                listener.enterRuleSubsettings(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSubsettings" ):
                listener.exitRuleSubsettings(self)




    def ruleSubsettings(self):

        localctx = KerMLv2Parser.RuleSubsettingsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_ruleSubsettings)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1221
            self.ruleSubsets()
            self.state = 1226
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 1222
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 1223
                self.ruleOwnedSubsetting()
                self.state = 1228
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSubsetsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedSubsetting(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedSubsettingContext,0)


        def OP_COLON_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_RANGLE, 0)

        def K_SUBSETS(self):
            return self.getToken(KerMLv2Parser.K_SUBSETS, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSubsets

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSubsets" ):
                listener.enterRuleSubsets(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSubsets" ):
                listener.exitRuleSubsets(self)




    def ruleSubsets(self):

        localctx = KerMLv2Parser.RuleSubsetsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_ruleSubsets)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1229
            _la = self._input.LA(1)
            if not(_la==49 or _la==113):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1230
            self.ruleOwnedSubsetting()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleReferencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleReferencesKeyword(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleReferencesKeywordContext,0)


        def ruleOwnedReferenceSubsetting(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedReferenceSubsettingContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleReferences

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleReferences" ):
                listener.enterRuleReferences(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleReferences" ):
                listener.exitRuleReferences(self)




    def ruleReferences(self):

        localctx = KerMLv2Parser.RuleReferencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_ruleReferences)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1232
            self.ruleReferencesKeyword()
            self.state = 1233
            self.ruleOwnedReferenceSubsetting()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleReferencesKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleReferencesKeyword

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleReferencesKeyword1Context(RuleReferencesKeywordContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleReferencesKeywordContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_COLON_COLON_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_COLON_RANGLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleReferencesKeyword1" ):
                listener.enterRuleReferencesKeyword1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleReferencesKeyword1" ):
                listener.exitRuleReferencesKeyword1(self)


    class RuleReferencesKeyword2Context(RuleReferencesKeywordContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleReferencesKeywordContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_REFERENCES(self):
            return self.getToken(KerMLv2Parser.K_REFERENCES, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleReferencesKeyword2" ):
                listener.enterRuleReferencesKeyword2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleReferencesKeyword2" ):
                listener.exitRuleReferencesKeyword2(self)



    def ruleReferencesKeyword(self):

        localctx = KerMLv2Parser.RuleReferencesKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_ruleReferencesKeyword)
        try:
            self.state = 1237
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [116]:
                localctx = KerMLv2Parser.RuleReferencesKeyword1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1235
                self.match(KerMLv2Parser.OP_COLON_COLON_RANGLE)
                pass
            elif token in [50]:
                localctx = KerMLv2Parser.RuleReferencesKeyword2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1236
                self.match(KerMLv2Parser.K_REFERENCES)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRedefinitionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleRedefines(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRedefinesContext,0)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def ruleOwnedRedefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedRedefinitionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedRedefinitionContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRedefinitions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRedefinitions" ):
                listener.enterRuleRedefinitions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRedefinitions" ):
                listener.exitRuleRedefinitions(self)




    def ruleRedefinitions(self):

        localctx = KerMLv2Parser.RuleRedefinitionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_ruleRedefinitions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1239
            self.ruleRedefines()
            self.state = 1244
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 1240
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 1241
                self.ruleOwnedRedefinition()
                self.state = 1246
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRedefinesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedRedefinition(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedRedefinitionContext,0)


        def OP_COLON_RANGLE_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_RANGLE_RANGLE, 0)

        def K_REDEFINES(self):
            return self.getToken(KerMLv2Parser.K_REDEFINES, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRedefines

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRedefines" ):
                listener.enterRuleRedefines(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRedefines" ):
                listener.exitRuleRedefines(self)




    def ruleRedefines(self):

        localctx = KerMLv2Parser.RuleRedefinesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_ruleRedefines)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1247
            _la = self._input.LA(1)
            if not(_la==51 or _la==117):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1248
            self.ruleOwnedRedefinition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureInvertingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_INVERSE(self):
            return self.getToken(KerMLv2Parser.K_INVERSE, 0)

        def K_OF(self):
            return self.getToken(KerMLv2Parser.K_OF, 0)

        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def ruleQualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleQualifiedNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,i)


        def ruleOwnedFeatureChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedFeatureChainContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,i)


        def K_INVERTING(self):
            return self.getToken(KerMLv2Parser.K_INVERTING, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureInverting

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureInverting" ):
                listener.enterRuleFeatureInverting(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureInverting" ):
                listener.exitRuleFeatureInverting(self)




    def ruleFeatureInverting(self):

        localctx = KerMLv2Parser.RuleFeatureInvertingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_ruleFeatureInverting)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1254
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 1250
                self.match(KerMLv2Parser.K_INVERTING)
                self.state = 1252
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 1251
                    self.ruleIdentification()




            self.state = 1256
            self.match(KerMLv2Parser.K_INVERSE)
            self.state = 1259
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
            if la_ == 1:
                self.state = 1257
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 1258
                self.ruleOwnedFeatureChain()
                pass


            self.state = 1261
            self.match(KerMLv2Parser.K_OF)
            self.state = 1264
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
            if la_ == 1:
                self.state = 1262
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 1263
                self.ruleOwnedFeatureChain()
                pass


            self.state = 1266
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedFeatureInvertingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedFeatureInverting

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleOwnedFeatureInverting2Context(RuleOwnedFeatureInvertingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedFeatureInvertingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedFeatureInverting2" ):
                listener.enterRuleOwnedFeatureInverting2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedFeatureInverting2" ):
                listener.exitRuleOwnedFeatureInverting2(self)


    class RuleOwnedFeatureInverting1Context(RuleOwnedFeatureInvertingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedFeatureInvertingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedFeatureInverting1" ):
                listener.enterRuleOwnedFeatureInverting1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedFeatureInverting1" ):
                listener.exitRuleOwnedFeatureInverting1(self)



    def ruleOwnedFeatureInverting(self):

        localctx = KerMLv2Parser.RuleOwnedFeatureInvertingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_ruleOwnedFeatureInverting)
        try:
            self.state = 1270
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleOwnedFeatureInverting1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1268
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleOwnedFeatureInverting2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1269
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeFeaturingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FEATURING(self):
            return self.getToken(KerMLv2Parser.K_FEATURING, 0)

        def ruleQualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleQualifiedNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,i)


        def K_BY(self):
            return self.getToken(KerMLv2Parser.K_BY, 0)

        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def K_OF(self):
            return self.getToken(KerMLv2Parser.K_OF, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypeFeaturing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeFeaturing" ):
                listener.enterRuleTypeFeaturing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeFeaturing" ):
                listener.exitRuleTypeFeaturing(self)




    def ruleTypeFeaturing(self):

        localctx = KerMLv2Parser.RuleTypeFeaturingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_ruleTypeFeaturing)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1272
            self.match(KerMLv2Parser.K_FEATURING)
            self.state = 1277
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,132,self._ctx)
            if la_ == 1:
                self.state = 1274
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 1273
                    self.ruleIdentification()


                self.state = 1276
                self.match(KerMLv2Parser.K_OF)


            self.state = 1279
            self.ruleQualifiedName()
            self.state = 1280
            self.match(KerMLv2Parser.K_BY)
            self.state = 1281
            self.ruleQualifiedName()
            self.state = 1282
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedTypeFeaturingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedTypeFeaturing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedTypeFeaturing" ):
                listener.enterRuleOwnedTypeFeaturing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedTypeFeaturing" ):
                listener.exitRuleOwnedTypeFeaturing(self)




    def ruleOwnedTypeFeaturing(self):

        localctx = KerMLv2Parser.RuleOwnedTypeFeaturingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_ruleOwnedTypeFeaturing)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1284
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureTypingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_TYPING(self):
            return self.getToken(KerMLv2Parser.K_TYPING, 0)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def ruleFeatureType(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureTypeContext,0)


        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def OP_COLON(self):
            return self.getToken(KerMLv2Parser.OP_COLON, 0)

        def K_TYPED(self):
            return self.getToken(KerMLv2Parser.K_TYPED, 0)

        def K_BY(self):
            return self.getToken(KerMLv2Parser.K_BY, 0)

        def K_SPECIALIZATION(self):
            return self.getToken(KerMLv2Parser.K_SPECIALIZATION, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureTyping

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureTyping" ):
                listener.enterRuleFeatureTyping(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureTyping" ):
                listener.exitRuleFeatureTyping(self)




    def ruleFeatureTyping(self):

        localctx = KerMLv2Parser.RuleFeatureTypingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_ruleFeatureTyping)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1290
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 1286
                self.match(KerMLv2Parser.K_SPECIALIZATION)
                self.state = 1288
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 1287
                    self.ruleIdentification()




            self.state = 1292
            self.match(KerMLv2Parser.K_TYPING)
            self.state = 1293
            self.ruleQualifiedName()
            self.state = 1297
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [115]:
                self.state = 1294
                self.match(KerMLv2Parser.OP_COLON)
                pass
            elif token in [48]:
                self.state = 1295
                self.match(KerMLv2Parser.K_TYPED)
                self.state = 1296
                self.match(KerMLv2Parser.K_BY)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1299
            self.ruleFeatureType()
            self.state = 1300
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedFeatureTypingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeatureType(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureTypeContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedFeatureTyping

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedFeatureTyping" ):
                listener.enterRuleOwnedFeatureTyping(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedFeatureTyping" ):
                listener.exitRuleOwnedFeatureTyping(self)




    def ruleOwnedFeatureTyping(self):

        localctx = KerMLv2Parser.RuleOwnedFeatureTypingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_ruleOwnedFeatureTyping)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1302
            self.ruleFeatureType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureType

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFeatureType1Context(RuleFeatureTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureTypeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureType1" ):
                listener.enterRuleFeatureType1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureType1" ):
                listener.exitRuleFeatureType1(self)


    class RuleFeatureType2Context(RuleFeatureTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureTypeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureType2" ):
                listener.enterRuleFeatureType2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureType2" ):
                listener.exitRuleFeatureType2(self)



    def ruleFeatureType(self):

        localctx = KerMLv2Parser.RuleFeatureTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_ruleFeatureType)
        try:
            self.state = 1306
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleFeatureType1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1304
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleFeatureType2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1305
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSubsettingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SUBSET(self):
            return self.getToken(KerMLv2Parser.K_SUBSET, 0)

        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def OP_COLON_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_RANGLE, 0)

        def K_SUBSETS(self):
            return self.getToken(KerMLv2Parser.K_SUBSETS, 0)

        def ruleQualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleQualifiedNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,i)


        def ruleOwnedFeatureChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedFeatureChainContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,i)


        def K_SPECIALIZATION(self):
            return self.getToken(KerMLv2Parser.K_SPECIALIZATION, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSubsetting

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSubsetting" ):
                listener.enterRuleSubsetting(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSubsetting" ):
                listener.exitRuleSubsetting(self)




    def ruleSubsetting(self):

        localctx = KerMLv2Parser.RuleSubsettingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_ruleSubsetting)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1312
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 1308
                self.match(KerMLv2Parser.K_SPECIALIZATION)
                self.state = 1310
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 1309
                    self.ruleIdentification()




            self.state = 1314
            self.match(KerMLv2Parser.K_SUBSET)
            self.state = 1317
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
            if la_ == 1:
                self.state = 1315
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 1316
                self.ruleOwnedFeatureChain()
                pass


            self.state = 1319
            _la = self._input.LA(1)
            if not(_la==49 or _la==113):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1322
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,140,self._ctx)
            if la_ == 1:
                self.state = 1320
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 1321
                self.ruleOwnedFeatureChain()
                pass


            self.state = 1324
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedSubsettingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedSubsetting

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleOwnedSubsetting1Context(RuleOwnedSubsettingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedSubsettingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedSubsetting1" ):
                listener.enterRuleOwnedSubsetting1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedSubsetting1" ):
                listener.exitRuleOwnedSubsetting1(self)


    class RuleOwnedSubsetting2Context(RuleOwnedSubsettingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedSubsettingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedSubsetting2" ):
                listener.enterRuleOwnedSubsetting2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedSubsetting2" ):
                listener.exitRuleOwnedSubsetting2(self)



    def ruleOwnedSubsetting(self):

        localctx = KerMLv2Parser.RuleOwnedSubsettingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_ruleOwnedSubsetting)
        try:
            self.state = 1328
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,141,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleOwnedSubsetting1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1326
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleOwnedSubsetting2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1327
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedReferenceSubsettingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedReferenceSubsetting

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleOwnedReferenceSubsetting2Context(RuleOwnedReferenceSubsettingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedReferenceSubsettingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedReferenceSubsetting2" ):
                listener.enterRuleOwnedReferenceSubsetting2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedReferenceSubsetting2" ):
                listener.exitRuleOwnedReferenceSubsetting2(self)


    class RuleOwnedReferenceSubsetting1Context(RuleOwnedReferenceSubsettingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedReferenceSubsettingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedReferenceSubsetting1" ):
                listener.enterRuleOwnedReferenceSubsetting1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedReferenceSubsetting1" ):
                listener.exitRuleOwnedReferenceSubsetting1(self)



    def ruleOwnedReferenceSubsetting(self):

        localctx = KerMLv2Parser.RuleOwnedReferenceSubsettingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_ruleOwnedReferenceSubsetting)
        try:
            self.state = 1332
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,142,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleOwnedReferenceSubsetting1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1330
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleOwnedReferenceSubsetting2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1331
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRedefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_REDEFINITION(self):
            return self.getToken(KerMLv2Parser.K_REDEFINITION, 0)

        def ruleRelationshipBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationshipBodyContext,0)


        def OP_COLON_RANGLE_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_RANGLE_RANGLE, 0)

        def K_REDEFINES(self):
            return self.getToken(KerMLv2Parser.K_REDEFINES, 0)

        def ruleQualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleQualifiedNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,i)


        def ruleOwnedFeatureChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedFeatureChainContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,i)


        def K_SPECIALIZATION(self):
            return self.getToken(KerMLv2Parser.K_SPECIALIZATION, 0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRedefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRedefinition" ):
                listener.enterRuleRedefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRedefinition" ):
                listener.exitRuleRedefinition(self)




    def ruleRedefinition(self):

        localctx = KerMLv2Parser.RuleRedefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_ruleRedefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1338
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==28:
                self.state = 1334
                self.match(KerMLv2Parser.K_SPECIALIZATION)
                self.state = 1336
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 1335
                    self.ruleIdentification()




            self.state = 1340
            self.match(KerMLv2Parser.K_REDEFINITION)
            self.state = 1343
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
            if la_ == 1:
                self.state = 1341
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 1342
                self.ruleOwnedFeatureChain()
                pass


            self.state = 1345
            _la = self._input.LA(1)
            if not(_la==51 or _la==117):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1348
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,146,self._ctx)
            if la_ == 1:
                self.state = 1346
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                self.state = 1347
                self.ruleOwnedFeatureChain()
                pass


            self.state = 1350
            self.ruleRelationshipBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedRedefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedRedefinition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleOwnedRedefinition1Context(RuleOwnedRedefinitionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedRedefinitionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedRedefinition1" ):
                listener.enterRuleOwnedRedefinition1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedRedefinition1" ):
                listener.exitRuleOwnedRedefinition1(self)


    class RuleOwnedRedefinition2Context(RuleOwnedRedefinitionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleOwnedRedefinitionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedRedefinition2" ):
                listener.enterRuleOwnedRedefinition2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedRedefinition2" ):
                listener.exitRuleOwnedRedefinition2(self)



    def ruleOwnedRedefinition(self):

        localctx = KerMLv2Parser.RuleOwnedRedefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_ruleOwnedRedefinition)
        try:
            self.state = 1354
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,147,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleOwnedRedefinition1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1352
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleOwnedRedefinition2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1353
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureConjugationPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeatureConjugation(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureConjugationContext,0)


        def OP_TILDE(self):
            return self.getToken(KerMLv2Parser.OP_TILDE, 0)

        def K_CONJUGATES(self):
            return self.getToken(KerMLv2Parser.K_CONJUGATES, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureConjugationPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureConjugationPart" ):
                listener.enterRuleFeatureConjugationPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureConjugationPart" ):
                listener.exitRuleFeatureConjugationPart(self)




    def ruleFeatureConjugationPart(self):

        localctx = KerMLv2Parser.RuleFeatureConjugationPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_ruleFeatureConjugationPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1356
            _la = self._input.LA(1)
            if not(_la==22 or _la==114):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1357
            self.ruleFeatureConjugation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureConjugationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureConjugation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureConjugation" ):
                listener.enterRuleFeatureConjugation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureConjugation" ):
                listener.exitRuleFeatureConjugation(self)




    def ruleFeatureConjugation(self):

        localctx = KerMLv2Parser.RuleFeatureConjugationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_ruleFeatureConjugation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1359
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleValuePartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeatureValue(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureValueContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleValuePart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleValuePart" ):
                listener.enterRuleValuePart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleValuePart" ):
                listener.exitRuleValuePart(self)




    def ruleValuePart(self):

        localctx = KerMLv2Parser.RuleValuePartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_ruleValuePart)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1361
            self.ruleFeatureValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedExpressionContext,0)


        def OP_EQ(self):
            return self.getToken(KerMLv2Parser.OP_EQ, 0)

        def OP_COLON_EQ(self):
            return self.getToken(KerMLv2Parser.OP_COLON_EQ, 0)

        def K_DEFAULT(self):
            return self.getToken(KerMLv2Parser.K_DEFAULT, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureValue" ):
                listener.enterRuleFeatureValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureValue" ):
                listener.exitRuleFeatureValue(self)




    def ruleFeatureValue(self):

        localctx = KerMLv2Parser.RuleFeatureValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_ruleFeatureValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1369
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118]:
                self.state = 1363
                self.match(KerMLv2Parser.OP_EQ)
                pass
            elif token in [119]:
                self.state = 1364
                self.match(KerMLv2Parser.OP_COLON_EQ)
                pass
            elif token in [57]:
                self.state = 1365
                self.match(KerMLv2Parser.K_DEFAULT)
                self.state = 1367
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==118 or _la==119:
                    self.state = 1366
                    _la = self._input.LA(1)
                    if not(_la==118 or _la==119):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 1371
            self.ruleOwnedExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMultiplicityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMultiplicity

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleMultiplicity1Context(RuleMultiplicityContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMultiplicityContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMultiplicitySubset(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicitySubsetContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicity1" ):
                listener.enterRuleMultiplicity1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicity1" ):
                listener.exitRuleMultiplicity1(self)


    class RuleMultiplicity2Context(RuleMultiplicityContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMultiplicityContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMultiplicityRange(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicityRangeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicity2" ):
                listener.enterRuleMultiplicity2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicity2" ):
                listener.exitRuleMultiplicity2(self)



    def ruleMultiplicity(self):

        localctx = KerMLv2Parser.RuleMultiplicityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_ruleMultiplicity)
        try:
            self.state = 1375
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,150,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleMultiplicity1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1373
                self.ruleMultiplicitySubset()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleMultiplicity2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1374
                self.ruleMultiplicityRange()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMultiplicitySubsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_MULTIPLICITY(self):
            return self.getToken(KerMLv2Parser.K_MULTIPLICITY, 0)

        def ruleSubsets(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSubsetsContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMultiplicitySubset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicitySubset" ):
                listener.enterRuleMultiplicitySubset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicitySubset" ):
                listener.exitRuleMultiplicitySubset(self)




    def ruleMultiplicitySubset(self):

        localctx = KerMLv2Parser.RuleMultiplicitySubsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_ruleMultiplicitySubset)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1377
            self.match(KerMLv2Parser.K_MULTIPLICITY)
            self.state = 1379
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                self.state = 1378
                self.ruleIdentification()


            self.state = 1381
            self.ruleSubsets()
            self.state = 1382
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMultiplicityRangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_MULTIPLICITY(self):
            return self.getToken(KerMLv2Parser.K_MULTIPLICITY, 0)

        def ruleMultiplicityBounds(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicityBoundsContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMultiplicityRange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicityRange" ):
                listener.enterRuleMultiplicityRange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicityRange" ):
                listener.exitRuleMultiplicityRange(self)




    def ruleMultiplicityRange(self):

        localctx = KerMLv2Parser.RuleMultiplicityRangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_ruleMultiplicityRange)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1384
            self.match(KerMLv2Parser.K_MULTIPLICITY)
            self.state = 1386
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                self.state = 1385
                self.ruleIdentification()


            self.state = 1388
            self.ruleMultiplicityBounds()
            self.state = 1389
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedMultiplicityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedMultiplicityRange(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedMultiplicityRangeContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedMultiplicity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedMultiplicity" ):
                listener.enterRuleOwnedMultiplicity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedMultiplicity" ):
                listener.exitRuleOwnedMultiplicity(self)




    def ruleOwnedMultiplicity(self):

        localctx = KerMLv2Parser.RuleOwnedMultiplicityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_ruleOwnedMultiplicity)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1391
            self.ruleOwnedMultiplicityRange()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedMultiplicityRangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMultiplicityBounds(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicityBoundsContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedMultiplicityRange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedMultiplicityRange" ):
                listener.enterRuleOwnedMultiplicityRange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedMultiplicityRange" ):
                listener.exitRuleOwnedMultiplicityRange(self)




    def ruleOwnedMultiplicityRange(self):

        localctx = KerMLv2Parser.RuleOwnedMultiplicityRangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_ruleOwnedMultiplicityRange)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1393
            self.ruleMultiplicityBounds()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMultiplicityBoundsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LSQUARE(self):
            return self.getToken(KerMLv2Parser.LSQUARE, 0)

        def ruleMultiplicityExpressionMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleMultiplicityExpressionMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicityExpressionMemberContext,i)


        def RSQUARE(self):
            return self.getToken(KerMLv2Parser.RSQUARE, 0)

        def OP_DOT_DOT(self):
            return self.getToken(KerMLv2Parser.OP_DOT_DOT, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMultiplicityBounds

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicityBounds" ):
                listener.enterRuleMultiplicityBounds(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicityBounds" ):
                listener.exitRuleMultiplicityBounds(self)




    def ruleMultiplicityBounds(self):

        localctx = KerMLv2Parser.RuleMultiplicityBoundsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_ruleMultiplicityBounds)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1395
            self.match(KerMLv2Parser.LSQUARE)
            self.state = 1396
            self.ruleMultiplicityExpressionMember()
            self.state = 1399
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==120:
                self.state = 1397
                self.match(KerMLv2Parser.OP_DOT_DOT)
                self.state = 1398
                self.ruleMultiplicityExpressionMember()


            self.state = 1401
            self.match(KerMLv2Parser.RSQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMultiplicityExpressionMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleLiteralExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleLiteralExpressionContext,0)


        def ruleFeatureReferenceExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureReferenceExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMultiplicityExpressionMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicityExpressionMember" ):
                listener.enterRuleMultiplicityExpressionMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicityExpressionMember" ):
                listener.exitRuleMultiplicityExpressionMember(self)




    def ruleMultiplicityExpressionMember(self):

        localctx = KerMLv2Parser.RuleMultiplicityExpressionMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_ruleMultiplicityExpressionMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1405
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [76, 77, 112, 121, 142, 143, 146]:
                self.state = 1403
                self.ruleLiteralExpression()
                pass
            elif token in [144, 145]:
                self.state = 1404
                self.ruleFeatureReferenceExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDataTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_DATATYPE(self):
            return self.getToken(KerMLv2Parser.K_DATATYPE, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleDataType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDataType" ):
                listener.enterRuleDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDataType" ):
                listener.exitRuleDataType(self)




    def ruleDataType(self):

        localctx = KerMLv2Parser.RuleDataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_ruleDataType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1407
            self.ruleTypePrefix()
            self.state = 1408
            self.match(KerMLv2Parser.K_DATATYPE)
            self.state = 1409
            self.ruleClassifierDeclaration()
            self.state = 1410
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleClassContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_CLASS(self):
            return self.getToken(KerMLv2Parser.K_CLASS, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleClass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClass" ):
                listener.enterRuleClass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClass" ):
                listener.exitRuleClass(self)




    def ruleClass(self):

        localctx = KerMLv2Parser.RuleClassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_ruleClass)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1412
            self.ruleTypePrefix()
            self.state = 1413
            self.match(KerMLv2Parser.K_CLASS)
            self.state = 1414
            self.ruleClassifierDeclaration()
            self.state = 1415
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleStructureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_STRUCT(self):
            return self.getToken(KerMLv2Parser.K_STRUCT, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleStructure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleStructure" ):
                listener.enterRuleStructure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleStructure" ):
                listener.exitRuleStructure(self)




    def ruleStructure(self):

        localctx = KerMLv2Parser.RuleStructureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_ruleStructure)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1417
            self.ruleTypePrefix()
            self.state = 1418
            self.match(KerMLv2Parser.K_STRUCT)
            self.state = 1419
            self.ruleClassifierDeclaration()
            self.state = 1420
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleAssociationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_ASSOC(self):
            return self.getToken(KerMLv2Parser.K_ASSOC, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleAssociation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAssociation" ):
                listener.enterRuleAssociation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAssociation" ):
                listener.exitRuleAssociation(self)




    def ruleAssociation(self):

        localctx = KerMLv2Parser.RuleAssociationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_ruleAssociation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1422
            self.ruleTypePrefix()
            self.state = 1423
            self.match(KerMLv2Parser.K_ASSOC)
            self.state = 1424
            self.ruleClassifierDeclaration()
            self.state = 1425
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleAssociationStructureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_ASSOC(self):
            return self.getToken(KerMLv2Parser.K_ASSOC, 0)

        def K_STRUCT(self):
            return self.getToken(KerMLv2Parser.K_STRUCT, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleAssociationStructure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAssociationStructure" ):
                listener.enterRuleAssociationStructure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAssociationStructure" ):
                listener.exitRuleAssociationStructure(self)




    def ruleAssociationStructure(self):

        localctx = KerMLv2Parser.RuleAssociationStructureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_ruleAssociationStructure)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1427
            self.ruleTypePrefix()
            self.state = 1428
            self.match(KerMLv2Parser.K_ASSOC)
            self.state = 1429
            self.match(KerMLv2Parser.K_STRUCT)
            self.state = 1430
            self.ruleClassifierDeclaration()
            self.state = 1431
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConnectorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def K_CONNECTOR(self):
            return self.getToken(KerMLv2Parser.K_CONNECTOR, 0)

        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def ruleConnectorDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleConnectorDeclarationContext,0)


        def ruleFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDeclarationContext,0)


        def ruleValuePart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleValuePartContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConnector

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConnector" ):
                listener.enterRuleConnector(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConnector" ):
                listener.exitRuleConnector(self)




    def ruleConnector(self):

        localctx = KerMLv2Parser.RuleConnectorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_ruleConnector)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1433
            self.ruleFeaturePrefix()
            self.state = 1434
            self.match(KerMLv2Parser.K_CONNECTOR)
            self.state = 1442
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,157,self._ctx)
            if la_ == 1:
                self.state = 1436
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4433230887403520) != 0) or ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558387233) != 0):
                    self.state = 1435
                    self.ruleFeatureDeclaration()


                self.state = 1439
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & 6917529027641081857) != 0):
                    self.state = 1438
                    self.ruleValuePart()


                pass

            elif la_ == 2:
                self.state = 1441
                self.ruleConnectorDeclaration()
                pass


            self.state = 1444
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConnectorDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConnectorDeclaration

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleConnectorDeclaration1Context(RuleConnectorDeclarationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleConnectorDeclarationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleBinaryConnectorDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleBinaryConnectorDeclarationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConnectorDeclaration1" ):
                listener.enterRuleConnectorDeclaration1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConnectorDeclaration1" ):
                listener.exitRuleConnectorDeclaration1(self)


    class RuleConnectorDeclaration2Context(RuleConnectorDeclarationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleConnectorDeclarationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleNaryConnectorDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNaryConnectorDeclarationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConnectorDeclaration2" ):
                listener.enterRuleConnectorDeclaration2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConnectorDeclaration2" ):
                listener.exitRuleConnectorDeclaration2(self)



    def ruleConnectorDeclaration(self):

        localctx = KerMLv2Parser.RuleConnectorDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_ruleConnectorDeclaration)
        try:
            self.state = 1448
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,158,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleConnectorDeclaration1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1446
                self.ruleBinaryConnectorDeclaration()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleConnectorDeclaration2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1447
                self.ruleNaryConnectorDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBinaryConnectorDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleConnectorEndMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleConnectorEndMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleConnectorEndMemberContext,i)


        def K_TO(self):
            return self.getToken(KerMLv2Parser.K_TO, 0)

        def K_FROM(self):
            return self.getToken(KerMLv2Parser.K_FROM, 0)

        def K_ALL(self):
            return self.getToken(KerMLv2Parser.K_ALL, 0)

        def ruleFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDeclarationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleBinaryConnectorDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBinaryConnectorDeclaration" ):
                listener.enterRuleBinaryConnectorDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBinaryConnectorDeclaration" ):
                listener.exitRuleBinaryConnectorDeclaration(self)




    def ruleBinaryConnectorDeclaration(self):

        localctx = KerMLv2Parser.RuleBinaryConnectorDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_ruleBinaryConnectorDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1458
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,161,self._ctx)
            if la_ == 1:
                self.state = 1451
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4433230887403520) != 0) or ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558387233) != 0):
                    self.state = 1450
                    self.ruleFeatureDeclaration()


                self.state = 1453
                self.match(KerMLv2Parser.K_FROM)

            elif la_ == 2:
                self.state = 1454
                self.match(KerMLv2Parser.K_ALL)
                self.state = 1456
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==2:
                    self.state = 1455
                    self.match(KerMLv2Parser.K_FROM)




            self.state = 1460
            self.ruleConnectorEndMember()
            self.state = 1461
            self.match(KerMLv2Parser.K_TO)
            self.state = 1462
            self.ruleConnectorEndMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNaryConnectorDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(KerMLv2Parser.LPAREN, 0)

        def ruleConnectorEndMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleConnectorEndMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleConnectorEndMemberContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def RPAREN(self):
            return self.getToken(KerMLv2Parser.RPAREN, 0)

        def ruleFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDeclarationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNaryConnectorDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNaryConnectorDeclaration" ):
                listener.enterRuleNaryConnectorDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNaryConnectorDeclaration" ):
                listener.exitRuleNaryConnectorDeclaration(self)




    def ruleNaryConnectorDeclaration(self):

        localctx = KerMLv2Parser.RuleNaryConnectorDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_ruleNaryConnectorDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1465
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4433230887403520) != 0) or ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558387233) != 0):
                self.state = 1464
                self.ruleFeatureDeclaration()


            self.state = 1467
            self.match(KerMLv2Parser.LPAREN)
            self.state = 1468
            self.ruleConnectorEndMember()
            self.state = 1469
            self.match(KerMLv2Parser.OP_COMMA)
            self.state = 1470
            self.ruleConnectorEndMember()
            self.state = 1475
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 1471
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 1472
                self.ruleConnectorEndMember()
                self.state = 1477
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1478
            self.match(KerMLv2Parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConnectorEndMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleConnectorEnd(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleConnectorEndContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConnectorEndMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConnectorEndMember" ):
                listener.enterRuleConnectorEndMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConnectorEndMember" ):
                listener.exitRuleConnectorEndMember(self)




    def ruleConnectorEndMember(self):

        localctx = KerMLv2Parser.RuleConnectorEndMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_ruleConnectorEndMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1480
            self.ruleConnectorEnd()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConnectorEndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedReferenceSubsetting(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedReferenceSubsettingContext,0)


        def ruleName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNameContext,0)


        def ruleReferencesKeyword(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleReferencesKeywordContext,0)


        def ruleOwnedMultiplicity(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedMultiplicityContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConnectorEnd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConnectorEnd" ):
                listener.enterRuleConnectorEnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConnectorEnd" ):
                listener.exitRuleConnectorEnd(self)




    def ruleConnectorEnd(self):

        localctx = KerMLv2Parser.RuleConnectorEndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_ruleConnectorEnd)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1485
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,164,self._ctx)
            if la_ == 1:
                self.state = 1482
                self.ruleName()
                self.state = 1483
                self.ruleReferencesKeyword()


            self.state = 1487
            self.ruleOwnedReferenceSubsetting()
            self.state = 1489
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==105:
                self.state = 1488
                self.ruleOwnedMultiplicity()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBindingConnectorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def K_BINDING(self):
            return self.getToken(KerMLv2Parser.K_BINDING, 0)

        def ruleBindingConnectorDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleBindingConnectorDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleBindingConnector

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBindingConnector" ):
                listener.enterRuleBindingConnector(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBindingConnector" ):
                listener.exitRuleBindingConnector(self)




    def ruleBindingConnector(self):

        localctx = KerMLv2Parser.RuleBindingConnectorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_ruleBindingConnector)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1491
            self.ruleFeaturePrefix()
            self.state = 1492
            self.match(KerMLv2Parser.K_BINDING)
            self.state = 1493
            self.ruleBindingConnectorDeclaration()
            self.state = 1494
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBindingConnectorDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleBindingConnectorDeclaration

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleBindingConnectorDeclaration1Context(RuleBindingConnectorDeclarationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBindingConnectorDeclarationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDeclarationContext,0)

        def K_OF(self):
            return self.getToken(KerMLv2Parser.K_OF, 0)
        def ruleConnectorEndMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleConnectorEndMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleConnectorEndMemberContext,i)

        def OP_EQ(self):
            return self.getToken(KerMLv2Parser.OP_EQ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBindingConnectorDeclaration1" ):
                listener.enterRuleBindingConnectorDeclaration1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBindingConnectorDeclaration1" ):
                listener.exitRuleBindingConnectorDeclaration1(self)


    class RuleBindingConnectorDeclaration2Context(RuleBindingConnectorDeclarationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBindingConnectorDeclarationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_ALL(self):
            return self.getToken(KerMLv2Parser.K_ALL, 0)
        def ruleConnectorEndMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleConnectorEndMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleConnectorEndMemberContext,i)

        def OP_EQ(self):
            return self.getToken(KerMLv2Parser.OP_EQ, 0)
        def K_OF(self):
            return self.getToken(KerMLv2Parser.K_OF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBindingConnectorDeclaration2" ):
                listener.enterRuleBindingConnectorDeclaration2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBindingConnectorDeclaration2" ):
                listener.exitRuleBindingConnectorDeclaration2(self)



    def ruleBindingConnectorDeclaration(self):

        localctx = KerMLv2Parser.RuleBindingConnectorDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_ruleBindingConnectorDeclaration)
        self._la = 0 # Token type
        try:
            self.state = 1516
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,170,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleBindingConnectorDeclaration1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1496
                self.ruleFeatureDeclaration()
                self.state = 1502
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43:
                    self.state = 1497
                    self.match(KerMLv2Parser.K_OF)
                    self.state = 1498
                    self.ruleConnectorEndMember()
                    self.state = 1499
                    self.match(KerMLv2Parser.OP_EQ)
                    self.state = 1500
                    self.ruleConnectorEndMember()


                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleBindingConnectorDeclaration2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1505
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==14:
                    self.state = 1504
                    self.match(KerMLv2Parser.K_ALL)


                self.state = 1514
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43 or _la==144 or _la==145:
                    self.state = 1508
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==43:
                        self.state = 1507
                        self.match(KerMLv2Parser.K_OF)


                    self.state = 1510
                    self.ruleConnectorEndMember()
                    self.state = 1511
                    self.match(KerMLv2Parser.OP_EQ)
                    self.state = 1512
                    self.ruleConnectorEndMember()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSuccessionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def K_SUCCESSION(self):
            return self.getToken(KerMLv2Parser.K_SUCCESSION, 0)

        def ruleSuccessionDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSuccessionDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSuccession

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSuccession" ):
                listener.enterRuleSuccession(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSuccession" ):
                listener.exitRuleSuccession(self)




    def ruleSuccession(self):

        localctx = KerMLv2Parser.RuleSuccessionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_ruleSuccession)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1518
            self.ruleFeaturePrefix()
            self.state = 1519
            self.match(KerMLv2Parser.K_SUCCESSION)
            self.state = 1520
            self.ruleSuccessionDeclaration()
            self.state = 1521
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSuccessionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSuccessionDeclaration

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleSuccessionDeclaration2Context(RuleSuccessionDeclarationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleSuccessionDeclarationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_ALL(self):
            return self.getToken(KerMLv2Parser.K_ALL, 0)
        def ruleConnectorEndMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleConnectorEndMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleConnectorEndMemberContext,i)

        def K_THEN(self):
            return self.getToken(KerMLv2Parser.K_THEN, 0)
        def K_FIRST(self):
            return self.getToken(KerMLv2Parser.K_FIRST, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSuccessionDeclaration2" ):
                listener.enterRuleSuccessionDeclaration2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSuccessionDeclaration2" ):
                listener.exitRuleSuccessionDeclaration2(self)


    class RuleSuccessionDeclaration1Context(RuleSuccessionDeclarationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleSuccessionDeclarationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDeclarationContext,0)

        def K_FIRST(self):
            return self.getToken(KerMLv2Parser.K_FIRST, 0)
        def ruleConnectorEndMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleConnectorEndMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleConnectorEndMemberContext,i)

        def K_THEN(self):
            return self.getToken(KerMLv2Parser.K_THEN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSuccessionDeclaration1" ):
                listener.enterRuleSuccessionDeclaration1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSuccessionDeclaration1" ):
                listener.exitRuleSuccessionDeclaration1(self)



    def ruleSuccessionDeclaration(self):

        localctx = KerMLv2Parser.RuleSuccessionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_ruleSuccessionDeclaration)
        self._la = 0 # Token type
        try:
            self.state = 1543
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,175,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleSuccessionDeclaration1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1523
                self.ruleFeatureDeclaration()
                self.state = 1529
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==66:
                    self.state = 1524
                    self.match(KerMLv2Parser.K_FIRST)
                    self.state = 1525
                    self.ruleConnectorEndMember()
                    self.state = 1526
                    self.match(KerMLv2Parser.K_THEN)
                    self.state = 1527
                    self.ruleConnectorEndMember()


                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleSuccessionDeclaration2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1532
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==14:
                    self.state = 1531
                    self.match(KerMLv2Parser.K_ALL)


                self.state = 1541
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==66 or _la==144 or _la==145:
                    self.state = 1535
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==66:
                        self.state = 1534
                        self.match(KerMLv2Parser.K_FIRST)


                    self.state = 1537
                    self.ruleConnectorEndMember()
                    self.state = 1538
                    self.match(KerMLv2Parser.K_THEN)
                    self.state = 1539
                    self.ruleConnectorEndMember()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBehaviorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_BEHAVIOR(self):
            return self.getToken(KerMLv2Parser.K_BEHAVIOR, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleBehavior

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBehavior" ):
                listener.enterRuleBehavior(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBehavior" ):
                listener.exitRuleBehavior(self)




    def ruleBehavior(self):

        localctx = KerMLv2Parser.RuleBehaviorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_ruleBehavior)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1545
            self.ruleTypePrefix()
            self.state = 1546
            self.match(KerMLv2Parser.K_BEHAVIOR)
            self.state = 1547
            self.ruleClassifierDeclaration()
            self.state = 1548
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleStepContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def K_STEP(self):
            return self.getToken(KerMLv2Parser.K_STEP, 0)

        def ruleStepDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleStepDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleStep

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleStep" ):
                listener.enterRuleStep(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleStep" ):
                listener.exitRuleStep(self)




    def ruleStep(self):

        localctx = KerMLv2Parser.RuleStepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_ruleStep)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1550
            self.ruleFeaturePrefix()
            self.state = 1551
            self.match(KerMLv2Parser.K_STEP)
            self.state = 1552
            self.ruleStepDeclaration()
            self.state = 1553
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleStepDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDeclarationContext,0)


        def ruleValuePart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleValuePartContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleStepDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleStepDeclaration" ):
                listener.enterRuleStepDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleStepDeclaration" ):
                listener.exitRuleStepDeclaration(self)




    def ruleStepDeclaration(self):

        localctx = KerMLv2Parser.RuleStepDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_ruleStepDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1556
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4433230887403520) != 0) or ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558387233) != 0):
                self.state = 1555
                self.ruleFeatureDeclaration()


            self.state = 1559
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & 6917529027641081857) != 0):
                self.state = 1558
                self.ruleValuePart()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_FUNCTION(self):
            return self.getToken(KerMLv2Parser.K_FUNCTION, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleFunctionBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFunction" ):
                listener.enterRuleFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFunction" ):
                listener.exitRuleFunction(self)




    def ruleFunction(self):

        localctx = KerMLv2Parser.RuleFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_ruleFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1561
            self.ruleTypePrefix()
            self.state = 1562
            self.match(KerMLv2Parser.K_FUNCTION)
            self.state = 1563
            self.ruleClassifierDeclaration()
            self.state = 1564
            self.ruleFunctionBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFunctionBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFunctionBody

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFunctionBody2Context(RuleFunctionBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFunctionBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACE(self):
            return self.getToken(KerMLv2Parser.LBRACE, 0)
        def ruleFunctionBodyPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionBodyPartContext,0)

        def RBRACE(self):
            return self.getToken(KerMLv2Parser.RBRACE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFunctionBody2" ):
                listener.enterRuleFunctionBody2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFunctionBody2" ):
                listener.exitRuleFunctionBody2(self)


    class RuleFunctionBody1Context(RuleFunctionBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFunctionBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_SEMI(self):
            return self.getToken(KerMLv2Parser.OP_SEMI, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFunctionBody1" ):
                listener.enterRuleFunctionBody1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFunctionBody1" ):
                listener.exitRuleFunctionBody1(self)



    def ruleFunctionBody(self):

        localctx = KerMLv2Parser.RuleFunctionBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_ruleFunctionBody)
        try:
            self.state = 1571
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [108]:
                localctx = KerMLv2Parser.RuleFunctionBody1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1566
                self.match(KerMLv2Parser.OP_SEMI)
                pass
            elif token in [102]:
                localctx = KerMLv2Parser.RuleFunctionBody2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1567
                self.match(KerMLv2Parser.LBRACE)
                self.state = 1568
                self.ruleFunctionBodyPart()
                self.state = 1569
                self.match(KerMLv2Parser.RBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFunctionBodyPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleNonFeatureMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNonFeatureMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNonFeatureMemberContext,i)


        def ruleFeatureMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFeatureMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureMemberContext,i)


        def ruleAliasMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAliasMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAliasMemberContext,i)


        def ruleImport(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleImportContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleImportContext,i)


        def ruleReturnFeatureMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleReturnFeatureMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleReturnFeatureMemberContext,i)


        def ruleResultExpressionMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleResultExpressionMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFunctionBodyPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFunctionBodyPart" ):
                listener.enterRuleFunctionBodyPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFunctionBodyPart" ):
                listener.exitRuleFunctionBodyPart(self)




    def ruleFunctionBodyPart(self):

        localctx = KerMLv2Parser.RuleFunctionBodyPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_ruleFunctionBodyPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1580
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,180,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1578
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
                    if la_ == 1:
                        self.state = 1573
                        self.ruleNonFeatureMember()
                        pass

                    elif la_ == 2:
                        self.state = 1574
                        self.ruleFeatureMember()
                        pass

                    elif la_ == 3:
                        self.state = 1575
                        self.ruleAliasMember()
                        pass

                    elif la_ == 4:
                        self.state = 1576
                        self.ruleImport()
                        pass

                    elif la_ == 5:
                        self.state = 1577
                        self.ruleReturnFeatureMember()
                        pass

             
                self.state = 1582
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,180,self._ctx)

            self.state = 1584
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 14)) & ~0x3f) == 0 and ((1 << (_la - 14)) & -4611686018427387903) != 0) or ((((_la - 83)) & ~0x3f) == 0 and ((1 << (_la - 83)) & -562948576338493727) != 0):
                self.state = 1583
                self.ruleResultExpressionMember()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleReturnFeatureMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMemberPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMemberPrefixContext,0)


        def K_RETURN(self):
            return self.getToken(KerMLv2Parser.K_RETURN, 0)

        def ruleFeatureElement(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureElementContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleReturnFeatureMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleReturnFeatureMember" ):
                listener.enterRuleReturnFeatureMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleReturnFeatureMember" ):
                listener.exitRuleReturnFeatureMember(self)




    def ruleReturnFeatureMember(self):

        localctx = KerMLv2Parser.RuleReturnFeatureMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_ruleReturnFeatureMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1586
            self.ruleMemberPrefix()
            self.state = 1587
            self.match(KerMLv2Parser.K_RETURN)
            self.state = 1588
            self.ruleFeatureElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleResultExpressionMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMemberPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMemberPrefixContext,0)


        def ruleOwnedExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleResultExpressionMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleResultExpressionMember" ):
                listener.enterRuleResultExpressionMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleResultExpressionMember" ):
                listener.exitRuleResultExpressionMember(self)




    def ruleResultExpressionMember(self):

        localctx = KerMLv2Parser.RuleResultExpressionMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_ruleResultExpressionMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1590
            self.ruleMemberPrefix()
            self.state = 1591
            self.ruleOwnedExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def K_EXPR(self):
            return self.getToken(KerMLv2Parser.K_EXPR, 0)

        def ruleExpressionDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExpressionDeclarationContext,0)


        def ruleFunctionBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleExpression" ):
                listener.enterRuleExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleExpression" ):
                listener.exitRuleExpression(self)




    def ruleExpression(self):

        localctx = KerMLv2Parser.RuleExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_ruleExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1593
            self.ruleFeaturePrefix()
            self.state = 1594
            self.match(KerMLv2Parser.K_EXPR)
            self.state = 1595
            self.ruleExpressionDeclaration()
            self.state = 1596
            self.ruleFunctionBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleExpressionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDeclarationContext,0)


        def ruleValuePart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleValuePartContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleExpressionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleExpressionDeclaration" ):
                listener.enterRuleExpressionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleExpressionDeclaration" ):
                listener.exitRuleExpressionDeclaration(self)




    def ruleExpressionDeclaration(self):

        localctx = KerMLv2Parser.RuleExpressionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_ruleExpressionDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1599
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4433230887403520) != 0) or ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558387233) != 0):
                self.state = 1598
                self.ruleFeatureDeclaration()


            self.state = 1602
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & 6917529027641081857) != 0):
                self.state = 1601
                self.ruleValuePart()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulePredicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_PREDICATE(self):
            return self.getToken(KerMLv2Parser.K_PREDICATE, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleFunctionBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_rulePredicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePredicate" ):
                listener.enterRulePredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePredicate" ):
                listener.exitRulePredicate(self)




    def rulePredicate(self):

        localctx = KerMLv2Parser.RulePredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_rulePredicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1604
            self.ruleTypePrefix()
            self.state = 1605
            self.match(KerMLv2Parser.K_PREDICATE)
            self.state = 1606
            self.ruleClassifierDeclaration()
            self.state = 1607
            self.ruleFunctionBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBooleanExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def K_BOOL(self):
            return self.getToken(KerMLv2Parser.K_BOOL, 0)

        def ruleExpressionDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExpressionDeclarationContext,0)


        def ruleFunctionBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleBooleanExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBooleanExpression" ):
                listener.enterRuleBooleanExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBooleanExpression" ):
                listener.exitRuleBooleanExpression(self)




    def ruleBooleanExpression(self):

        localctx = KerMLv2Parser.RuleBooleanExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_ruleBooleanExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1609
            self.ruleFeaturePrefix()
            self.state = 1610
            self.match(KerMLv2Parser.K_BOOL)
            self.state = 1611
            self.ruleExpressionDeclaration()
            self.state = 1612
            self.ruleFunctionBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleInvariantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def K_INV(self):
            return self.getToken(KerMLv2Parser.K_INV, 0)

        def ruleExpressionDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExpressionDeclarationContext,0)


        def ruleFunctionBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionBodyContext,0)


        def K_TRUE(self):
            return self.getToken(KerMLv2Parser.K_TRUE, 0)

        def K_FALSE(self):
            return self.getToken(KerMLv2Parser.K_FALSE, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleInvariant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleInvariant" ):
                listener.enterRuleInvariant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleInvariant" ):
                listener.exitRuleInvariant(self)




    def ruleInvariant(self):

        localctx = KerMLv2Parser.RuleInvariantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_ruleInvariant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1614
            self.ruleFeaturePrefix()
            self.state = 1615
            self.match(KerMLv2Parser.K_INV)
            self.state = 1617
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==76 or _la==77:
                self.state = 1616
                _la = self._input.LA(1)
                if not(_la==76 or _la==77):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1619
            self.ruleExpressionDeclaration()
            self.state = 1620
            self.ruleFunctionBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleInteractionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_INTERACTION(self):
            return self.getToken(KerMLv2Parser.K_INTERACTION, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleInteraction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleInteraction" ):
                listener.enterRuleInteraction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleInteraction" ):
                listener.exitRuleInteraction(self)




    def ruleInteraction(self):

        localctx = KerMLv2Parser.RuleInteractionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_ruleInteraction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1622
            self.ruleTypePrefix()
            self.state = 1623
            self.match(KerMLv2Parser.K_INTERACTION)
            self.state = 1624
            self.ruleClassifierDeclaration()
            self.state = 1625
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFlowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def K_FLOW(self):
            return self.getToken(KerMLv2Parser.K_FLOW, 0)

        def ruleItemFlowDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFlow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlow" ):
                listener.enterRuleItemFlow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlow" ):
                listener.exitRuleItemFlow(self)




    def ruleItemFlow(self):

        localctx = KerMLv2Parser.RuleItemFlowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_ruleItemFlow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1627
            self.ruleFeaturePrefix()
            self.state = 1628
            self.match(KerMLv2Parser.K_FLOW)
            self.state = 1629
            self.ruleItemFlowDeclaration()
            self.state = 1630
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSuccessionItemFlowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeaturePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeaturePrefixContext,0)


        def K_SUCCESSION(self):
            return self.getToken(KerMLv2Parser.K_SUCCESSION, 0)

        def K_FLOW(self):
            return self.getToken(KerMLv2Parser.K_FLOW, 0)

        def ruleItemFlowDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSuccessionItemFlow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSuccessionItemFlow" ):
                listener.enterRuleSuccessionItemFlow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSuccessionItemFlow" ):
                listener.exitRuleSuccessionItemFlow(self)




    def ruleSuccessionItemFlow(self):

        localctx = KerMLv2Parser.RuleSuccessionItemFlowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_ruleSuccessionItemFlow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1632
            self.ruleFeaturePrefix()
            self.state = 1633
            self.match(KerMLv2Parser.K_SUCCESSION)
            self.state = 1634
            self.match(KerMLv2Parser.K_FLOW)
            self.state = 1635
            self.ruleItemFlowDeclaration()
            self.state = 1636
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFlowDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFlowDeclaration

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleItemFlowDeclaration1Context(RuleItemFlowDeclarationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFlowDeclarationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureDeclarationContext,0)

        def ruleValuePart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleValuePartContext,0)

        def K_OF(self):
            return self.getToken(KerMLv2Parser.K_OF, 0)
        def ruleItemFeatureMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFeatureMemberContext,0)

        def K_FROM(self):
            return self.getToken(KerMLv2Parser.K_FROM, 0)
        def ruleItemFlowEndMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleItemFlowEndMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowEndMemberContext,i)

        def K_TO(self):
            return self.getToken(KerMLv2Parser.K_TO, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlowDeclaration1" ):
                listener.enterRuleItemFlowDeclaration1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlowDeclaration1" ):
                listener.exitRuleItemFlowDeclaration1(self)


    class RuleItemFlowDeclaration2Context(RuleItemFlowDeclarationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFlowDeclarationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleItemFlowEndMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleItemFlowEndMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowEndMemberContext,i)

        def K_TO(self):
            return self.getToken(KerMLv2Parser.K_TO, 0)
        def K_ALL(self):
            return self.getToken(KerMLv2Parser.K_ALL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlowDeclaration2" ):
                listener.enterRuleItemFlowDeclaration2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlowDeclaration2" ):
                listener.exitRuleItemFlowDeclaration2(self)



    def ruleItemFlowDeclaration(self):

        localctx = KerMLv2Parser.RuleItemFlowDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_ruleItemFlowDeclaration)
        self._la = 0 # Token type
        try:
            self.state = 1662
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleItemFlowDeclaration1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1639
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4433230887403520) != 0) or ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558387233) != 0):
                    self.state = 1638
                    self.ruleFeatureDeclaration()


                self.state = 1642
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & 6917529027641081857) != 0):
                    self.state = 1641
                    self.ruleValuePart()


                self.state = 1646
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43:
                    self.state = 1644
                    self.match(KerMLv2Parser.K_OF)
                    self.state = 1645
                    self.ruleItemFeatureMember()


                self.state = 1653
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==2:
                    self.state = 1648
                    self.match(KerMLv2Parser.K_FROM)
                    self.state = 1649
                    self.ruleItemFlowEndMember()
                    self.state = 1650
                    self.match(KerMLv2Parser.K_TO)
                    self.state = 1651
                    self.ruleItemFlowEndMember()


                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleItemFlowDeclaration2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1656
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==14:
                    self.state = 1655
                    self.match(KerMLv2Parser.K_ALL)


                self.state = 1658
                self.ruleItemFlowEndMember()
                self.state = 1659
                self.match(KerMLv2Parser.K_TO)
                self.state = 1660
                self.ruleItemFlowEndMember()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFeatureMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleItemFeature(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFeatureContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFeatureMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFeatureMember" ):
                listener.enterRuleItemFeatureMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFeatureMember" ):
                listener.exitRuleItemFeatureMember(self)




    def ruleItemFeatureMember(self):

        localctx = KerMLv2Parser.RuleItemFeatureMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_ruleItemFeatureMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1664
            self.ruleItemFeature()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFeatureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFeature

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleItemFeature3Context(RuleItemFeatureContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFeatureContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureTyping(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureTypingContext,0)

        def ruleOwnedMultiplicity(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedMultiplicityContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFeature3" ):
                listener.enterRuleItemFeature3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFeature3" ):
                listener.exitRuleItemFeature3(self)


    class RuleItemFeature4Context(RuleItemFeatureContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFeatureContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedMultiplicity(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedMultiplicityContext,0)

        def ruleOwnedFeatureTyping(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureTypingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFeature4" ):
                listener.enterRuleItemFeature4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFeature4" ):
                listener.exitRuleItemFeature4(self)


    class RuleItemFeature1Context(RuleItemFeatureContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFeatureContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleItemFeatureSpecializationPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFeatureSpecializationPartContext,0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)

        def ruleValuePart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleValuePartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFeature1" ):
                listener.enterRuleItemFeature1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFeature1" ):
                listener.exitRuleItemFeature1(self)


    class RuleItemFeature2Context(RuleItemFeatureContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFeatureContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleValuePart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleValuePartContext,0)

        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFeature2" ):
                listener.enterRuleItemFeature2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFeature2" ):
                listener.exitRuleItemFeature2(self)



    def ruleItemFeature(self):

        localctx = KerMLv2Parser.RuleItemFeatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_ruleItemFeature)
        self._la = 0 # Token type
        try:
            self.state = 1684
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,195,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleItemFeature1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1667
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 1666
                    self.ruleIdentification()


                self.state = 1669
                self.ruleItemFeatureSpecializationPart()
                self.state = 1671
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & 6917529027641081857) != 0):
                    self.state = 1670
                    self.ruleValuePart()


                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleItemFeature2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1674
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 52776558133249) != 0):
                    self.state = 1673
                    self.ruleIdentification()


                self.state = 1676
                self.ruleValuePart()
                pass

            elif la_ == 3:
                localctx = KerMLv2Parser.RuleItemFeature3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1677
                self.ruleOwnedFeatureTyping()
                self.state = 1679
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==105:
                    self.state = 1678
                    self.ruleOwnedMultiplicity()


                pass

            elif la_ == 4:
                localctx = KerMLv2Parser.RuleItemFeature4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1681
                self.ruleOwnedMultiplicity()
                self.state = 1682
                self.ruleOwnedFeatureTyping()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFeatureSpecializationPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFeatureSpecializationPart

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleItemFeatureSpecializationPart2Context(RuleItemFeatureSpecializationPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFeatureSpecializationPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMultiplicityPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicityPartContext,0)

        def ruleFeatureSpecialization(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFeatureSpecializationContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureSpecializationContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFeatureSpecializationPart2" ):
                listener.enterRuleItemFeatureSpecializationPart2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFeatureSpecializationPart2" ):
                listener.exitRuleItemFeatureSpecializationPart2(self)


    class RuleItemFeatureSpecializationPart1Context(RuleItemFeatureSpecializationPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFeatureSpecializationPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureSpecialization(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFeatureSpecializationContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureSpecializationContext,i)

        def ruleMultiplicityPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicityPartContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFeatureSpecializationPart1" ):
                listener.enterRuleItemFeatureSpecializationPart1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFeatureSpecializationPart1" ):
                listener.exitRuleItemFeatureSpecializationPart1(self)



    def ruleItemFeatureSpecializationPart(self):

        localctx = KerMLv2Parser.RuleItemFeatureSpecializationPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_ruleItemFeatureSpecializationPart)
        self._la = 0 # Token type
        try:
            self.state = 1706
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48, 49, 50, 51, 113, 115, 116, 117]:
                localctx = KerMLv2Parser.RuleItemFeatureSpecializationPart1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1687 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1686
                        self.ruleFeatureSpecialization()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1689 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,196,self._ctx)

                self.state = 1692
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 46)) & ~0x3f) == 0 and ((1 << (_la - 46)) & 576460752303423491) != 0):
                    self.state = 1691
                    self.ruleMultiplicityPart()


                self.state = 1697
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4222124650659840) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 29) != 0):
                    self.state = 1694
                    self.ruleFeatureSpecialization()
                    self.state = 1699
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [46, 47, 105]:
                localctx = KerMLv2Parser.RuleItemFeatureSpecializationPart2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1700
                self.ruleMultiplicityPart()
                self.state = 1702 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1701
                    self.ruleFeatureSpecialization()
                    self.state = 1704 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4222124650659840) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 29) != 0)):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFlowEndMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleItemFlowEnd(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowEndContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFlowEndMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlowEndMember" ):
                listener.enterRuleItemFlowEndMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlowEndMember" ):
                listener.exitRuleItemFlowEndMember(self)




    def ruleItemFlowEndMember(self):

        localctx = KerMLv2Parser.RuleItemFlowEndMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_ruleItemFlowEndMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1708
            self.ruleItemFlowEnd()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFlowEndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleItemFlowFeatureMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowFeatureMemberContext,0)


        def ruleItemFlowEndSubsetting(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowEndSubsettingContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFlowEnd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlowEnd" ):
                listener.enterRuleItemFlowEnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlowEnd" ):
                listener.exitRuleItemFlowEnd(self)




    def ruleItemFlowEnd(self):

        localctx = KerMLv2Parser.RuleItemFlowEndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_ruleItemFlowEnd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1711
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,201,self._ctx)
            if la_ == 1:
                self.state = 1710
                self.ruleItemFlowEndSubsetting()


            self.state = 1713
            self.ruleItemFlowFeatureMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFlowEndSubsettingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFlowEndSubsetting

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleItemFlowEndSubsetting1Context(RuleItemFlowEndSubsettingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFlowEndSubsettingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)

        def OP_DOT(self):
            return self.getToken(KerMLv2Parser.OP_DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlowEndSubsetting1" ):
                listener.enterRuleItemFlowEndSubsetting1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlowEndSubsetting1" ):
                listener.exitRuleItemFlowEndSubsetting1(self)


    class RuleItemFlowEndSubsetting2Context(RuleItemFlowEndSubsettingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleItemFlowEndSubsettingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureChainPrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureChainPrefixContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlowEndSubsetting2" ):
                listener.enterRuleItemFlowEndSubsetting2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlowEndSubsetting2" ):
                listener.exitRuleItemFlowEndSubsetting2(self)



    def ruleItemFlowEndSubsetting(self):

        localctx = KerMLv2Parser.RuleItemFlowEndSubsettingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_ruleItemFlowEndSubsetting)
        try:
            self.state = 1719
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,202,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleItemFlowEndSubsetting1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1715
                self.ruleQualifiedName()
                self.state = 1716
                self.match(KerMLv2Parser.OP_DOT)
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleItemFlowEndSubsetting2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1718
                self.ruleFeatureChainPrefix()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureChainPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedFeatureChaining(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedFeatureChainingContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainingContext,i)


        def OP_DOT(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_DOT)
            else:
                return self.getToken(KerMLv2Parser.OP_DOT, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureChainPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureChainPrefix" ):
                listener.enterRuleFeatureChainPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureChainPrefix" ):
                listener.exitRuleFeatureChainPrefix(self)




    def ruleFeatureChainPrefix(self):

        localctx = KerMLv2Parser.RuleFeatureChainPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_ruleFeatureChainPrefix)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1724 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1721
                    self.ruleOwnedFeatureChaining()
                    self.state = 1722
                    self.match(KerMLv2Parser.OP_DOT)

                else:
                    raise NoViableAltException(self)
                self.state = 1726 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,203,self._ctx)

            self.state = 1728
            self.ruleOwnedFeatureChaining()
            self.state = 1729
            self.match(KerMLv2Parser.OP_DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFlowFeatureMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleItemFlowFeature(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowFeatureContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFlowFeatureMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlowFeatureMember" ):
                listener.enterRuleItemFlowFeatureMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlowFeatureMember" ):
                listener.exitRuleItemFlowFeatureMember(self)




    def ruleItemFlowFeatureMember(self):

        localctx = KerMLv2Parser.RuleItemFlowFeatureMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_ruleItemFlowFeatureMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1731
            self.ruleItemFlowFeature()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFlowFeatureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleItemFlowRedefinition(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleItemFlowRedefinitionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFlowFeature

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlowFeature" ):
                listener.enterRuleItemFlowFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlowFeature" ):
                listener.exitRuleItemFlowFeature(self)




    def ruleItemFlowFeature(self):

        localctx = KerMLv2Parser.RuleItemFlowFeatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_ruleItemFlowFeature)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1733
            self.ruleItemFlowRedefinition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleItemFlowRedefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleItemFlowRedefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleItemFlowRedefinition" ):
                listener.enterRuleItemFlowRedefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleItemFlowRedefinition" ):
                listener.exitRuleItemFlowRedefinition(self)




    def ruleItemFlowRedefinition(self):

        localctx = KerMLv2Parser.RuleItemFlowRedefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_ruleItemFlowRedefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1735
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetaclassContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypePrefix(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypePrefixContext,0)


        def K_METACLASS(self):
            return self.getToken(KerMLv2Parser.K_METACLASS, 0)

        def ruleClassifierDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassifierDeclarationContext,0)


        def ruleTypeBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetaclass

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetaclass" ):
                listener.enterRuleMetaclass(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetaclass" ):
                listener.exitRuleMetaclass(self)




    def ruleMetaclass(self):

        localctx = KerMLv2Parser.RuleMetaclassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_ruleMetaclass)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1737
            self.ruleTypePrefix()
            self.state = 1738
            self.match(KerMLv2Parser.K_METACLASS)
            self.state = 1739
            self.ruleClassifierDeclaration()
            self.state = 1740
            self.ruleTypeBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulePrefixMetadataAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP_HASH(self):
            return self.getToken(KerMLv2Parser.OP_HASH, 0)

        def rulePrefixMetadataFeature(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataFeatureContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_rulePrefixMetadataAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePrefixMetadataAnnotation" ):
                listener.enterRulePrefixMetadataAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePrefixMetadataAnnotation" ):
                listener.exitRulePrefixMetadataAnnotation(self)




    def rulePrefixMetadataAnnotation(self):

        localctx = KerMLv2Parser.RulePrefixMetadataAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_rulePrefixMetadataAnnotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1742
            self.match(KerMLv2Parser.OP_HASH)
            self.state = 1743
            self.rulePrefixMetadataFeature()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulePrefixMetadataMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP_HASH(self):
            return self.getToken(KerMLv2Parser.OP_HASH, 0)

        def rulePrefixMetadataFeature(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataFeatureContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_rulePrefixMetadataMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePrefixMetadataMember" ):
                listener.enterRulePrefixMetadataMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePrefixMetadataMember" ):
                listener.exitRulePrefixMetadataMember(self)




    def rulePrefixMetadataMember(self):

        localctx = KerMLv2Parser.RulePrefixMetadataMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_rulePrefixMetadataMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1745
            self.match(KerMLv2Parser.OP_HASH)
            self.state = 1746
            self.rulePrefixMetadataFeature()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulePrefixMetadataFeatureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMetadataTyping(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataTypingContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_rulePrefixMetadataFeature

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePrefixMetadataFeature" ):
                listener.enterRulePrefixMetadataFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePrefixMetadataFeature" ):
                listener.exitRulePrefixMetadataFeature(self)




    def rulePrefixMetadataFeature(self):

        localctx = KerMLv2Parser.RulePrefixMetadataFeatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_rulePrefixMetadataFeature)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1748
            self.ruleMetadataTyping()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetadataFeatureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMetadataFeatureDeclaration(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataFeatureDeclarationContext,0)


        def ruleMetadataBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataBodyContext,0)


        def OP_AT(self):
            return self.getToken(KerMLv2Parser.OP_AT, 0)

        def K_METADATA(self):
            return self.getToken(KerMLv2Parser.K_METADATA, 0)

        def rulePrefixMetadataMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RulePrefixMetadataMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RulePrefixMetadataMemberContext,i)


        def K_ABOUT(self):
            return self.getToken(KerMLv2Parser.K_ABOUT, 0)

        def ruleAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAnnotationContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAnnotationContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetadataFeature

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetadataFeature" ):
                listener.enterRuleMetadataFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetadataFeature" ):
                listener.exitRuleMetadataFeature(self)




    def ruleMetadataFeature(self):

        localctx = KerMLv2Parser.RuleMetadataFeatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_ruleMetadataFeature)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1753
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==122:
                self.state = 1750
                self.rulePrefixMetadataMember()
                self.state = 1755
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1756
            _la = self._input.LA(1)
            if not(_la==81 or _la==123):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1757
            self.ruleMetadataFeatureDeclaration()
            self.state = 1767
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==5:
                self.state = 1758
                self.match(KerMLv2Parser.K_ABOUT)
                self.state = 1759
                self.ruleAnnotation()
                self.state = 1764
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==109:
                    self.state = 1760
                    self.match(KerMLv2Parser.OP_COMMA)
                    self.state = 1761
                    self.ruleAnnotation()
                    self.state = 1766
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1769
            self.ruleMetadataBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetadataFeatureDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMetadataTyping(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataTypingContext,0)


        def ruleIdentification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleIdentificationContext,0)


        def OP_COLON(self):
            return self.getToken(KerMLv2Parser.OP_COLON, 0)

        def K_TYPED(self):
            return self.getToken(KerMLv2Parser.K_TYPED, 0)

        def K_BY(self):
            return self.getToken(KerMLv2Parser.K_BY, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetadataFeatureDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetadataFeatureDeclaration" ):
                listener.enterRuleMetadataFeatureDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetadataFeatureDeclaration" ):
                listener.exitRuleMetadataFeatureDeclaration(self)




    def ruleMetadataFeatureDeclaration(self):

        localctx = KerMLv2Parser.RuleMetadataFeatureDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_ruleMetadataFeatureDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1777
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
            if la_ == 1:
                self.state = 1771
                self.ruleIdentification()
                self.state = 1775
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [115]:
                    self.state = 1772
                    self.match(KerMLv2Parser.OP_COLON)
                    pass
                elif token in [48]:
                    self.state = 1773
                    self.match(KerMLv2Parser.K_TYPED)
                    self.state = 1774
                    self.match(KerMLv2Parser.K_BY)
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 1779
            self.ruleMetadataTyping()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetadataTypingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetadataTyping

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetadataTyping" ):
                listener.enterRuleMetadataTyping(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetadataTyping" ):
                listener.exitRuleMetadataTyping(self)




    def ruleMetadataTyping(self):

        localctx = KerMLv2Parser.RuleMetadataTypingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_ruleMetadataTyping)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1781
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetadataBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetadataBody

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleMetadataBody2Context(RuleMetadataBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMetadataBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACE(self):
            return self.getToken(KerMLv2Parser.LBRACE, 0)
        def RBRACE(self):
            return self.getToken(KerMLv2Parser.RBRACE, 0)
        def ruleNonFeatureMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNonFeatureMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNonFeatureMemberContext,i)

        def ruleMetadataBodyFeatureMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleMetadataBodyFeatureMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataBodyFeatureMemberContext,i)

        def ruleAliasMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAliasMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAliasMemberContext,i)

        def ruleImport(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleImportContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleImportContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetadataBody2" ):
                listener.enterRuleMetadataBody2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetadataBody2" ):
                listener.exitRuleMetadataBody2(self)


    class RuleMetadataBody1Context(RuleMetadataBodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMetadataBodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_SEMI(self):
            return self.getToken(KerMLv2Parser.OP_SEMI, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetadataBody1" ):
                listener.enterRuleMetadataBody1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetadataBody1" ):
                listener.exitRuleMetadataBody1(self)



    def ruleMetadataBody(self):

        localctx = KerMLv2Parser.RuleMetadataBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_ruleMetadataBody)
        self._la = 0 # Token type
        try:
            self.state = 1795
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [108]:
                localctx = KerMLv2Parser.RuleMetadataBody1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1783
                self.match(KerMLv2Parser.OP_SEMI)
                pass
            elif token in [102]:
                localctx = KerMLv2Parser.RuleMetadataBody2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1784
                self.match(KerMLv2Parser.LBRACE)
                self.state = 1791
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 9077010580624879570) != 0) or ((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 54606145951642661) != 0) or ((((_la - 144)) & ~0x3f) == 0 and ((1 << (_la - 144)) & 11) != 0):
                    self.state = 1789
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,209,self._ctx)
                    if la_ == 1:
                        self.state = 1785
                        self.ruleNonFeatureMember()
                        pass

                    elif la_ == 2:
                        self.state = 1786
                        self.ruleMetadataBodyFeatureMember()
                        pass

                    elif la_ == 3:
                        self.state = 1787
                        self.ruleAliasMember()
                        pass

                    elif la_ == 4:
                        self.state = 1788
                        self.ruleImport()
                        pass


                    self.state = 1793
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1794
                self.match(KerMLv2Parser.RBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetadataBodyFeatureMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMetadataBodyFeature(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataBodyFeatureContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetadataBodyFeatureMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetadataBodyFeatureMember" ):
                listener.enterRuleMetadataBodyFeatureMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetadataBodyFeatureMember" ):
                listener.exitRuleMetadataBodyFeatureMember(self)




    def ruleMetadataBodyFeatureMember(self):

        localctx = KerMLv2Parser.RuleMetadataBodyFeatureMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_ruleMetadataBodyFeatureMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1797
            self.ruleMetadataBodyFeature()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetadataBodyFeatureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedRedefinition(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedRedefinitionContext,0)


        def ruleMetadataBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataBodyContext,0)


        def K_FEATURE(self):
            return self.getToken(KerMLv2Parser.K_FEATURE, 0)

        def ruleFeatureSpecializationPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureSpecializationPartContext,0)


        def ruleValuePart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleValuePartContext,0)


        def OP_COLON_RANGLE_RANGLE(self):
            return self.getToken(KerMLv2Parser.OP_COLON_RANGLE_RANGLE, 0)

        def K_REDEFINES(self):
            return self.getToken(KerMLv2Parser.K_REDEFINES, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetadataBodyFeature

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetadataBodyFeature" ):
                listener.enterRuleMetadataBodyFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetadataBodyFeature" ):
                listener.exitRuleMetadataBodyFeature(self)




    def ruleMetadataBodyFeature(self):

        localctx = KerMLv2Parser.RuleMetadataBodyFeatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_ruleMetadataBodyFeature)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1800
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 1799
                self.match(KerMLv2Parser.K_FEATURE)


            self.state = 1803
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==51 or _la==117:
                self.state = 1802
                _la = self._input.LA(1)
                if not(_la==51 or _la==117):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1805
            self.ruleOwnedRedefinition()
            self.state = 1807
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4433230883192832) != 0) or ((((_la - 105)) & ~0x3f) == 0 and ((1 << (_la - 105)) & 7425) != 0):
                self.state = 1806
                self.ruleFeatureSpecializationPart()


            self.state = 1810
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & 6917529027641081857) != 0):
                self.state = 1809
                self.ruleValuePart()


            self.state = 1812
            self.ruleMetadataBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleExpressionBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(KerMLv2Parser.LBRACE, 0)

        def ruleFunctionBodyPart(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionBodyPartContext,0)


        def RBRACE(self):
            return self.getToken(KerMLv2Parser.RBRACE, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleExpressionBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleExpressionBody" ):
                listener.enterRuleExpressionBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleExpressionBody" ):
                listener.exitRuleExpressionBody(self)




    def ruleExpressionBody(self):

        localctx = KerMLv2Parser.RuleExpressionBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_ruleExpressionBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1814
            self.match(KerMLv2Parser.LBRACE)
            self.state = 1815
            self.ruleFunctionBodyPart()
            self.state = 1816
            self.match(KerMLv2Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedExpressionMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedExpressionMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedExpressionMember" ):
                listener.enterRuleOwnedExpressionMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedExpressionMember" ):
                listener.exitRuleOwnedExpressionMember(self)




    def ruleOwnedExpressionMember(self):

        localctx = KerMLv2Parser.RuleOwnedExpressionMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_ruleOwnedExpressionMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1818
            self.ruleOwnedExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleConditionalExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleConditionalExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedExpression" ):
                listener.enterRuleOwnedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedExpression" ):
                listener.exitRuleOwnedExpression(self)




    def ruleOwnedExpression(self):

        localctx = KerMLv2Parser.RuleOwnedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_ruleOwnedExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1820
            self.ruleConditionalExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedExpressionReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedExpressionMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedExpressionMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedExpressionReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedExpressionReference" ):
                listener.enterRuleOwnedExpressionReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedExpressionReference" ):
                listener.exitRuleOwnedExpressionReference(self)




    def ruleOwnedExpressionReference(self):

        localctx = KerMLv2Parser.RuleOwnedExpressionReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_ruleOwnedExpressionReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1822
            self.ruleOwnedExpressionMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConditionalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConditionalExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleConditionalExpression1Context(RuleConditionalExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleConditionalExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleNullCoalescingExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNullCoalescingExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConditionalExpression1" ):
                listener.enterRuleConditionalExpression1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConditionalExpression1" ):
                listener.exitRuleConditionalExpression1(self)


    class RuleConditionalExpression2Context(RuleConditionalExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleConditionalExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleConditionalOperator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleConditionalOperatorContext,0)

        def ruleNullCoalescingExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNullCoalescingExpressionContext,0)

        def OP_QMARK(self):
            return self.getToken(KerMLv2Parser.OP_QMARK, 0)
        def ruleOwnedExpressionReference(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedExpressionReferenceContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedExpressionReferenceContext,i)

        def K_ELSE(self):
            return self.getToken(KerMLv2Parser.K_ELSE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConditionalExpression2" ):
                listener.enterRuleConditionalExpression2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConditionalExpression2" ):
                listener.exitRuleConditionalExpression2(self)



    def ruleConditionalExpression(self):

        localctx = KerMLv2Parser.RuleConditionalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_ruleConditionalExpression)
        try:
            self.state = 1832
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14, 76, 77, 88, 89, 90, 92, 93, 102, 106, 112, 114, 121, 123, 135, 136, 142, 143, 144, 145, 146]:
                localctx = KerMLv2Parser.RuleConditionalExpression1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1824
                self.ruleNullCoalescingExpression()
                pass
            elif token in [83]:
                localctx = KerMLv2Parser.RuleConditionalExpression2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1825
                self.ruleConditionalOperator()
                self.state = 1826
                self.ruleNullCoalescingExpression()
                self.state = 1827
                self.match(KerMLv2Parser.OP_QMARK)
                self.state = 1828
                self.ruleOwnedExpressionReference()
                self.state = 1829
                self.match(KerMLv2Parser.K_ELSE)
                self.state = 1830
                self.ruleOwnedExpressionReference()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConditionalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_IF(self):
            return self.getToken(KerMLv2Parser.K_IF, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConditionalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConditionalOperator" ):
                listener.enterRuleConditionalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConditionalOperator" ):
                listener.exitRuleConditionalOperator(self)




    def ruleConditionalOperator(self):

        localctx = KerMLv2Parser.RuleConditionalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_ruleConditionalOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1834
            self.match(KerMLv2Parser.K_IF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNullCoalescingExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleImpliesExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImpliesExpressionContext,0)


        def ruleNullCoalescingOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNullCoalescingOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNullCoalescingOperatorContext,i)


        def ruleImpliesExpressionReference(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleImpliesExpressionReferenceContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleImpliesExpressionReferenceContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNullCoalescingExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNullCoalescingExpression" ):
                listener.enterRuleNullCoalescingExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNullCoalescingExpression" ):
                listener.exitRuleNullCoalescingExpression(self)




    def ruleNullCoalescingExpression(self):

        localctx = KerMLv2Parser.RuleNullCoalescingExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_ruleNullCoalescingExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1836
            self.ruleImpliesExpression()
            self.state = 1842
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==125:
                self.state = 1837
                self.ruleNullCoalescingOperator()
                self.state = 1838
                self.ruleImpliesExpressionReference()
                self.state = 1844
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNullCoalescingOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP_QMARK_QMARK(self):
            return self.getToken(KerMLv2Parser.OP_QMARK_QMARK, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNullCoalescingOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNullCoalescingOperator" ):
                listener.enterRuleNullCoalescingOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNullCoalescingOperator" ):
                listener.exitRuleNullCoalescingOperator(self)




    def ruleNullCoalescingOperator(self):

        localctx = KerMLv2Parser.RuleNullCoalescingOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_ruleNullCoalescingOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1845
            self.match(KerMLv2Parser.OP_QMARK_QMARK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleImpliesExpressionReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleImpliesExpressionMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImpliesExpressionMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleImpliesExpressionReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleImpliesExpressionReference" ):
                listener.enterRuleImpliesExpressionReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleImpliesExpressionReference" ):
                listener.exitRuleImpliesExpressionReference(self)




    def ruleImpliesExpressionReference(self):

        localctx = KerMLv2Parser.RuleImpliesExpressionReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_ruleImpliesExpressionReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1847
            self.ruleImpliesExpressionMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleImpliesExpressionMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleImpliesExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleImpliesExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleImpliesExpressionMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleImpliesExpressionMember" ):
                listener.enterRuleImpliesExpressionMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleImpliesExpressionMember" ):
                listener.exitRuleImpliesExpressionMember(self)




    def ruleImpliesExpressionMember(self):

        localctx = KerMLv2Parser.RuleImpliesExpressionMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_ruleImpliesExpressionMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1849
            self.ruleImpliesExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleImpliesExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOrExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOrExpressionContext,0)


        def ruleImpliesOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleImpliesOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleImpliesOperatorContext,i)


        def ruleOrExpressionReference(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOrExpressionReferenceContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOrExpressionReferenceContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleImpliesExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleImpliesExpression" ):
                listener.enterRuleImpliesExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleImpliesExpression" ):
                listener.exitRuleImpliesExpression(self)




    def ruleImpliesExpression(self):

        localctx = KerMLv2Parser.RuleImpliesExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_ruleImpliesExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1851
            self.ruleOrExpression()
            self.state = 1857
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==84:
                self.state = 1852
                self.ruleImpliesOperator()
                self.state = 1853
                self.ruleOrExpressionReference()
                self.state = 1859
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleImpliesOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_IMPLIES(self):
            return self.getToken(KerMLv2Parser.K_IMPLIES, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleImpliesOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleImpliesOperator" ):
                listener.enterRuleImpliesOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleImpliesOperator" ):
                listener.exitRuleImpliesOperator(self)




    def ruleImpliesOperator(self):

        localctx = KerMLv2Parser.RuleImpliesOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_ruleImpliesOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1860
            self.match(KerMLv2Parser.K_IMPLIES)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOrExpressionReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOrExpressionMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOrExpressionMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOrExpressionReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOrExpressionReference" ):
                listener.enterRuleOrExpressionReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOrExpressionReference" ):
                listener.exitRuleOrExpressionReference(self)




    def ruleOrExpressionReference(self):

        localctx = KerMLv2Parser.RuleOrExpressionReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_ruleOrExpressionReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1862
            self.ruleOrExpressionMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOrExpressionMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOrExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOrExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOrExpressionMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOrExpressionMember" ):
                listener.enterRuleOrExpressionMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOrExpressionMember" ):
                listener.exitRuleOrExpressionMember(self)




    def ruleOrExpressionMember(self):

        localctx = KerMLv2Parser.RuleOrExpressionMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_ruleOrExpressionMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1864
            self.ruleOrExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOrExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleXorExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleXorExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleXorExpressionContext,i)


        def ruleOrOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOrOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOrOperatorContext,i)


        def ruleConditionalOrOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleConditionalOrOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleConditionalOrOperatorContext,i)


        def ruleXorExpressionReference(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleXorExpressionReferenceContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleXorExpressionReferenceContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOrExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOrExpression" ):
                listener.enterRuleOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOrExpression" ):
                listener.exitRuleOrExpression(self)




    def ruleOrExpression(self):

        localctx = KerMLv2Parser.RuleOrExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_ruleOrExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1866
            self.ruleXorExpression()
            self.state = 1877
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==85 or _la==126:
                self.state = 1873
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [126]:
                    self.state = 1867
                    self.ruleOrOperator()
                    self.state = 1868
                    self.ruleXorExpression()
                    pass
                elif token in [85]:
                    self.state = 1870
                    self.ruleConditionalOrOperator()
                    self.state = 1871
                    self.ruleXorExpressionReference()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1879
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOrOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP_BAR(self):
            return self.getToken(KerMLv2Parser.OP_BAR, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOrOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOrOperator" ):
                listener.enterRuleOrOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOrOperator" ):
                listener.exitRuleOrOperator(self)




    def ruleOrOperator(self):

        localctx = KerMLv2Parser.RuleOrOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_ruleOrOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1880
            self.match(KerMLv2Parser.OP_BAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConditionalOrOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_OR(self):
            return self.getToken(KerMLv2Parser.K_OR, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConditionalOrOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConditionalOrOperator" ):
                listener.enterRuleConditionalOrOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConditionalOrOperator" ):
                listener.exitRuleConditionalOrOperator(self)




    def ruleConditionalOrOperator(self):

        localctx = KerMLv2Parser.RuleConditionalOrOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_ruleConditionalOrOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1882
            self.match(KerMLv2Parser.K_OR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleXorExpressionReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleXorExpressionMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleXorExpressionMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleXorExpressionReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleXorExpressionReference" ):
                listener.enterRuleXorExpressionReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleXorExpressionReference" ):
                listener.exitRuleXorExpressionReference(self)




    def ruleXorExpressionReference(self):

        localctx = KerMLv2Parser.RuleXorExpressionReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_ruleXorExpressionReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1884
            self.ruleXorExpressionMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleXorExpressionMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleXorExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleXorExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleXorExpressionMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleXorExpressionMember" ):
                listener.enterRuleXorExpressionMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleXorExpressionMember" ):
                listener.exitRuleXorExpressionMember(self)




    def ruleXorExpressionMember(self):

        localctx = KerMLv2Parser.RuleXorExpressionMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_ruleXorExpressionMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1886
            self.ruleXorExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleXorExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleAndExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAndExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAndExpressionContext,i)


        def ruleXorOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleXorOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleXorOperatorContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleXorExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleXorExpression" ):
                listener.enterRuleXorExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleXorExpression" ):
                listener.exitRuleXorExpression(self)




    def ruleXorExpression(self):

        localctx = KerMLv2Parser.RuleXorExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_ruleXorExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1888
            self.ruleAndExpression()
            self.state = 1894
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==86:
                self.state = 1889
                self.ruleXorOperator()
                self.state = 1890
                self.ruleAndExpression()
                self.state = 1896
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleXorOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_XOR(self):
            return self.getToken(KerMLv2Parser.K_XOR, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleXorOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleXorOperator" ):
                listener.enterRuleXorOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleXorOperator" ):
                listener.exitRuleXorOperator(self)




    def ruleXorOperator(self):

        localctx = KerMLv2Parser.RuleXorOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_ruleXorOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1897
            self.match(KerMLv2Parser.K_XOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleAndExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleEqualityExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleEqualityExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleEqualityExpressionContext,i)


        def ruleAndOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAndOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAndOperatorContext,i)


        def ruleConditionalAndOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleConditionalAndOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleConditionalAndOperatorContext,i)


        def ruleEqualityExpressionReference(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleEqualityExpressionReferenceContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleEqualityExpressionReferenceContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleAndExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAndExpression" ):
                listener.enterRuleAndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAndExpression" ):
                listener.exitRuleAndExpression(self)




    def ruleAndExpression(self):

        localctx = KerMLv2Parser.RuleAndExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_ruleAndExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1899
            self.ruleEqualityExpression()
            self.state = 1910
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==87 or _la==127:
                self.state = 1906
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [127]:
                    self.state = 1900
                    self.ruleAndOperator()
                    self.state = 1901
                    self.ruleEqualityExpression()
                    pass
                elif token in [87]:
                    self.state = 1903
                    self.ruleConditionalAndOperator()
                    self.state = 1904
                    self.ruleEqualityExpressionReference()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1912
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleAndOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP_AND(self):
            return self.getToken(KerMLv2Parser.OP_AND, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleAndOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAndOperator" ):
                listener.enterRuleAndOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAndOperator" ):
                listener.exitRuleAndOperator(self)




    def ruleAndOperator(self):

        localctx = KerMLv2Parser.RuleAndOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_ruleAndOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1913
            self.match(KerMLv2Parser.OP_AND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleConditionalAndOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_AND(self):
            return self.getToken(KerMLv2Parser.K_AND, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleConditionalAndOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleConditionalAndOperator" ):
                listener.enterRuleConditionalAndOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleConditionalAndOperator" ):
                listener.exitRuleConditionalAndOperator(self)




    def ruleConditionalAndOperator(self):

        localctx = KerMLv2Parser.RuleConditionalAndOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_ruleConditionalAndOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1915
            self.match(KerMLv2Parser.K_AND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleEqualityExpressionReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleEqualityExpressionMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleEqualityExpressionMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleEqualityExpressionReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleEqualityExpressionReference" ):
                listener.enterRuleEqualityExpressionReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleEqualityExpressionReference" ):
                listener.exitRuleEqualityExpressionReference(self)




    def ruleEqualityExpressionReference(self):

        localctx = KerMLv2Parser.RuleEqualityExpressionReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_ruleEqualityExpressionReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1917
            self.ruleEqualityExpressionMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleEqualityExpressionMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleEqualityExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleEqualityExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleEqualityExpressionMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleEqualityExpressionMember" ):
                listener.enterRuleEqualityExpressionMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleEqualityExpressionMember" ):
                listener.exitRuleEqualityExpressionMember(self)




    def ruleEqualityExpressionMember(self):

        localctx = KerMLv2Parser.RuleEqualityExpressionMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_ruleEqualityExpressionMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1919
            self.ruleEqualityExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleEqualityExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleClassificationExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleClassificationExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleClassificationExpressionContext,i)


        def ruleEqualityOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleEqualityOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleEqualityOperatorContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleEqualityExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleEqualityExpression" ):
                listener.enterRuleEqualityExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleEqualityExpression" ):
                listener.exitRuleEqualityExpression(self)




    def ruleEqualityExpression(self):

        localctx = KerMLv2Parser.RuleEqualityExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_ruleEqualityExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1921
            self.ruleClassificationExpression()
            self.state = 1927
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & 15) != 0):
                self.state = 1922
                self.ruleEqualityOperator()
                self.state = 1923
                self.ruleClassificationExpression()
                self.state = 1929
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleEqualityOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleEqualityOperator

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleEqualityOperator2Context(RuleEqualityOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleEqualityOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_BANG_EQ(self):
            return self.getToken(KerMLv2Parser.OP_BANG_EQ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleEqualityOperator2" ):
                listener.enterRuleEqualityOperator2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleEqualityOperator2" ):
                listener.exitRuleEqualityOperator2(self)


    class RuleEqualityOperator3Context(RuleEqualityOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleEqualityOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_EQ_EQ_EQ(self):
            return self.getToken(KerMLv2Parser.OP_EQ_EQ_EQ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleEqualityOperator3" ):
                listener.enterRuleEqualityOperator3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleEqualityOperator3" ):
                listener.exitRuleEqualityOperator3(self)


    class RuleEqualityOperator4Context(RuleEqualityOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleEqualityOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_BANG_EQ_EQ(self):
            return self.getToken(KerMLv2Parser.OP_BANG_EQ_EQ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleEqualityOperator4" ):
                listener.enterRuleEqualityOperator4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleEqualityOperator4" ):
                listener.exitRuleEqualityOperator4(self)


    class RuleEqualityOperator1Context(RuleEqualityOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleEqualityOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_EQ_EQ(self):
            return self.getToken(KerMLv2Parser.OP_EQ_EQ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleEqualityOperator1" ):
                listener.enterRuleEqualityOperator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleEqualityOperator1" ):
                listener.exitRuleEqualityOperator1(self)



    def ruleEqualityOperator(self):

        localctx = KerMLv2Parser.RuleEqualityOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_ruleEqualityOperator)
        try:
            self.state = 1934
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [128]:
                localctx = KerMLv2Parser.RuleEqualityOperator1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1930
                self.match(KerMLv2Parser.OP_EQ_EQ)
                pass
            elif token in [129]:
                localctx = KerMLv2Parser.RuleEqualityOperator2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1931
                self.match(KerMLv2Parser.OP_BANG_EQ)
                pass
            elif token in [130]:
                localctx = KerMLv2Parser.RuleEqualityOperator3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1932
                self.match(KerMLv2Parser.OP_EQ_EQ_EQ)
                pass
            elif token in [131]:
                localctx = KerMLv2Parser.RuleEqualityOperator4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1933
                self.match(KerMLv2Parser.OP_BANG_EQ_EQ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleClassificationExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleClassificationExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleClassificationExpression1Context(RuleClassificationExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleClassificationExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleRelationalExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRelationalExpressionContext,0)

        def ruleClassificationTestOperator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassificationTestOperatorContext,0)

        def ruleTypeReferenceMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeReferenceMemberContext,0)

        def ruleCastOperator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleCastOperatorContext,0)

        def ruleTypeResultMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeResultMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassificationExpression1" ):
                listener.enterRuleClassificationExpression1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassificationExpression1" ):
                listener.exitRuleClassificationExpression1(self)


    class RuleClassificationExpression4Context(RuleClassificationExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleClassificationExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleSelfReferenceExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSelfReferenceExpressionContext,0)

        def ruleCastOperator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleCastOperatorContext,0)

        def ruleTypeResultMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeResultMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassificationExpression4" ):
                listener.enterRuleClassificationExpression4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassificationExpression4" ):
                listener.exitRuleClassificationExpression4(self)


    class RuleClassificationExpression5Context(RuleClassificationExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleClassificationExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMetadataReference(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataReferenceContext,0)

        def ruleMetaCastOperator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetaCastOperatorContext,0)

        def ruleTypeResultMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeResultMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassificationExpression5" ):
                listener.enterRuleClassificationExpression5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassificationExpression5" ):
                listener.exitRuleClassificationExpression5(self)


    class RuleClassificationExpression2Context(RuleClassificationExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleClassificationExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleSelfReferenceExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSelfReferenceExpressionContext,0)

        def ruleClassificationTestOperator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleClassificationTestOperatorContext,0)

        def ruleTypeReferenceMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeReferenceMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassificationExpression2" ):
                listener.enterRuleClassificationExpression2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassificationExpression2" ):
                listener.exitRuleClassificationExpression2(self)


    class RuleClassificationExpression3Context(RuleClassificationExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleClassificationExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMetadataReference(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataReferenceContext,0)

        def ruleMetaClassificationTestOperator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetaClassificationTestOperatorContext,0)

        def ruleTypeReferenceMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeReferenceMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassificationExpression3" ):
                listener.enterRuleClassificationExpression3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassificationExpression3" ):
                listener.exitRuleClassificationExpression3(self)



    def ruleClassificationExpression(self):

        localctx = KerMLv2Parser.RuleClassificationExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_ruleClassificationExpression)
        try:
            self.state = 1961
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,227,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleClassificationExpression1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1936
                self.ruleRelationalExpression()
                self.state = 1943
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [88, 89, 123]:
                    self.state = 1937
                    self.ruleClassificationTestOperator()
                    self.state = 1938
                    self.ruleTypeReferenceMember()
                    pass
                elif token in [90]:
                    self.state = 1940
                    self.ruleCastOperator()
                    self.state = 1941
                    self.ruleTypeResultMember()
                    pass
                elif token in [2, 43, 82, 84, 85, 86, 87, 102, 103, 104, 107, 108, 109, 124, 125, 126, 127, 128, 129, 130, 131]:
                    pass
                else:
                    pass
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleClassificationExpression2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1945
                self.ruleSelfReferenceExpression()
                self.state = 1946
                self.ruleClassificationTestOperator()
                self.state = 1947
                self.ruleTypeReferenceMember()
                pass

            elif la_ == 3:
                localctx = KerMLv2Parser.RuleClassificationExpression3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1949
                self.ruleMetadataReference()
                self.state = 1950
                self.ruleMetaClassificationTestOperator()
                self.state = 1951
                self.ruleTypeReferenceMember()
                pass

            elif la_ == 4:
                localctx = KerMLv2Parser.RuleClassificationExpression4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1953
                self.ruleSelfReferenceExpression()
                self.state = 1954
                self.ruleCastOperator()
                self.state = 1955
                self.ruleTypeResultMember()
                pass

            elif la_ == 5:
                localctx = KerMLv2Parser.RuleClassificationExpression5Context(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1957
                self.ruleMetadataReference()
                self.state = 1958
                self.ruleMetaCastOperator()
                self.state = 1959
                self.ruleTypeResultMember()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleClassificationTestOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleClassificationTestOperator

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleClassificationTestOperator2Context(RuleClassificationTestOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleClassificationTestOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_ISTYPE(self):
            return self.getToken(KerMLv2Parser.K_ISTYPE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassificationTestOperator2" ):
                listener.enterRuleClassificationTestOperator2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassificationTestOperator2" ):
                listener.exitRuleClassificationTestOperator2(self)


    class RuleClassificationTestOperator3Context(RuleClassificationTestOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleClassificationTestOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_AT(self):
            return self.getToken(KerMLv2Parser.OP_AT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassificationTestOperator3" ):
                listener.enterRuleClassificationTestOperator3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassificationTestOperator3" ):
                listener.exitRuleClassificationTestOperator3(self)


    class RuleClassificationTestOperator1Context(RuleClassificationTestOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleClassificationTestOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_HASTYPE(self):
            return self.getToken(KerMLv2Parser.K_HASTYPE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleClassificationTestOperator1" ):
                listener.enterRuleClassificationTestOperator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleClassificationTestOperator1" ):
                listener.exitRuleClassificationTestOperator1(self)



    def ruleClassificationTestOperator(self):

        localctx = KerMLv2Parser.RuleClassificationTestOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_ruleClassificationTestOperator)
        try:
            self.state = 1966
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [88]:
                localctx = KerMLv2Parser.RuleClassificationTestOperator1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1963
                self.match(KerMLv2Parser.K_HASTYPE)
                pass
            elif token in [89]:
                localctx = KerMLv2Parser.RuleClassificationTestOperator2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1964
                self.match(KerMLv2Parser.K_ISTYPE)
                pass
            elif token in [123]:
                localctx = KerMLv2Parser.RuleClassificationTestOperator3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1965
                self.match(KerMLv2Parser.OP_AT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetaClassificationTestOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP_AT_AT(self):
            return self.getToken(KerMLv2Parser.OP_AT_AT, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetaClassificationTestOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetaClassificationTestOperator" ):
                listener.enterRuleMetaClassificationTestOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetaClassificationTestOperator" ):
                listener.exitRuleMetaClassificationTestOperator(self)




    def ruleMetaClassificationTestOperator(self):

        localctx = KerMLv2Parser.RuleMetaClassificationTestOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_ruleMetaClassificationTestOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1968
            self.match(KerMLv2Parser.OP_AT_AT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleCastOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_AS(self):
            return self.getToken(KerMLv2Parser.K_AS, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleCastOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleCastOperator" ):
                listener.enterRuleCastOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleCastOperator" ):
                listener.exitRuleCastOperator(self)




    def ruleCastOperator(self):

        localctx = KerMLv2Parser.RuleCastOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_ruleCastOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1970
            self.match(KerMLv2Parser.K_AS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetaCastOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_META(self):
            return self.getToken(KerMLv2Parser.K_META, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetaCastOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetaCastOperator" ):
                listener.enterRuleMetaCastOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetaCastOperator" ):
                listener.exitRuleMetaCastOperator(self)




    def ruleMetaCastOperator(self):

        localctx = KerMLv2Parser.RuleMetaCastOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_ruleMetaCastOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1972
            self.match(KerMLv2Parser.K_META)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetadataReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetadataReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetadataReference" ):
                listener.enterRuleMetadataReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetadataReference" ):
                listener.exitRuleMetadataReference(self)




    def ruleMetadataReference(self):

        localctx = KerMLv2Parser.RuleMetadataReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_ruleMetadataReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1974
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeReferenceMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypeReference(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeReferenceContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypeReferenceMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeReferenceMember" ):
                listener.enterRuleTypeReferenceMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeReferenceMember" ):
                listener.exitRuleTypeReferenceMember(self)




    def ruleTypeReferenceMember(self):

        localctx = KerMLv2Parser.RuleTypeReferenceMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_ruleTypeReferenceMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1976
            self.ruleTypeReference()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeResultMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleTypeReference(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeReferenceContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypeResultMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeResultMember" ):
                listener.enterRuleTypeResultMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeResultMember" ):
                listener.exitRuleTypeResultMember(self)




    def ruleTypeResultMember(self):

        localctx = KerMLv2Parser.RuleTypeResultMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_ruleTypeResultMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1978
            self.ruleTypeReference()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleTypeReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleReferenceTyping(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleReferenceTypingContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleTypeReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleTypeReference" ):
                listener.enterRuleTypeReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleTypeReference" ):
                listener.exitRuleTypeReference(self)




    def ruleTypeReference(self):

        localctx = KerMLv2Parser.RuleTypeReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_ruleTypeReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1980
            self.ruleReferenceTyping()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleReferenceTypingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleReferenceTyping

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleReferenceTyping" ):
                listener.enterRuleReferenceTyping(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleReferenceTyping" ):
                listener.exitRuleReferenceTyping(self)




    def ruleReferenceTyping(self):

        localctx = KerMLv2Parser.RuleReferenceTypingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_ruleReferenceTyping)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1982
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSelfReferenceExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleSelfReferenceMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSelfReferenceMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSelfReferenceExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSelfReferenceExpression" ):
                listener.enterRuleSelfReferenceExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSelfReferenceExpression" ):
                listener.exitRuleSelfReferenceExpression(self)




    def ruleSelfReferenceExpression(self):

        localctx = KerMLv2Parser.RuleSelfReferenceExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_ruleSelfReferenceExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1984
            self.ruleSelfReferenceMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSelfReferenceMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleEmptyFeature(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleEmptyFeatureContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSelfReferenceMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSelfReferenceMember" ):
                listener.enterRuleSelfReferenceMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSelfReferenceMember" ):
                listener.exitRuleSelfReferenceMember(self)




    def ruleSelfReferenceMember(self):

        localctx = KerMLv2Parser.RuleSelfReferenceMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_ruleSelfReferenceMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1986
            self.ruleEmptyFeature()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleEmptyFeatureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleEmptyFeature

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleEmptyFeature" ):
                listener.enterRuleEmptyFeature(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleEmptyFeature" ):
                listener.exitRuleEmptyFeature(self)




    def ruleEmptyFeature(self):

        localctx = KerMLv2Parser.RuleEmptyFeatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_ruleEmptyFeature)
        try:
            self.enterOuterAlt(localctx, 1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRelationalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleRangeExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleRangeExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleRangeExpressionContext,i)


        def ruleRelationalOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleRelationalOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleRelationalOperatorContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRelationalExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRelationalExpression" ):
                listener.enterRuleRelationalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRelationalExpression" ):
                listener.exitRuleRelationalExpression(self)




    def ruleRelationalExpression(self):

        localctx = KerMLv2Parser.RuleRelationalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_ruleRelationalExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1990
            self.ruleRangeExpression()
            self.state = 1996
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 25769803779) != 0):
                self.state = 1991
                self.ruleRelationalOperator()
                self.state = 1992
                self.ruleRangeExpression()
                self.state = 1998
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRelationalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRelationalOperator

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleRelationalOperator4Context(RuleRelationalOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRelationalOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_RANGLE_EQ(self):
            return self.getToken(KerMLv2Parser.OP_RANGLE_EQ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRelationalOperator4" ):
                listener.enterRuleRelationalOperator4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRelationalOperator4" ):
                listener.exitRuleRelationalOperator4(self)


    class RuleRelationalOperator3Context(RuleRelationalOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRelationalOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_LANGLE_EQ(self):
            return self.getToken(KerMLv2Parser.OP_LANGLE_EQ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRelationalOperator3" ):
                listener.enterRuleRelationalOperator3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRelationalOperator3" ):
                listener.exitRuleRelationalOperator3(self)


    class RuleRelationalOperator2Context(RuleRelationalOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRelationalOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RANGLE(self):
            return self.getToken(KerMLv2Parser.RANGLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRelationalOperator2" ):
                listener.enterRuleRelationalOperator2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRelationalOperator2" ):
                listener.exitRuleRelationalOperator2(self)


    class RuleRelationalOperator1Context(RuleRelationalOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRelationalOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LANGLE(self):
            return self.getToken(KerMLv2Parser.LANGLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRelationalOperator1" ):
                listener.enterRuleRelationalOperator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRelationalOperator1" ):
                listener.exitRuleRelationalOperator1(self)



    def ruleRelationalOperator(self):

        localctx = KerMLv2Parser.RuleRelationalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_ruleRelationalOperator)
        try:
            self.state = 2003
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [100]:
                localctx = KerMLv2Parser.RuleRelationalOperator1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1999
                self.match(KerMLv2Parser.LANGLE)
                pass
            elif token in [101]:
                localctx = KerMLv2Parser.RuleRelationalOperator2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2000
                self.match(KerMLv2Parser.RANGLE)
                pass
            elif token in [133]:
                localctx = KerMLv2Parser.RuleRelationalOperator3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2001
                self.match(KerMLv2Parser.OP_LANGLE_EQ)
                pass
            elif token in [134]:
                localctx = KerMLv2Parser.RuleRelationalOperator4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2002
                self.match(KerMLv2Parser.OP_RANGLE_EQ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRangeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleAdditiveExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAdditiveExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAdditiveExpressionContext,i)


        def OP_DOT_DOT(self):
            return self.getToken(KerMLv2Parser.OP_DOT_DOT, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRangeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRangeExpression" ):
                listener.enterRuleRangeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRangeExpression" ):
                listener.exitRuleRangeExpression(self)




    def ruleRangeExpression(self):

        localctx = KerMLv2Parser.RuleRangeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_ruleRangeExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2005
            self.ruleAdditiveExpression()
            self.state = 2008
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==120:
                self.state = 2006
                self.match(KerMLv2Parser.OP_DOT_DOT)
                self.state = 2007
                self.ruleAdditiveExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleAdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleMultiplicativeExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleMultiplicativeExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicativeExpressionContext,i)


        def ruleAdditiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleAdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleAdditiveOperatorContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleAdditiveExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAdditiveExpression" ):
                listener.enterRuleAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAdditiveExpression" ):
                listener.exitRuleAdditiveExpression(self)




    def ruleAdditiveExpression(self):

        localctx = KerMLv2Parser.RuleAdditiveExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_ruleAdditiveExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2010
            self.ruleMultiplicativeExpression()
            self.state = 2016
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==135 or _la==136:
                self.state = 2011
                self.ruleAdditiveOperator()
                self.state = 2012
                self.ruleMultiplicativeExpression()
                self.state = 2018
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleAdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleAdditiveOperator

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleAdditiveOperator1Context(RuleAdditiveOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleAdditiveOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_PLUS(self):
            return self.getToken(KerMLv2Parser.OP_PLUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAdditiveOperator1" ):
                listener.enterRuleAdditiveOperator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAdditiveOperator1" ):
                listener.exitRuleAdditiveOperator1(self)


    class RuleAdditiveOperator2Context(RuleAdditiveOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleAdditiveOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_MINUS(self):
            return self.getToken(KerMLv2Parser.OP_MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleAdditiveOperator2" ):
                listener.enterRuleAdditiveOperator2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleAdditiveOperator2" ):
                listener.exitRuleAdditiveOperator2(self)



    def ruleAdditiveOperator(self):

        localctx = KerMLv2Parser.RuleAdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_ruleAdditiveOperator)
        try:
            self.state = 2021
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [135]:
                localctx = KerMLv2Parser.RuleAdditiveOperator1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2019
                self.match(KerMLv2Parser.OP_PLUS)
                pass
            elif token in [136]:
                localctx = KerMLv2Parser.RuleAdditiveOperator2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2020
                self.match(KerMLv2Parser.OP_MINUS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleExponentiationExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleExponentiationExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleExponentiationExpressionContext,i)


        def ruleMultiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleMultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleMultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMultiplicativeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicativeExpression" ):
                listener.enterRuleMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicativeExpression" ):
                listener.exitRuleMultiplicativeExpression(self)




    def ruleMultiplicativeExpression(self):

        localctx = KerMLv2Parser.RuleMultiplicativeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_ruleMultiplicativeExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2023
            self.ruleExponentiationExpression()
            self.state = 2029
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 100663297) != 0):
                self.state = 2024
                self.ruleMultiplicativeOperator()
                self.state = 2025
                self.ruleExponentiationExpression()
                self.state = 2031
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMultiplicativeOperator

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleMultiplicativeOperator1Context(RuleMultiplicativeOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMultiplicativeOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_STAR(self):
            return self.getToken(KerMLv2Parser.OP_STAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicativeOperator1" ):
                listener.enterRuleMultiplicativeOperator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicativeOperator1" ):
                listener.exitRuleMultiplicativeOperator1(self)


    class RuleMultiplicativeOperator3Context(RuleMultiplicativeOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMultiplicativeOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_PERCENT(self):
            return self.getToken(KerMLv2Parser.OP_PERCENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicativeOperator3" ):
                listener.enterRuleMultiplicativeOperator3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicativeOperator3" ):
                listener.exitRuleMultiplicativeOperator3(self)


    class RuleMultiplicativeOperator2Context(RuleMultiplicativeOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleMultiplicativeOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_SLASH(self):
            return self.getToken(KerMLv2Parser.OP_SLASH, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMultiplicativeOperator2" ):
                listener.enterRuleMultiplicativeOperator2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMultiplicativeOperator2" ):
                listener.exitRuleMultiplicativeOperator2(self)



    def ruleMultiplicativeOperator(self):

        localctx = KerMLv2Parser.RuleMultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_ruleMultiplicativeOperator)
        try:
            self.state = 2035
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [112]:
                localctx = KerMLv2Parser.RuleMultiplicativeOperator1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2032
                self.match(KerMLv2Parser.OP_STAR)
                pass
            elif token in [137]:
                localctx = KerMLv2Parser.RuleMultiplicativeOperator2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2033
                self.match(KerMLv2Parser.OP_SLASH)
                pass
            elif token in [138]:
                localctx = KerMLv2Parser.RuleMultiplicativeOperator3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2034
                self.match(KerMLv2Parser.OP_PERCENT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleExponentiationExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleUnaryExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleUnaryExpressionContext,0)


        def ruleExponentiationOperator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExponentiationOperatorContext,0)


        def ruleExponentiationExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExponentiationExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleExponentiationExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleExponentiationExpression" ):
                listener.enterRuleExponentiationExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleExponentiationExpression" ):
                listener.exitRuleExponentiationExpression(self)




    def ruleExponentiationExpression(self):

        localctx = KerMLv2Parser.RuleExponentiationExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_ruleExponentiationExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2037
            self.ruleUnaryExpression()
            self.state = 2041
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==111 or _la==139:
                self.state = 2038
                self.ruleExponentiationOperator()
                self.state = 2039
                self.ruleExponentiationExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleExponentiationOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleExponentiationOperator

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleExponentiationOperator1Context(RuleExponentiationOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleExponentiationOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_STAR_STAR(self):
            return self.getToken(KerMLv2Parser.OP_STAR_STAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleExponentiationOperator1" ):
                listener.enterRuleExponentiationOperator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleExponentiationOperator1" ):
                listener.exitRuleExponentiationOperator1(self)


    class RuleExponentiationOperator2Context(RuleExponentiationOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleExponentiationOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_HAT(self):
            return self.getToken(KerMLv2Parser.OP_HAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleExponentiationOperator2" ):
                listener.enterRuleExponentiationOperator2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleExponentiationOperator2" ):
                listener.exitRuleExponentiationOperator2(self)



    def ruleExponentiationOperator(self):

        localctx = KerMLv2Parser.RuleExponentiationOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_ruleExponentiationOperator)
        try:
            self.state = 2045
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [111]:
                localctx = KerMLv2Parser.RuleExponentiationOperator1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2043
                self.match(KerMLv2Parser.OP_STAR_STAR)
                pass
            elif token in [139]:
                localctx = KerMLv2Parser.RuleExponentiationOperator2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2044
                self.match(KerMLv2Parser.OP_HAT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleUnaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleUnaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleUnaryExpression1Context(RuleUnaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleUnaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleUnaryOperator(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleUnaryOperatorContext,0)

        def ruleExtentExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExtentExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleUnaryExpression1" ):
                listener.enterRuleUnaryExpression1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleUnaryExpression1" ):
                listener.exitRuleUnaryExpression1(self)


    class RuleUnaryExpression2Context(RuleUnaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleUnaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleExtentExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExtentExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleUnaryExpression2" ):
                listener.enterRuleUnaryExpression2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleUnaryExpression2" ):
                listener.exitRuleUnaryExpression2(self)



    def ruleUnaryExpression(self):

        localctx = KerMLv2Parser.RuleUnaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_ruleUnaryExpression)
        try:
            self.state = 2051
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [92, 114, 135, 136]:
                localctx = KerMLv2Parser.RuleUnaryExpression1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2047
                self.ruleUnaryOperator()
                self.state = 2048
                self.ruleExtentExpression()
                pass
            elif token in [14, 76, 77, 93, 102, 106, 112, 121, 142, 143, 144, 145, 146]:
                localctx = KerMLv2Parser.RuleUnaryExpression2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2050
                self.ruleExtentExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleUnaryOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleUnaryOperator

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleUnaryOperator4Context(RuleUnaryOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleUnaryOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_NOT(self):
            return self.getToken(KerMLv2Parser.K_NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleUnaryOperator4" ):
                listener.enterRuleUnaryOperator4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleUnaryOperator4" ):
                listener.exitRuleUnaryOperator4(self)


    class RuleUnaryOperator3Context(RuleUnaryOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleUnaryOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_TILDE(self):
            return self.getToken(KerMLv2Parser.OP_TILDE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleUnaryOperator3" ):
                listener.enterRuleUnaryOperator3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleUnaryOperator3" ):
                listener.exitRuleUnaryOperator3(self)


    class RuleUnaryOperator2Context(RuleUnaryOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleUnaryOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_MINUS(self):
            return self.getToken(KerMLv2Parser.OP_MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleUnaryOperator2" ):
                listener.enterRuleUnaryOperator2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleUnaryOperator2" ):
                listener.exitRuleUnaryOperator2(self)


    class RuleUnaryOperator1Context(RuleUnaryOperatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleUnaryOperatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_PLUS(self):
            return self.getToken(KerMLv2Parser.OP_PLUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleUnaryOperator1" ):
                listener.enterRuleUnaryOperator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleUnaryOperator1" ):
                listener.exitRuleUnaryOperator1(self)



    def ruleUnaryOperator(self):

        localctx = KerMLv2Parser.RuleUnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_ruleUnaryOperator)
        try:
            self.state = 2057
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [135]:
                localctx = KerMLv2Parser.RuleUnaryOperator1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2053
                self.match(KerMLv2Parser.OP_PLUS)
                pass
            elif token in [136]:
                localctx = KerMLv2Parser.RuleUnaryOperator2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2054
                self.match(KerMLv2Parser.OP_MINUS)
                pass
            elif token in [114]:
                localctx = KerMLv2Parser.RuleUnaryOperator3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2055
                self.match(KerMLv2Parser.OP_TILDE)
                pass
            elif token in [92]:
                localctx = KerMLv2Parser.RuleUnaryOperator4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2056
                self.match(KerMLv2Parser.K_NOT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleExtentExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleExtentExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleExtentExpression2Context(RuleExtentExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleExtentExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def rulePrimaryExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleExtentExpression2" ):
                listener.enterRuleExtentExpression2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleExtentExpression2" ):
                listener.exitRuleExtentExpression2(self)


    class RuleExtentExpression1Context(RuleExtentExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleExtentExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_ALL(self):
            return self.getToken(KerMLv2Parser.K_ALL, 0)
        def ruleTypeResultMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleTypeResultMemberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleExtentExpression1" ):
                listener.enterRuleExtentExpression1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleExtentExpression1" ):
                listener.exitRuleExtentExpression1(self)



    def ruleExtentExpression(self):

        localctx = KerMLv2Parser.RuleExtentExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_ruleExtentExpression)
        try:
            self.state = 2062
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14]:
                localctx = KerMLv2Parser.RuleExtentExpression1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2059
                self.match(KerMLv2Parser.K_ALL)
                self.state = 2060
                self.ruleTypeResultMember()
                pass
            elif token in [76, 77, 93, 102, 106, 112, 121, 142, 143, 144, 145, 146]:
                localctx = KerMLv2Parser.RuleExtentExpression2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2061
                self.rulePrimaryExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulePrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleBaseExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleBaseExpressionContext,0)


        def OP_DOT(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_DOT)
            else:
                return self.getToken(KerMLv2Parser.OP_DOT, i)

        def ruleFeatureChainMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFeatureChainMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureChainMemberContext,i)


        def OP_HASH(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_HASH)
            else:
                return self.getToken(KerMLv2Parser.OP_HASH, i)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.LPAREN)
            else:
                return self.getToken(KerMLv2Parser.LPAREN, i)

        def ruleSequenceExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleSequenceExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleSequenceExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.RPAREN)
            else:
                return self.getToken(KerMLv2Parser.RPAREN, i)

        def LSQUARE(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.LSQUARE)
            else:
                return self.getToken(KerMLv2Parser.LSQUARE, i)

        def RSQUARE(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.RSQUARE)
            else:
                return self.getToken(KerMLv2Parser.RSQUARE, i)

        def OP_MINUS_RANGLE(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_MINUS_RANGLE)
            else:
                return self.getToken(KerMLv2Parser.OP_MINUS_RANGLE, i)

        def ruleReferenceTyping(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleReferenceTypingContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleReferenceTypingContext,i)


        def ruleBodyExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleBodyExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleBodyExpressionContext,i)


        def OP_DOT_QMARK(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_DOT_QMARK)
            else:
                return self.getToken(KerMLv2Parser.OP_DOT_QMARK, i)

        def ruleFunctionReferenceExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleFunctionReferenceExpressionContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionReferenceExpressionContext,i)


        def ruleArgumentList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleArgumentListContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleArgumentListContext,i)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_rulePrimaryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePrimaryExpression" ):
                listener.enterRulePrimaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePrimaryExpression" ):
                listener.exitRulePrimaryExpression(self)




    def rulePrimaryExpression(self):

        localctx = KerMLv2Parser.RulePrimaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_rulePrimaryExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2064
            self.ruleBaseExpression()
            self.state = 2067
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,241,self._ctx)
            if la_ == 1:
                self.state = 2065
                self.match(KerMLv2Parser.OP_DOT)
                self.state = 2066
                self.ruleFeatureChainMember()


            self.state = 2097
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 105)) & ~0x3f) == 0 and ((1 << (_la - 105)) & 103079411713) != 0):
                self.state = 2089
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [122]:
                    self.state = 2069
                    self.match(KerMLv2Parser.OP_HASH)
                    self.state = 2070
                    self.match(KerMLv2Parser.LPAREN)
                    self.state = 2071
                    self.ruleSequenceExpression()
                    self.state = 2072
                    self.match(KerMLv2Parser.RPAREN)
                    pass
                elif token in [105]:
                    self.state = 2074
                    self.match(KerMLv2Parser.LSQUARE)
                    self.state = 2075
                    self.ruleSequenceExpression()
                    self.state = 2076
                    self.match(KerMLv2Parser.RSQUARE)
                    pass
                elif token in [140]:
                    self.state = 2078
                    self.match(KerMLv2Parser.OP_MINUS_RANGLE)
                    self.state = 2079
                    self.ruleReferenceTyping()
                    self.state = 2083
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [102]:
                        self.state = 2080
                        self.ruleBodyExpression()
                        pass
                    elif token in [144, 145]:
                        self.state = 2081
                        self.ruleFunctionReferenceExpression()
                        pass
                    elif token in [106]:
                        self.state = 2082
                        self.ruleArgumentList()
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass
                elif token in [121]:
                    self.state = 2085
                    self.match(KerMLv2Parser.OP_DOT)
                    self.state = 2086
                    self.ruleBodyExpression()
                    pass
                elif token in [141]:
                    self.state = 2087
                    self.match(KerMLv2Parser.OP_DOT_QMARK)
                    self.state = 2088
                    self.ruleBodyExpression()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2093
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,244,self._ctx)
                if la_ == 1:
                    self.state = 2091
                    self.match(KerMLv2Parser.OP_DOT)
                    self.state = 2092
                    self.ruleFeatureChainMember()


                self.state = 2099
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFunctionReferenceExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFunctionReferenceMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionReferenceMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFunctionReferenceExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFunctionReferenceExpression" ):
                listener.enterRuleFunctionReferenceExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFunctionReferenceExpression" ):
                listener.exitRuleFunctionReferenceExpression(self)




    def ruleFunctionReferenceExpression(self):

        localctx = KerMLv2Parser.RuleFunctionReferenceExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_ruleFunctionReferenceExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2100
            self.ruleFunctionReferenceMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFunctionReferenceMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFunctionReference(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFunctionReferenceContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFunctionReferenceMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFunctionReferenceMember" ):
                listener.enterRuleFunctionReferenceMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFunctionReferenceMember" ):
                listener.exitRuleFunctionReferenceMember(self)




    def ruleFunctionReferenceMember(self):

        localctx = KerMLv2Parser.RuleFunctionReferenceMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_ruleFunctionReferenceMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2102
            self.ruleFunctionReference()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFunctionReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleReferenceTyping(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleReferenceTypingContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFunctionReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFunctionReference" ):
                listener.enterRuleFunctionReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFunctionReference" ):
                listener.exitRuleFunctionReference(self)




    def ruleFunctionReference(self):

        localctx = KerMLv2Parser.RuleFunctionReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_ruleFunctionReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2104
            self.ruleReferenceTyping()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureChainMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureChainMember

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFeatureChainMember1Context(RuleFeatureChainMemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureChainMemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureChainMember1" ):
                listener.enterRuleFeatureChainMember1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureChainMember1" ):
                listener.exitRuleFeatureChainMember1(self)


    class RuleFeatureChainMember2Context(RuleFeatureChainMemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureChainMemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleOwnedFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureChainMember2" ):
                listener.enterRuleFeatureChainMember2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureChainMember2" ):
                listener.exitRuleFeatureChainMember2(self)



    def ruleFeatureChainMember(self):

        localctx = KerMLv2Parser.RuleFeatureChainMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_ruleFeatureChainMember)
        try:
            self.state = 2108
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,246,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleFeatureChainMember1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2106
                self.ruleQualifiedName()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleFeatureChainMember2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2107
                self.ruleOwnedFeatureChain()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBaseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleBaseExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleBaseExpression4Context(RuleBaseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBaseExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleMetadataAccessExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleMetadataAccessExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBaseExpression4" ):
                listener.enterRuleBaseExpression4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBaseExpression4" ):
                listener.exitRuleBaseExpression4(self)


    class RuleBaseExpression3Context(RuleBaseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBaseExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleFeatureReferenceExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureReferenceExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBaseExpression3" ):
                listener.enterRuleBaseExpression3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBaseExpression3" ):
                listener.exitRuleBaseExpression3(self)


    class RuleBaseExpression2Context(RuleBaseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBaseExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleLiteralExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleLiteralExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBaseExpression2" ):
                listener.enterRuleBaseExpression2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBaseExpression2" ):
                listener.exitRuleBaseExpression2(self)


    class RuleBaseExpression1Context(RuleBaseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBaseExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleNullExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNullExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBaseExpression1" ):
                listener.enterRuleBaseExpression1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBaseExpression1" ):
                listener.exitRuleBaseExpression1(self)


    class RuleBaseExpression7Context(RuleBaseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBaseExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(KerMLv2Parser.LPAREN, 0)
        def ruleSequenceExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSequenceExpressionContext,0)

        def RPAREN(self):
            return self.getToken(KerMLv2Parser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBaseExpression7" ):
                listener.enterRuleBaseExpression7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBaseExpression7" ):
                listener.exitRuleBaseExpression7(self)


    class RuleBaseExpression6Context(RuleBaseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBaseExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleBodyExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleBodyExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBaseExpression6" ):
                listener.enterRuleBaseExpression6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBaseExpression6" ):
                listener.exitRuleBaseExpression6(self)


    class RuleBaseExpression5Context(RuleBaseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBaseExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleInvocationExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleInvocationExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBaseExpression5" ):
                listener.enterRuleBaseExpression5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBaseExpression5" ):
                listener.exitRuleBaseExpression5(self)



    def ruleBaseExpression(self):

        localctx = KerMLv2Parser.RuleBaseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 444, self.RULE_ruleBaseExpression)
        try:
            self.state = 2120
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,247,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleBaseExpression1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2110
                self.ruleNullExpression()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleBaseExpression2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2111
                self.ruleLiteralExpression()
                pass

            elif la_ == 3:
                localctx = KerMLv2Parser.RuleBaseExpression3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2112
                self.ruleFeatureReferenceExpression()
                pass

            elif la_ == 4:
                localctx = KerMLv2Parser.RuleBaseExpression4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2113
                self.ruleMetadataAccessExpression()
                pass

            elif la_ == 5:
                localctx = KerMLv2Parser.RuleBaseExpression5Context(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2114
                self.ruleInvocationExpression()
                pass

            elif la_ == 6:
                localctx = KerMLv2Parser.RuleBaseExpression6Context(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 2115
                self.ruleBodyExpression()
                pass

            elif la_ == 7:
                localctx = KerMLv2Parser.RuleBaseExpression7Context(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 2116
                self.match(KerMLv2Parser.LPAREN)
                self.state = 2117
                self.ruleSequenceExpression()
                self.state = 2118
                self.match(KerMLv2Parser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBodyExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleExpressionBodyMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExpressionBodyMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleBodyExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBodyExpression" ):
                listener.enterRuleBodyExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBodyExpression" ):
                listener.exitRuleBodyExpression(self)




    def ruleBodyExpression(self):

        localctx = KerMLv2Parser.RuleBodyExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 446, self.RULE_ruleBodyExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2122
            self.ruleExpressionBodyMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleExpressionBodyMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleExpressionBody(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleExpressionBodyContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleExpressionBodyMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleExpressionBodyMember" ):
                listener.enterRuleExpressionBodyMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleExpressionBodyMember" ):
                listener.exitRuleExpressionBodyMember(self)




    def ruleExpressionBodyMember(self):

        localctx = KerMLv2Parser.RuleExpressionBodyMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 448, self.RULE_ruleExpressionBodyMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2124
            self.ruleExpressionBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBodyParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleBodyParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBodyParameter" ):
                listener.enterRuleBodyParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBodyParameter" ):
                listener.exitRuleBodyParameter(self)




    def ruleBodyParameter(self):

        localctx = KerMLv2Parser.RuleBodyParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 450, self.RULE_ruleBodyParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2126
            self.ruleName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleSequenceExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedExpressionContext,0)


        def OP_COMMA(self):
            return self.getToken(KerMLv2Parser.OP_COMMA, 0)

        def ruleSequenceExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleSequenceExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleSequenceExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleSequenceExpression" ):
                listener.enterRuleSequenceExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleSequenceExpression" ):
                listener.exitRuleSequenceExpression(self)




    def ruleSequenceExpression(self):

        localctx = KerMLv2Parser.RuleSequenceExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 452, self.RULE_ruleSequenceExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2128
            self.ruleOwnedExpression()
            self.state = 2132
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,248,self._ctx)
            if la_ == 1:
                self.state = 2129
                self.match(KerMLv2Parser.OP_COMMA)

            elif la_ == 2:
                self.state = 2130
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 2131
                self.ruleSequenceExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureReferenceExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeatureReferenceMember(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureReferenceMemberContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureReferenceExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureReferenceExpression" ):
                listener.enterRuleFeatureReferenceExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureReferenceExpression" ):
                listener.exitRuleFeatureReferenceExpression(self)




    def ruleFeatureReferenceExpression(self):

        localctx = KerMLv2Parser.RuleFeatureReferenceExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 454, self.RULE_ruleFeatureReferenceExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2134
            self.ruleFeatureReferenceMember()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureReferenceMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureReferenceMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureReferenceMember" ):
                listener.enterRuleFeatureReferenceMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureReferenceMember" ):
                listener.exitRuleFeatureReferenceMember(self)




    def ruleFeatureReferenceMember(self):

        localctx = KerMLv2Parser.RuleFeatureReferenceMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 456, self.RULE_ruleFeatureReferenceMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2136
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleMetadataAccessExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def OP_DOT(self):
            return self.getToken(KerMLv2Parser.OP_DOT, 0)

        def K_METADATA(self):
            return self.getToken(KerMLv2Parser.K_METADATA, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleMetadataAccessExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleMetadataAccessExpression" ):
                listener.enterRuleMetadataAccessExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleMetadataAccessExpression" ):
                listener.exitRuleMetadataAccessExpression(self)




    def ruleMetadataAccessExpression(self):

        localctx = KerMLv2Parser.RuleMetadataAccessExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 458, self.RULE_ruleMetadataAccessExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2138
            self.ruleQualifiedName()
            self.state = 2139
            self.match(KerMLv2Parser.OP_DOT)
            self.state = 2140
            self.match(KerMLv2Parser.K_METADATA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleInvocationExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedFeatureTyping(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureTypingContext,0)


        def ruleArgumentList(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleArgumentListContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleInvocationExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleInvocationExpression" ):
                listener.enterRuleInvocationExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleInvocationExpression" ):
                listener.exitRuleInvocationExpression(self)




    def ruleInvocationExpression(self):

        localctx = KerMLv2Parser.RuleInvocationExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 460, self.RULE_ruleInvocationExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2142
            self.ruleOwnedFeatureTyping()
            self.state = 2143
            self.ruleArgumentList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedFeatureChainContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleFeatureChain(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleFeatureChainContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedFeatureChain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedFeatureChain" ):
                listener.enterRuleOwnedFeatureChain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedFeatureChain" ):
                listener.exitRuleOwnedFeatureChain(self)




    def ruleOwnedFeatureChain(self):

        localctx = KerMLv2Parser.RuleOwnedFeatureChainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 462, self.RULE_ruleOwnedFeatureChain)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2145
            self.ruleFeatureChain()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureChainContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedFeatureChaining(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleOwnedFeatureChainingContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedFeatureChainingContext,i)


        def OP_DOT(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_DOT)
            else:
                return self.getToken(KerMLv2Parser.OP_DOT, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureChain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureChain" ):
                listener.enterRuleFeatureChain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureChain" ):
                listener.exitRuleFeatureChain(self)




    def ruleFeatureChain(self):

        localctx = KerMLv2Parser.RuleFeatureChainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 464, self.RULE_ruleFeatureChain)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2147
            self.ruleOwnedFeatureChaining()
            self.state = 2150 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2148
                    self.match(KerMLv2Parser.OP_DOT)
                    self.state = 2149
                    self.ruleOwnedFeatureChaining()

                else:
                    raise NoViableAltException(self)
                self.state = 2152 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,249,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOwnedFeatureChainingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleOwnedFeatureChaining

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOwnedFeatureChaining" ):
                listener.enterRuleOwnedFeatureChaining(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOwnedFeatureChaining" ):
                listener.exitRuleOwnedFeatureChaining(self)




    def ruleOwnedFeatureChaining(self):

        localctx = KerMLv2Parser.RuleOwnedFeatureChainingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 466, self.RULE_ruleOwnedFeatureChaining)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2154
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(KerMLv2Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(KerMLv2Parser.RPAREN, 0)

        def rulePositionalArgumentList(self):
            return self.getTypedRuleContext(KerMLv2Parser.RulePositionalArgumentListContext,0)


        def ruleNamedArgumentList(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNamedArgumentListContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleArgumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleArgumentList" ):
                listener.enterRuleArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleArgumentList" ):
                listener.exitRuleArgumentList(self)




    def ruleArgumentList(self):

        localctx = KerMLv2Parser.RuleArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 468, self.RULE_ruleArgumentList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2156
            self.match(KerMLv2Parser.LPAREN)
            self.state = 2159
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,250,self._ctx)
            if la_ == 1:
                self.state = 2157
                self.rulePositionalArgumentList()

            elif la_ == 2:
                self.state = 2158
                self.ruleNamedArgumentList()


            self.state = 2161
            self.match(KerMLv2Parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RulePositionalArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleArgumentMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleArgumentMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleArgumentMemberContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_rulePositionalArgumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRulePositionalArgumentList" ):
                listener.enterRulePositionalArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRulePositionalArgumentList" ):
                listener.exitRulePositionalArgumentList(self)




    def rulePositionalArgumentList(self):

        localctx = KerMLv2Parser.RulePositionalArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 470, self.RULE_rulePositionalArgumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2163
            self.ruleArgumentMember()
            self.state = 2168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 2164
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 2165
                self.ruleArgumentMember()
                self.state = 2170
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleArgumentMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleArgument(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleArgumentContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleArgumentMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleArgumentMember" ):
                listener.enterRuleArgumentMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleArgumentMember" ):
                listener.exitRuleArgumentMember(self)




    def ruleArgumentMember(self):

        localctx = KerMLv2Parser.RuleArgumentMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 472, self.RULE_ruleArgumentMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2171
            self.ruleArgument()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleArgumentValue(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleArgumentValueContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleArgument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleArgument" ):
                listener.enterRuleArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleArgument" ):
                listener.exitRuleArgument(self)




    def ruleArgument(self):

        localctx = KerMLv2Parser.RuleArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 474, self.RULE_ruleArgument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2173
            self.ruleArgumentValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamedArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleNamedArgumentMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNamedArgumentMemberContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNamedArgumentMemberContext,i)


        def OP_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COMMA)
            else:
                return self.getToken(KerMLv2Parser.OP_COMMA, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamedArgumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamedArgumentList" ):
                listener.enterRuleNamedArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamedArgumentList" ):
                listener.exitRuleNamedArgumentList(self)




    def ruleNamedArgumentList(self):

        localctx = KerMLv2Parser.RuleNamedArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 476, self.RULE_ruleNamedArgumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2175
            self.ruleNamedArgumentMember()
            self.state = 2180
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==109:
                self.state = 2176
                self.match(KerMLv2Parser.OP_COMMA)
                self.state = 2177
                self.ruleNamedArgumentMember()
                self.state = 2182
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamedArgumentMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleNamedArgument(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNamedArgumentContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamedArgumentMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamedArgumentMember" ):
                listener.enterRuleNamedArgumentMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamedArgumentMember" ):
                listener.exitRuleNamedArgumentMember(self)




    def ruleNamedArgumentMember(self):

        localctx = KerMLv2Parser.RuleNamedArgumentMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 478, self.RULE_ruleNamedArgumentMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2183
            self.ruleNamedArgument()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNamedArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleParameterRedefinition(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleParameterRedefinitionContext,0)


        def OP_EQ(self):
            return self.getToken(KerMLv2Parser.OP_EQ, 0)

        def ruleArgumentValue(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleArgumentValueContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNamedArgument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNamedArgument" ):
                listener.enterRuleNamedArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNamedArgument" ):
                listener.exitRuleNamedArgument(self)




    def ruleNamedArgument(self):

        localctx = KerMLv2Parser.RuleNamedArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 480, self.RULE_ruleNamedArgument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2185
            self.ruleParameterRedefinition()
            self.state = 2186
            self.match(KerMLv2Parser.OP_EQ)
            self.state = 2187
            self.ruleArgumentValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleParameterRedefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleQualifiedName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualifiedNameContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleParameterRedefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleParameterRedefinition" ):
                listener.enterRuleParameterRedefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleParameterRedefinition" ):
                listener.exitRuleParameterRedefinition(self)




    def ruleParameterRedefinition(self):

        localctx = KerMLv2Parser.RuleParameterRedefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 482, self.RULE_ruleParameterRedefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2189
            self.ruleQualifiedName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleArgumentValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleOwnedExpression(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleOwnedExpressionContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleArgumentValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleArgumentValue" ):
                listener.enterRuleArgumentValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleArgumentValue" ):
                listener.exitRuleArgumentValue(self)




    def ruleArgumentValue(self):

        localctx = KerMLv2Parser.RuleArgumentValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 484, self.RULE_ruleArgumentValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2191
            self.ruleOwnedExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNullExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_NULL(self):
            return self.getToken(KerMLv2Parser.K_NULL, 0)

        def LPAREN(self):
            return self.getToken(KerMLv2Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(KerMLv2Parser.RPAREN, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleNullExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleNullExpression" ):
                listener.enterRuleNullExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleNullExpression" ):
                listener.exitRuleNullExpression(self)




    def ruleNullExpression(self):

        localctx = KerMLv2Parser.RuleNullExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 486, self.RULE_ruleNullExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2196
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [93]:
                self.state = 2193
                self.match(KerMLv2Parser.K_NULL)
                pass
            elif token in [106]:
                self.state = 2194
                self.match(KerMLv2Parser.LPAREN)
                self.state = 2195
                self.match(KerMLv2Parser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleLiteralExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleLiteralExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleLiteralExpression1Context(RuleLiteralExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleLiteralExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleLiteralBoolean(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleLiteralBooleanContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralExpression1" ):
                listener.enterRuleLiteralExpression1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralExpression1" ):
                listener.exitRuleLiteralExpression1(self)


    class RuleLiteralExpression2Context(RuleLiteralExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleLiteralExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleLiteralString(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleLiteralStringContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralExpression2" ):
                listener.enterRuleLiteralExpression2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralExpression2" ):
                listener.exitRuleLiteralExpression2(self)


    class RuleLiteralExpression3Context(RuleLiteralExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleLiteralExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleLiteralInteger(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleLiteralIntegerContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralExpression3" ):
                listener.enterRuleLiteralExpression3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralExpression3" ):
                listener.exitRuleLiteralExpression3(self)


    class RuleLiteralExpression4Context(RuleLiteralExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleLiteralExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleLiteralReal(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleLiteralRealContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralExpression4" ):
                listener.enterRuleLiteralExpression4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralExpression4" ):
                listener.exitRuleLiteralExpression4(self)


    class RuleLiteralExpression5Context(RuleLiteralExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleLiteralExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ruleLiteralInfinity(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleLiteralInfinityContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralExpression5" ):
                listener.enterRuleLiteralExpression5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralExpression5" ):
                listener.exitRuleLiteralExpression5(self)



    def ruleLiteralExpression(self):

        localctx = KerMLv2Parser.RuleLiteralExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 488, self.RULE_ruleLiteralExpression)
        try:
            self.state = 2203
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,254,self._ctx)
            if la_ == 1:
                localctx = KerMLv2Parser.RuleLiteralExpression1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2198
                self.ruleLiteralBoolean()
                pass

            elif la_ == 2:
                localctx = KerMLv2Parser.RuleLiteralExpression2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2199
                self.ruleLiteralString()
                pass

            elif la_ == 3:
                localctx = KerMLv2Parser.RuleLiteralExpression3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2200
                self.ruleLiteralInteger()
                pass

            elif la_ == 4:
                localctx = KerMLv2Parser.RuleLiteralExpression4Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2201
                self.ruleLiteralReal()
                pass

            elif la_ == 5:
                localctx = KerMLv2Parser.RuleLiteralExpression5Context(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2202
                self.ruleLiteralInfinity()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleLiteralBooleanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleBooleanValue(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleBooleanValueContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleLiteralBoolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralBoolean" ):
                listener.enterRuleLiteralBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralBoolean" ):
                listener.exitRuleLiteralBoolean(self)




    def ruleLiteralBoolean(self):

        localctx = KerMLv2Parser.RuleLiteralBooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 490, self.RULE_ruleLiteralBoolean)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2205
            self.ruleBooleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleBooleanValue

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleBooleanValue1Context(RuleBooleanValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBooleanValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_TRUE(self):
            return self.getToken(KerMLv2Parser.K_TRUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBooleanValue1" ):
                listener.enterRuleBooleanValue1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBooleanValue1" ):
                listener.exitRuleBooleanValue1(self)


    class RuleBooleanValue2Context(RuleBooleanValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleBooleanValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_FALSE(self):
            return self.getToken(KerMLv2Parser.K_FALSE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBooleanValue2" ):
                listener.enterRuleBooleanValue2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBooleanValue2" ):
                listener.exitRuleBooleanValue2(self)



    def ruleBooleanValue(self):

        localctx = KerMLv2Parser.RuleBooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 492, self.RULE_ruleBooleanValue)
        try:
            self.state = 2209
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [76]:
                localctx = KerMLv2Parser.RuleBooleanValue1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2207
                self.match(KerMLv2Parser.K_TRUE)
                pass
            elif token in [77]:
                localctx = KerMLv2Parser.RuleBooleanValue2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2208
                self.match(KerMLv2Parser.K_FALSE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleLiteralStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULE_STRING_VALUE(self):
            return self.getToken(KerMLv2Parser.RULE_STRING_VALUE, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleLiteralString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralString" ):
                listener.enterRuleLiteralString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralString" ):
                listener.exitRuleLiteralString(self)




    def ruleLiteralString(self):

        localctx = KerMLv2Parser.RuleLiteralStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 494, self.RULE_ruleLiteralString)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2211
            self.match(KerMLv2Parser.RULE_STRING_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleLiteralIntegerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULE_DECIMAL_VALUE(self):
            return self.getToken(KerMLv2Parser.RULE_DECIMAL_VALUE, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleLiteralInteger

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralInteger" ):
                listener.enterRuleLiteralInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralInteger" ):
                listener.exitRuleLiteralInteger(self)




    def ruleLiteralInteger(self):

        localctx = KerMLv2Parser.RuleLiteralIntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 496, self.RULE_ruleLiteralInteger)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2213
            self.match(KerMLv2Parser.RULE_DECIMAL_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleLiteralRealContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleRealValue(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleRealValueContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleLiteralReal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralReal" ):
                listener.enterRuleLiteralReal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralReal" ):
                listener.exitRuleLiteralReal(self)




    def ruleLiteralReal(self):

        localctx = KerMLv2Parser.RuleLiteralRealContext(self, self._ctx, self.state)
        self.enterRule(localctx, 498, self.RULE_ruleLiteralReal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2215
            self.ruleRealValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleRealValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleRealValue

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleRealValue2Context(RuleRealValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRealValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RULE_EXP_VALUE(self):
            return self.getToken(KerMLv2Parser.RULE_EXP_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRealValue2" ):
                listener.enterRuleRealValue2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRealValue2" ):
                listener.exitRuleRealValue2(self)


    class RuleRealValue1Context(RuleRealValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleRealValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OP_DOT(self):
            return self.getToken(KerMLv2Parser.OP_DOT, 0)
        def RULE_DECIMAL_VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.RULE_DECIMAL_VALUE)
            else:
                return self.getToken(KerMLv2Parser.RULE_DECIMAL_VALUE, i)
        def RULE_EXP_VALUE(self):
            return self.getToken(KerMLv2Parser.RULE_EXP_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleRealValue1" ):
                listener.enterRuleRealValue1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleRealValue1" ):
                listener.exitRuleRealValue1(self)



    def ruleRealValue(self):

        localctx = KerMLv2Parser.RuleRealValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 500, self.RULE_ruleRealValue)
        self._la = 0 # Token type
        try:
            self.state = 2223
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [121, 142]:
                localctx = KerMLv2Parser.RuleRealValue1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2218
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==142:
                    self.state = 2217
                    self.match(KerMLv2Parser.RULE_DECIMAL_VALUE)


                self.state = 2220
                self.match(KerMLv2Parser.OP_DOT)
                self.state = 2221
                _la = self._input.LA(1)
                if not(_la==142 or _la==143):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [143]:
                localctx = KerMLv2Parser.RuleRealValue2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2222
                self.match(KerMLv2Parser.RULE_EXP_VALUE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleLiteralInfinityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP_STAR(self):
            return self.getToken(KerMLv2Parser.OP_STAR, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleLiteralInfinity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleLiteralInfinity" ):
                listener.enterRuleLiteralInfinity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleLiteralInfinity" ):
                listener.exitRuleLiteralInfinity(self)




    def ruleLiteralInfinity(self):

        localctx = KerMLv2Parser.RuleLiteralInfinityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 502, self.RULE_ruleLiteralInfinity)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2225
            self.match(KerMLv2Parser.OP_STAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleName

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleName1Context(RuleNameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNameContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RULE_ID(self):
            return self.getToken(KerMLv2Parser.RULE_ID, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleName1" ):
                listener.enterRuleName1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleName1" ):
                listener.exitRuleName1(self)


    class RuleName2Context(RuleNameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleNameContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RULE_UNRESTRICTED_NAME(self):
            return self.getToken(KerMLv2Parser.RULE_UNRESTRICTED_NAME, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleName2" ):
                listener.enterRuleName2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleName2" ):
                listener.exitRuleName2(self)



    def ruleName(self):

        localctx = KerMLv2Parser.RuleNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 504, self.RULE_ruleName)
        try:
            self.state = 2229
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [144]:
                localctx = KerMLv2Parser.RuleName1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2227
                self.match(KerMLv2Parser.RULE_ID)
                pass
            elif token in [145]:
                localctx = KerMLv2Parser.RuleName2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2228
                self.match(KerMLv2Parser.RULE_UNRESTRICTED_NAME)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleQualificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(KerMLv2Parser.RuleNameContext)
            else:
                return self.getTypedRuleContext(KerMLv2Parser.RuleNameContext,i)


        def OP_COLON_COLON(self, i:int=None):
            if i is None:
                return self.getTokens(KerMLv2Parser.OP_COLON_COLON)
            else:
                return self.getToken(KerMLv2Parser.OP_COLON_COLON, i)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleQualification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleQualification" ):
                listener.enterRuleQualification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleQualification" ):
                listener.exitRuleQualification(self)




    def ruleQualification(self):

        localctx = KerMLv2Parser.RuleQualificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 506, self.RULE_ruleQualification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2234 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2231
                    self.ruleName()
                    self.state = 2232
                    self.match(KerMLv2Parser.OP_COLON_COLON)

                else:
                    raise NoViableAltException(self)
                self.state = 2236 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,259,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleQualifiedNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleName(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleNameContext,0)


        def ruleQualification(self):
            return self.getTypedRuleContext(KerMLv2Parser.RuleQualificationContext,0)


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleQualifiedName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleQualifiedName" ):
                listener.enterRuleQualifiedName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleQualifiedName" ):
                listener.exitRuleQualifiedName(self)




    def ruleQualifiedName(self):

        localctx = KerMLv2Parser.RuleQualifiedNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 508, self.RULE_ruleQualifiedName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2239
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,260,self._ctx)
            if la_ == 1:
                self.state = 2238
                self.ruleQualification()


            self.state = 2241
            self.ruleName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFilterPackageMemberVisibilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LSQUARE(self):
            return self.getToken(KerMLv2Parser.LSQUARE, 0)

        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFilterPackageMemberVisibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFilterPackageMemberVisibility" ):
                listener.enterRuleFilterPackageMemberVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFilterPackageMemberVisibility" ):
                listener.exitRuleFilterPackageMemberVisibility(self)




    def ruleFilterPackageMemberVisibility(self):

        localctx = KerMLv2Parser.RuleFilterPackageMemberVisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 510, self.RULE_ruleFilterPackageMemberVisibility)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2243
            self.match(KerMLv2Parser.LSQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleVisibilityIndicatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleVisibilityIndicator

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleVisibilityIndicator3Context(RuleVisibilityIndicatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleVisibilityIndicatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_PROTECTED(self):
            return self.getToken(KerMLv2Parser.K_PROTECTED, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleVisibilityIndicator3" ):
                listener.enterRuleVisibilityIndicator3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleVisibilityIndicator3" ):
                listener.exitRuleVisibilityIndicator3(self)


    class RuleVisibilityIndicator1Context(RuleVisibilityIndicatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleVisibilityIndicatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_PUBLIC(self):
            return self.getToken(KerMLv2Parser.K_PUBLIC, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleVisibilityIndicator1" ):
                listener.enterRuleVisibilityIndicator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleVisibilityIndicator1" ):
                listener.exitRuleVisibilityIndicator1(self)


    class RuleVisibilityIndicator2Context(RuleVisibilityIndicatorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleVisibilityIndicatorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_PRIVATE(self):
            return self.getToken(KerMLv2Parser.K_PRIVATE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleVisibilityIndicator2" ):
                listener.enterRuleVisibilityIndicator2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleVisibilityIndicator2" ):
                listener.exitRuleVisibilityIndicator2(self)



    def ruleVisibilityIndicator(self):

        localctx = KerMLv2Parser.RuleVisibilityIndicatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 512, self.RULE_ruleVisibilityIndicator)
        try:
            self.state = 2248
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [94]:
                localctx = KerMLv2Parser.RuleVisibilityIndicator1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2245
                self.match(KerMLv2Parser.K_PUBLIC)
                pass
            elif token in [95]:
                localctx = KerMLv2Parser.RuleVisibilityIndicator2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2246
                self.match(KerMLv2Parser.K_PRIVATE)
                pass
            elif token in [96]:
                localctx = KerMLv2Parser.RuleVisibilityIndicator3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2247
                self.match(KerMLv2Parser.K_PROTECTED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleFeatureDirectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return KerMLv2Parser.RULE_ruleFeatureDirection

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RuleFeatureDirection1Context(RuleFeatureDirectionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureDirectionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_IN(self):
            return self.getToken(KerMLv2Parser.K_IN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureDirection1" ):
                listener.enterRuleFeatureDirection1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureDirection1" ):
                listener.exitRuleFeatureDirection1(self)


    class RuleFeatureDirection2Context(RuleFeatureDirectionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureDirectionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_OUT(self):
            return self.getToken(KerMLv2Parser.K_OUT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureDirection2" ):
                listener.enterRuleFeatureDirection2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureDirection2" ):
                listener.exitRuleFeatureDirection2(self)


    class RuleFeatureDirection3Context(RuleFeatureDirectionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a KerMLv2Parser.RuleFeatureDirectionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_INOUT(self):
            return self.getToken(KerMLv2Parser.K_INOUT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleFeatureDirection3" ):
                listener.enterRuleFeatureDirection3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleFeatureDirection3" ):
                listener.exitRuleFeatureDirection3(self)



    def ruleFeatureDirection(self):

        localctx = KerMLv2Parser.RuleFeatureDirectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 514, self.RULE_ruleFeatureDirection)
        try:
            self.state = 2253
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [97]:
                localctx = KerMLv2Parser.RuleFeatureDirection1Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2250
                self.match(KerMLv2Parser.K_IN)
                pass
            elif token in [98]:
                localctx = KerMLv2Parser.RuleFeatureDirection2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2251
                self.match(KerMLv2Parser.K_OUT)
                pass
            elif token in [99]:
                localctx = KerMLv2Parser.RuleFeatureDirection3Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2252
                self.match(KerMLv2Parser.K_INOUT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





